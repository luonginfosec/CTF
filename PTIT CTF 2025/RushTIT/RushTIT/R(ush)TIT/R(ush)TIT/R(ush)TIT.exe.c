/* This file was generated by the Hex-Rays decompiler version 9.0.0.241217.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_7FF7053E31E0(__int64);
unsigned __int64 *__fastcall sub_7FF7053E5AA0(unsigned __int64 *, int, __int64);
__int64 __fastcall sub_7FF7053EC5E0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_7FF7053F0E90(__int64, unsigned __int8 *, unsigned __int64);
void __fastcall __noreturn sub_7FF7053FE4D0(__int64, __int64, __int64);

//-------------------------------------------------------------------------
// Data declarations

char *off_7FF7053FF878 = "src\\main.rs"; // weak


//----- (00007FF7053E1000) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053E1000()
{
  __int64 copy_inp; // rax
  __int64 v1; // rdx
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rdx
  int *v5; // rdx
  int v7; // [rsp+2Ch] [rbp-54h]
  unsigned __int64 lenInp; // [rsp+98h] [rbp+18h]
  __int64 v9; // [rsp+A0h] [rbp+20h]
  int (__cdecl *inp)(unsigned __int16); // [rsp+A8h] [rbp+28h]
  _QWORD v11[2]; // [rsp+D0h] [rbp+50h] BYREF
  _QWORD v12[6]; // [rsp+E0h] [rbp+60h] BYREF
  __int128 v13; // [rsp+110h] [rbp+90h] BYREF
  __int128 v14; // [rsp+128h] [rbp+A8h] BYREF
  unsigned __int64 v15[3]; // [rsp+138h] [rbp+B8h] BYREF
  __int128 v16[2]; // [rsp+150h] [rbp+D0h] BYREF
  _QWORD v17[6]; // [rsp+170h] [rbp+F0h] BYREF
  __int128 v18; // [rsp+1A0h] [rbp+120h] BYREF
  __int128 v19; // [rsp+1B8h] [rbp+138h] BYREF
  unsigned __int64 v20[6]; // [rsp+1C8h] [rbp+148h] BYREF
  unsigned __int64 v21[3]; // [rsp+1F8h] [rbp+178h] BYREF
  __int64 v22[2]; // [rsp+210h] [rbp+190h] BYREF
  _BYTE *v23; // [rsp+220h] [rbp+1A0h]
  char v24; // [rsp+22Fh] [rbp+1AFh] BYREF
  _DWORD v25[42]; // [rsp+230h] [rbp+1B0h]
  _QWORD v26[3]; // [rsp+2D8h] [rbp+258h] BYREF
  _QWORD v27[3]; // [rsp+2F0h] [rbp+270h] BYREF
  __int64 v28[3]; // [rsp+308h] [rbp+288h] BYREF
  unsigned __int64 v29; // [rsp+320h] [rbp+2A0h]
  int *v30; // [rsp+328h] [rbp+2A8h]
  _QWORD v31[6]; // [rsp+330h] [rbp+2B0h] BYREF
  _QWORD v32[8]; // [rsp+360h] [rbp+2E0h] BYREF
  int v33; // [rsp+3A4h] [rbp+324h]
  _BYTE *v34; // [rsp+3A8h] [rbp+328h]
  int v35; // [rsp+3B4h] [rbp+334h]
  __int64 v36; // [rsp+3B8h] [rbp+338h]

  v36 = -2LL;
  v11[0] = asc_7FF7053FF380;
  v11[1] = 1097LL;
  sub_7FF7053E4220(&v14, v11);
  v13 = v14;
  sub_7FF7053E1C70(v12, &unk_7FF7053FF7D0, &v13);
  sub_7FF7053EA750(v12);
  sub_7FF7053E88E0(v16);
  sub_7FF7053E4820(v15, v16);
  if ( sub_7FF7053E5A90(v15) != 2 )
  {
    v9 = sub_7FF7053E5D20(v15, 0LL, &off_7FF7053FF890);
    sub_7FF7053E41E0(&v19, v9);
    v18 = v19;
    sub_7FF7053E1C70(v17, &off_7FF7053FF8B8, &v18);
    sub_7FF7053EA860(v17);
    sub_7FF7053ECB90(1u);
  }
  inp = sub_7FF7053E5D20(v15, 1uLL, &off_7FF7053FF800);
  v32[6] = inp;
  lenInp = len(inp);
  if ( lenInp < 4 )
    sub_7FF7053FE560(&off_7FF7053FF818);
  if ( lenInp != 42 )
  {
    sub_7FF7053E1CC0(v20, &off_7FF7053FF868);
    sub_7FF7053EA860(v20);
    sub_7FF7053ECB90(1u);
  }
  sub_7FF7053E58A0(v21);
  copy_inp = sub_7FF7053E18B0(inp);
  v22[0] = sub_7FF7053E1D90(copy_inp);
  v22[1] = v1;
  while ( 1 )
  {
    v23 = sub_7FF7053E1E90(v22);
    if ( !v23 )
      break;
    v34 = v23;
    v24 = *v23;
    v35 = sub_7FF7053E1640(&v24, 1LL);
    sub_7FF7053E5AA0(v21, v35, &off_7FF7053FF878);
  }
  v25[0] = 0xB969BE79;
  v25[1] = 0xBE047A60;
  v25[2] = 0xDD0216B9;
  v25[3] = 0xBE047A60;
  v25[4] = 0x3DD7FFA7;
  v25[5] = 0xBE047A60;
  v25[6] = 0x4DBD0B28;
  v25[7] = 0x15D54739;
  v25[8] = 0x4AD0CF31;
  v25[9] = 0x83DCEFB7;
  v25[10] = 0x7808A3D2;
  v25[11] = 0x8D076785;
  v25[12] = -186917087;
  v25[13] = -1637089325;
  v25[14] = 701932520;
  v25[15] = 1466425173;
  v25[16] = -227710402;
  v25[17] = -2068763730;
  v25[18] = 1790921346;
  v25[19] = -69523947;
  v25[20] = 701932520;
  v25[21] = 1037565863;
  v25[22] = -206169288;
  v25[23] = 1812594589;
  v25[24] = 30677878;
  v25[25] = -186917087;
  v25[26] = 701932520;
  v25[27] = -2082672713;
  v25[28] = 2013832146;
  v25[29] = 701932520;
  v25[30] = -1107002784;
  v25[31] = -1855256857;
  v25[32] = 1842515611;
  v25[33] = 701932520;
  v25[34] = 1466425173;
  v25[35] = 1842515611;
  v25[36] = 1801730948;
  v25[37] = 1842515611;
  v25[38] = 0x6C09FF9D;
  v25[39] = 0x84B12BAE;
  v25[40] = 0x6DD28E9B;
  v25[41] = 0xFCB6E20C;
  v2 = sub_7FF7053E5D00(v21);
  v3 = sub_7FF7053E31E0(v2);
  sub_7FF7053E1D00(v27, v3, v4);
  sub_7FF7053E3AD0(v26, v27);
  v28[0] = v26[0];
  v28[1] = v26[1];
  v28[2] = v26[2];
  while ( 1 )
  {
    v29 = sub_7FF7053E39E0(v28);
    v30 = v5;
    if ( !v5 )
      break;
    v32[7] = v29;
    v7 = *v30;
    v33 = *v30;
    if ( v29 >= 42 )
      sub_7FF7053FE234(v29, 42LL, &off_7FF7053FF848);
    if ( v7 != v25[v29] )
    {
      sub_7FF7053E1CC0(v31, &off_7FF7053FF868);
      sub_7FF7053EA750(v31);
      sub_7FF7053ECB90(1u);
    }
  }
  sub_7FF7053E1CC0(v32, &off_7FF7053FF838);
  sub_7FF7053EA750(v32);
  sub_7FF7053E34E0(v21);
  return sub_7FF7053E3760(v15);
}
// 7FF7053E1191: variable 'v1' is possibly undefined
// 7FF7053E13E2: variable 'v4' is possibly undefined
// 7FF7053E144D: variable 'v5' is possibly undefined
// 7FF7053FF800: using guessed type char *off_7FF7053FF800;
// 7FF7053FF818: using guessed type char *off_7FF7053FF818;
// 7FF7053FF838: using guessed type char *off_7FF7053FF838;
// 7FF7053FF848: using guessed type char *off_7FF7053FF848;
// 7FF7053FF868: using guessed type char *off_7FF7053FF868;
// 7FF7053FF878: using guessed type char *off_7FF7053FF878;
// 7FF7053FF890: using guessed type char *off_7FF7053FF890;
// 7FF7053FF8B8: using guessed type char *off_7FF7053FF8B8;

//----- (00007FF7053E1640) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E1640(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  unsigned __int64 v3; // rdx
  int v4; // edx
  __int64 v5; // rdx
  unsigned __int64 v7; // [rsp+40h] [rbp-488h]
  _DWORD v9[256]; // [rsp+58h] [rbp-470h] BYREF
  __int64 v10[2]; // [rsp+458h] [rbp-70h] BYREF
  __int64 v11; // [rsp+468h] [rbp-60h]
  unsigned __int64 v12; // [rsp+470h] [rbp-58h]
  unsigned int v13; // [rsp+478h] [rbp-50h]
  int v14[2]; // [rsp+47Ch] [rbp-4Ch] BYREF
  unsigned int v15; // [rsp+484h] [rbp-44h]
  __int64 v16[2]; // [rsp+488h] [rbp-40h] BYREF
  char *v17; // [rsp+498h] [rbp-30h]
  __int64 v18; // [rsp+4A0h] [rbp-28h]
  __int64 v19; // [rsp+4A8h] [rbp-20h]
  char v20; // [rsp+4B7h] [rbp-11h]
  __int64 v21; // [rsp+4B8h] [rbp-10h]
  unsigned __int64 v22; // [rsp+4C0h] [rbp-8h]

  v18 = a1;
  v19 = a2;
  memset(v9, 0, sizeof(v9));
  v10[0] = sub_7FF7053E4570(0LL);
  v10[1] = v2;
  while ( 1 )
  {
    v11 = sub_7FF7053E4520(v10);
    v12 = v3;
    if ( (v11 & 1) == 0 )
      break;
    v7 = v12;
    v22 = v12;
    v13 = v12;
    v14[0] = sub_7FF7053E4560(0);
    v14[1] = v4;
    while ( (sub_7FF7053E4540(v14) & 1) != 0 )
    {
      if ( (v13 & 1) != 0 )
        v13 = (v13 >> 1) ^ 0xEDB88320;
      else
        v13 >>= 1;
    }
    if ( v7 >= 0x100 )
      sub_7FF7053FE234(v7, 256LL, &off_7FF7053FF8F0);
    v9[v7] = v13;
  }
  v15 = -1;
  v16[0] = sub_7FF7053E1D90(a1);
  v16[1] = v5;
  while ( 1 )
  {
    v17 = sub_7FF7053E1E90(v16);
    if ( !v17 )
      break;
    v20 = *v17;
    v21 = (v20 ^ v15);
    v15 = v9[v21] ^ (v15 >> 8);
  }
  return ~v15;
}
// 7FF7053E1689: variable 'v2' is possibly undefined
// 7FF7053E16A6: variable 'v3' is possibly undefined
// 7FF7053E16EB: variable 'v4' is possibly undefined
// 7FF7053E1719: variable 'v5' is possibly undefined
// 7FF7053FF8F0: using guessed type char *off_7FF7053FF8F0;

//----- (00007FF7053E1880) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
int __fastcall main(int argc, const char **argv, const char **envp)
{
  return sub_7FF7053E46E0(sub_7FF7053E1000, argc, argv, 0);
}

//----- (00007FF7053E18A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall len(__int64 a1)
{
  return *(a1 + 16);
}

//----- (00007FF7053E18B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E18B0(__int64 a1)
{
  return sub_7FF7053E5CA0(a1);
}

//----- (00007FF7053E18D0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E18D0(__int64 a1, __int64 *a2)
{
  unsigned __int16 *v4; // [rsp+30h] [rbp-48h]
  unsigned __int64 v5; // [rsp+38h] [rbp-40h]

  v4 = *(a1 + 8);
  v5 = *(a1 + 16);
  sub_7FF7053E1950(v4, 1uLL, 1uLL, v5, &off_7FF7053FF958);
  return sub_7FF7053FA4C0(v4, v5, a2) & 1;
}
// 7FF7053FF958: using guessed type char *off_7FF7053FF958;

//----- (00007FF7053E1950) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053E1950(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5)
{
  unsigned __int64 result; // rax
  __int128 v6; // [rsp+58h] [rbp-28h] BYREF
  __int64 v7; // [rsp+68h] [rbp-18h]
  __int64 v8; // [rsp+70h] [rbp-10h]
  __int64 v9; // [rsp+78h] [rbp-8h]
  _QWORD *v10; // [rsp+80h] [rbp+0h]
  _QWORD v11[2]; // [rsp+88h] [rbp+8h] BYREF
  _QWORD v12[6]; // [rsp+98h] [rbp+18h] BYREF
  unsigned __int64 v13; // [rsp+C8h] [rbp+48h]
  __int64 v14; // [rsp+D0h] [rbp+50h]
  unsigned __int64 v15; // [rsp+D8h] [rbp+58h]
  unsigned __int64 v16; // [rsp+E0h] [rbp+60h]
  unsigned __int64 v17; // [rsp+E8h] [rbp+68h]
  const char *v18; // [rsp+F0h] [rbp+70h]
  __int64 v19; // [rsp+F8h] [rbp+78h]
  char v20; // [rsp+106h] [rbp+86h]
  char v21; // [rsp+107h] [rbp+87h]
  char **v22; // [rsp+108h] [rbp+88h]
  __int64 v23; // [rsp+110h] [rbp+90h]
  unsigned int v24; // [rsp+11Ch] [rbp+9Ch]
  _QWORD *v25; // [rsp+120h] [rbp+A0h]
  __int64 v26; // [rsp+128h] [rbp+A8h]

  v26 = -2LL;
  v14 = a1;
  v15 = a2;
  v16 = a3;
  v17 = a4;
  v18 = aUnsafePrecondi;
  v19 = 279LL;
  v20 = 0;
  v21 = 0;
  v22 = &off_7FF7053FFAB8;
  v23 = a1;
  v24 = ((0x101010101010101LL
        * (((((((v16 - ((v16 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
            + ((v16 - ((v16 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) >> 4)
          + (((v16 - ((v16 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
          + ((v16 - ((v16 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) & 0xF0F0F0F0F0F0F0FLL)) >> 32) >> 24;
  if ( v24 != 1 )
  {
    v12[0] = &off_7FF7053FFAB8;
    v12[1] = 1LL;
    v12[4] = 0LL;
    v12[2] = 8LL;
    v12[3] = 0LL;
    try
    {
      sub_7FF7053FE110(v12, &off_7FF7053FFB88);
    }
    catch ( ... )
    {
      sub_7FF7053FE29A();
    }
  }
  if ( ((a3 - 1) & a1) != 0 || !a1 || (a2 ? (v13 = 0x7FFFFFFFFFFFFFFFLL / a2) : (v13 = -1LL), result = a4, a4 > v13) )
  {
    v11[0] = aUnsafePrecondi;
    v11[1] = 279LL;
    v25 = v11;
    *&v6 = v11;
    *(&v6 + 1) = 1LL;
    v9 = 0LL;
    v10 = v11;
    v7 = 8LL;
    v8 = 0LL;
    sub_7FF7053FE140(&v6, 0, a5);
  }
  return result;
}
// 7FF7053FE29A: using guessed type void __noreturn sub_7FF7053FE29A(void);
// 7FF7053FFAB8: using guessed type char *off_7FF7053FFAB8;
// 7FF7053FFB88: using guessed type char *off_7FF7053FFB88;

//----- (00007FF7053E1B90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 *__fastcall sub_7FF7053E1B90(unsigned __int64 *a1, __int64 a2)
{
  sub_7FF7053E3080(a1, a2);
  return a1;
}

//----- (00007FF7053E1BC0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
const char *__fastcall sub_7FF7053E1BC0(__int64 a1, __int64 a2)
{
  const char *result; // rax
  __int128 v3; // [rsp+28h] [rbp-60h] BYREF
  __int64 v4; // [rsp+38h] [rbp-50h]
  __int64 v5; // [rsp+40h] [rbp-48h]
  __int64 v6; // [rsp+48h] [rbp-40h]
  __int64 v7; // [rsp+50h] [rbp-38h]
  _QWORD v8[6]; // [rsp+58h] [rbp-30h] BYREF

  v8[2] = a1;
  result = aUnsafePrecondi_0;
  v8[3] = aUnsafePrecondi_0;
  v8[4] = 210LL;
  if ( !a1 )
  {
    v8[0] = aUnsafePrecondi_0;
    v8[1] = 210LL;
    v8[5] = v8;
    *&v3 = v8;
    *(&v3 + 1) = 1LL;
    v6 = 0LL;
    v7 = 0LL;
    v4 = 8LL;
    v5 = 0LL;
    sub_7FF7053FE140(&v3, 0, a2);
  }
  return result;
}

//----- (00007FF7053E1C70) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E1C70(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax

  result = a1;
  *a1 = a2;
  a1[1] = 2LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  a1[2] = a3;
  a1[3] = 1LL;
  return result;
}

//----- (00007FF7053E1CC0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E1CC0(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  result = a1;
  *a1 = a2;
  a1[1] = 1LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  a1[2] = 8LL;
  a1[3] = 0LL;
  return result;
}

//----- (00007FF7053E1D00) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E1D00(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax

  result = a1;
  *a1 = a2;
  a1[1] = a3;
  a1[2] = 0LL;
  return result;
}

//----- (00007FF7053E1D30) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E1D30(__int64 a1)
{
  return a1;
}

//----- (00007FF7053E1D90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E1D90(__int64 a1)
{
  return a1;
}

//----- (00007FF7053E1DE0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E1DE0(__int64 *a1)
{
  __int64 v3; // [rsp+18h] [rbp-58h] BYREF
  __int64 v4; // [rsp+20h] [rbp-50h] BYREF
  _QWORD v5[4]; // [rsp+28h] [rbp-48h] BYREF
  __int64 v6; // [rsp+48h] [rbp-28h]
  __int64 *v7; // [rsp+50h] [rbp-20h]
  __int64 *v8; // [rsp+58h] [rbp-18h]
  __int64 v9; // [rsp+60h] [rbp-10h]
  _QWORD *v10; // [rsp+68h] [rbp-8h]

  v5[1] = a1;
  v5[2] = 1LL;
  v5[3] = 1LL;
  v3 = *a1;
  v6 = a1[1];
  v7 = &v3;
  v4 = v6;
  v8 = &v4;
  if ( v3 == v6 )
    return 0LL;
  v9 = v3;
  *a1 = v3 + 4;
  v5[0] = v3;
  v10 = v5;
  return v3;
}

//----- (00007FF7053E1E90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E1E90(__int64 *a1)
{
  __int64 v3; // [rsp+18h] [rbp-58h] BYREF
  __int64 v4; // [rsp+20h] [rbp-50h] BYREF
  _QWORD v5[4]; // [rsp+28h] [rbp-48h] BYREF
  __int64 v6; // [rsp+48h] [rbp-28h]
  __int64 *v7; // [rsp+50h] [rbp-20h]
  __int64 *v8; // [rsp+58h] [rbp-18h]
  __int64 v9; // [rsp+60h] [rbp-10h]
  _QWORD *v10; // [rsp+68h] [rbp-8h]

  v5[1] = a1;
  v5[2] = 1LL;
  v5[3] = 1LL;
  v3 = *a1;
  v6 = a1[1];
  v7 = &v3;
  v4 = v6;
  v8 = &v4;
  if ( v3 == v6 )
    return 0LL;
  v9 = v3;
  *a1 = v3 + 1;
  v5[0] = v3;
  v10 = v5;
  return v3;
}

//----- (00007FF7053E1F40) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E1F40(_QWORD *a1, __int64 a2, unsigned __int64 a3, void **a4, __int64 a5)
{
  unsigned __int64 v5; // rax
  __int64 v6; // rdx
  unsigned __int64 v7; // rcx
  __int64 v8; // rcx
  void *v10; // [rsp+38h] [rbp-100h]
  void *v13; // [rsp+68h] [rbp-D0h] BYREF
  unsigned __int64 v14; // [rsp+70h] [rbp-C8h]
  __int64 v15; // [rsp+78h] [rbp-C0h]
  __int64 v16; // [rsp+80h] [rbp-B8h]
  void *v17; // [rsp+88h] [rbp-B0h] BYREF
  unsigned __int64 v18; // [rsp+90h] [rbp-A8h]
  __int64 v19; // [rsp+98h] [rbp-A0h]
  __int64 v20; // [rsp+A0h] [rbp-98h]
  __int64 v21; // [rsp+A8h] [rbp-90h]
  unsigned __int64 v22; // [rsp+B0h] [rbp-88h]
  char v23; // [rsp+BFh] [rbp-79h]
  unsigned __int64 v24; // [rsp+C0h] [rbp-78h]
  __int64 v25; // [rsp+C8h] [rbp-70h]
  unsigned __int64 v26; // [rsp+D8h] [rbp-60h]
  __int64 v27; // [rsp+E0h] [rbp-58h]
  __int64 *v28; // [rsp+F0h] [rbp-48h]
  unsigned __int64 v29; // [rsp+F8h] [rbp-40h]
  void *v30; // [rsp+100h] [rbp-38h]
  __int64 *v31; // [rsp+108h] [rbp-30h]
  __int64 *v32; // [rsp+110h] [rbp-28h]
  bool v33; // [rsp+11Fh] [rbp-19h]
  __int64 *v34; // [rsp+120h] [rbp-18h]
  __int64 v35; // [rsp+128h] [rbp-10h]
  __int64 v36; // [rsp+130h] [rbp-8h]

  v13 = a2;
  v14 = a3;
  v23 = 0;
  v24 = 0x8000000000000001uLL;
  v25 = 0LL;
  v26 = 0x8000000000000001uLL;
  v27 = 0LL;
  v28 = &v13;
  v29 = a3;
  if ( a4[1] )
  {
    v30 = *a4;
    v10 = v30;
    v5 = a4[2];
    v17 = a4[1];
    v18 = v5;
    v31 = &v17;
    v32 = &v13;
    v33 = v17 == v13;
    sub_7FF7053E43E0(v17 == v13, &off_7FF7053FFD00);
    v15 = sub_7FF7053E52A0(a5, v10, v17, v18, v13, v14);
  }
  else
  {
    v15 = sub_7FF7053E52F0(a5, v13, v14);
  }
  v16 = v6;
  v19 = v15;
  v20 = v6;
  v34 = &v13;
  if ( v15 )
  {
    v8 = v20;
    v35 = v19;
    v36 = v20;
    a1[1] = v19;
    a1[2] = v8;
    *a1 = 0LL;
  }
  else
  {
    v21 = v13;
    v22 = v14;
    v7 = v14;
    a1[1] = v13;
    a1[2] = v7;
    *a1 = 1LL;
  }
  return a1;
}
// 7FF7053E20C3: variable 'v6' is possibly undefined
// 7FF7053FFD00: using guessed type char *off_7FF7053FFD00;

//----- (00007FF7053E21A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_BOOL8 __fastcall sub_7FF7053E21A0(unsigned __int64 *a1, __int64 a2)
{
  __int64 v2; // rdx
  _BOOL8 result; // rax
  unsigned __int64 v5; // [rsp+30h] [rbp-48h]

  v5 = sub_7FF7053E2440(a1, *a1, 1LL, 4uLL, 4uLL);
  result = v5 != 0x8000000000000001uLL;
  if ( v5 != 0x8000000000000001uLL )
    sub_7FF7053FDFF0(v5, v2, a2);
  return result;
}
// 7FF7053E222C: variable 'v2' is possibly undefined

//----- (00007FF7053E2240) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E2240(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 result; // rax
  __int64 v5; // [rsp+30h] [rbp-48h] BYREF
  __int64 v6; // [rsp+38h] [rbp-40h]
  __int64 v7; // [rsp+40h] [rbp-38h]
  unsigned __int64 *v8; // [rsp+48h] [rbp-30h]
  unsigned __int64 v9; // [rsp+50h] [rbp-28h]
  unsigned __int64 v10; // [rsp+58h] [rbp-20h]
  __int64 v11; // [rsp+60h] [rbp-18h]
  __int64 v12; // [rsp+68h] [rbp-10h]
  __int64 v13; // [rsp+70h] [rbp-8h]

  v8 = a1;
  v9 = a2;
  v10 = a3;
  sub_7FF7053E22C0(&v5, a1, a2, a3);
  result = v6 != 0;
  if ( v6 )
  {
    v11 = v5;
    v12 = v6;
    v13 = v7;
    return sub_7FF7053E51E0((a1 + 2), v5, v6, v7);
  }
  return result;
}

//----- (00007FF7053E22C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 *__fastcall sub_7FF7053E22C0(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        unsigned __int64 a3,
        unsigned __int64 a4)
{
  unsigned __int64 v5; // [rsp+28h] [rbp-C0h]
  unsigned __int64 v10[2]; // [rsp+50h] [rbp-98h] BYREF
  unsigned __int64 v11; // [rsp+60h] [rbp-88h]
  unsigned __int64 v12; // [rsp+68h] [rbp-80h]
  unsigned __int64 v13; // [rsp+70h] [rbp-78h]
  unsigned __int64 v14; // [rsp+78h] [rbp-70h]
  unsigned __int64 v15; // [rsp+80h] [rbp-68h]
  unsigned __int64 *v16; // [rsp+88h] [rbp-60h]
  unsigned __int64 *v17; // [rsp+90h] [rbp-58h]
  unsigned __int64 v18; // [rsp+98h] [rbp-50h]
  unsigned __int64 v19; // [rsp+A0h] [rbp-48h]
  unsigned __int64 *v20; // [rsp+A8h] [rbp-40h]
  unsigned __int64 v21; // [rsp+B0h] [rbp-38h]
  unsigned __int64 v22; // [rsp+B8h] [rbp-30h]
  unsigned __int64 v23; // [rsp+C0h] [rbp-28h]
  unsigned __int64 *v24; // [rsp+C8h] [rbp-20h]
  unsigned __int64 v25; // [rsp+D0h] [rbp-18h]
  unsigned __int64 v26; // [rsp+D8h] [rbp-10h]
  unsigned __int64 v27; // [rsp+E0h] [rbp-8h]

  v10[0] = a3;
  v10[1] = a4;
  v16 = a2;
  v17 = v10;
  v18 = a4;
  if ( a4 && (v19 = *a2) != 0 )
  {
    v20 = v10;
    v5 = *a2;
    v21 = v5;
    v22 = v5;
    sub_7FF7053E4320(a4, v5, &off_7FF7053FFD18);
    v11 = v5 * a4;
    v23 = v5 * a4;
    v24 = v10;
    v12 = v10[0];
    sub_7FF7053E5400(v5 * a4, v10[0], &off_7FF7053FFD30);
    v25 = v12;
    v26 = v11;
    v27 = a2[1];
    v13 = v27;
    v14 = v12;
    v15 = v11;
    *a1 = v27;
    a1[1] = v14;
    a1[2] = v15;
  }
  else
  {
    a1[1] = 0LL;
  }
  return a1;
}
// 7FF7053FFD18: using guessed type char *off_7FF7053FFD18;
// 7FF7053FFD30: using guessed type char *off_7FF7053FFD30;

//----- (00007FF7053E2440) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053E2440(
        unsigned __int64 *a1,
        __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 a5)
{
  unsigned __int64 v6; // rax
  __int64 v7; // [rsp+30h] [rbp-338h]
  unsigned __int64 v8; // [rsp+38h] [rbp-330h]
  unsigned __int64 v9; // [rsp+40h] [rbp-328h]
  unsigned __int64 v11; // [rsp+70h] [rbp-2F8h] BYREF
  unsigned __int64 v12; // [rsp+78h] [rbp-2F0h]
  unsigned __int64 v13; // [rsp+80h] [rbp-2E8h]
  void *v14; // [rsp+88h] [rbp-2E0h]
  unsigned __int64 v15; // [rsp+90h] [rbp-2D8h]
  __int64 v16; // [rsp+98h] [rbp-2D0h]
  unsigned __int64 v17; // [rsp+A0h] [rbp-2C8h]
  __int64 v18; // [rsp+A8h] [rbp-2C0h]
  __int64 v19; // [rsp+B0h] [rbp-2B8h]
  __int64 v20; // [rsp+B8h] [rbp-2B0h]
  __int64 v21; // [rsp+C0h] [rbp-2A8h]
  __int64 v22; // [rsp+C8h] [rbp-2A0h]
  unsigned __int64 v23; // [rsp+D0h] [rbp-298h]
  __int64 v24; // [rsp+D8h] [rbp-290h]
  unsigned __int64 v25; // [rsp+E0h] [rbp-288h]
  unsigned __int64 v26; // [rsp+E8h] [rbp-280h]
  __int64 v27; // [rsp+F0h] [rbp-278h]
  unsigned __int64 v28; // [rsp+F8h] [rbp-270h]
  unsigned __int64 v29; // [rsp+100h] [rbp-268h]
  unsigned __int64 v30[4]; // [rsp+108h] [rbp-260h] BYREF
  __int64 v31; // [rsp+128h] [rbp-240h]
  void *v32; // [rsp+130h] [rbp-238h]
  void *v33; // [rsp+138h] [rbp-230h]
  __int64 v34; // [rsp+140h] [rbp-228h] BYREF
  void *v35; // [rsp+148h] [rbp-220h]
  void *v36; // [rsp+150h] [rbp-218h]
  void *v37[7]; // [rsp+158h] [rbp-210h] BYREF
  unsigned __int64 v38; // [rsp+190h] [rbp-1D8h]
  unsigned __int64 v39; // [rsp+198h] [rbp-1D0h]
  unsigned __int64 v40; // [rsp+1A0h] [rbp-1C8h] BYREF
  unsigned __int64 v41; // [rsp+1A8h] [rbp-1C0h]
  __int64 v42; // [rsp+1B0h] [rbp-1B8h]
  __int64 v43; // [rsp+1B8h] [rbp-1B0h]
  __int64 v44; // [rsp+1C0h] [rbp-1A8h]
  void *v45; // [rsp+1C8h] [rbp-1A0h]
  void *v46; // [rsp+1D0h] [rbp-198h]
  unsigned __int64 *v47; // [rsp+1D8h] [rbp-190h]
  __int64 v48; // [rsp+1E0h] [rbp-188h]
  __int64 v49; // [rsp+1E8h] [rbp-180h]
  __int64 v50; // [rsp+1F0h] [rbp-178h]
  __int64 v51; // [rsp+1F8h] [rbp-170h]
  __int64 v52; // [rsp+200h] [rbp-168h]
  __int64 v53; // [rsp+208h] [rbp-160h]
  __int64 v54; // [rsp+210h] [rbp-158h]
  __int64 v55; // [rsp+218h] [rbp-150h]
  unsigned __int64 *v56; // [rsp+228h] [rbp-140h]
  unsigned __int64 v57; // [rsp+230h] [rbp-138h]
  bool v58; // [rsp+23Fh] [rbp-129h]
  __int64 v59; // [rsp+240h] [rbp-128h]
  __int64 v60; // [rsp+248h] [rbp-120h]
  __int64 v61; // [rsp+250h] [rbp-118h]
  unsigned __int64 v62; // [rsp+258h] [rbp-110h]
  __int64 v63; // [rsp+260h] [rbp-108h]
  unsigned __int64 v64; // [rsp+268h] [rbp-100h]
  unsigned __int64 *v65; // [rsp+270h] [rbp-F8h]
  unsigned __int64 v66; // [rsp+278h] [rbp-F0h]
  unsigned __int64 v67; // [rsp+280h] [rbp-E8h]
  unsigned __int64 v68; // [rsp+288h] [rbp-E0h]
  __int64 v69; // [rsp+290h] [rbp-D8h]
  unsigned __int64 v70; // [rsp+298h] [rbp-D0h]
  unsigned __int64 v71; // [rsp+2A0h] [rbp-C8h]
  unsigned __int64 v72; // [rsp+2A8h] [rbp-C0h]
  unsigned __int64 v73; // [rsp+2B0h] [rbp-B8h]
  unsigned __int64 v74; // [rsp+2B8h] [rbp-B0h]
  unsigned __int64 v75; // [rsp+2C0h] [rbp-A8h]
  void *v76; // [rsp+2C8h] [rbp-A0h]
  void *v77; // [rsp+2D0h] [rbp-98h]
  void *v78; // [rsp+2D8h] [rbp-90h]
  void *v79; // [rsp+2E0h] [rbp-88h]
  void *v80; // [rsp+2E8h] [rbp-80h]
  void *v81; // [rsp+2F0h] [rbp-78h]
  void *v82; // [rsp+2F8h] [rbp-70h]
  void *v83; // [rsp+300h] [rbp-68h]
  __int64 v84; // [rsp+308h] [rbp-60h]
  __int64 v85; // [rsp+310h] [rbp-58h]
  __int64 v86; // [rsp+318h] [rbp-50h]
  __int64 v87; // [rsp+320h] [rbp-48h]
  __int64 v88; // [rsp+328h] [rbp-40h]
  __int64 v89; // [rsp+330h] [rbp-38h]
  __int64 v90; // [rsp+338h] [rbp-30h]
  __int64 v91; // [rsp+340h] [rbp-28h]

  v11 = a4;
  v12 = a5;
  v47 = a1;
  v48 = a2;
  v49 = a3;
  v50 = 0LL;
  v51 = 0LL;
  v52 = 0LL;
  v53 = 0LL;
  v54 = 0LL;
  v55 = 0LL;
  v56 = &v11;
  v57 = a5;
  if ( a5 )
  {
    v58 = __CFADD__(a3, a2);
    if ( __CFADD__(a3, a2) )
    {
      v19 = 0LL;
      v20 = 0LL;
      v17 = 0LL;
      v18 = 0LL;
      v88 = 0LL;
      v89 = 0LL;
      v37[5] = 0LL;
      v37[6] = 0LL;
      v15 = 0LL;
      v16 = 0LL;
      v21 = 0LL;
      v22 = 0LL;
      v90 = 0LL;
      v91 = 0LL;
      v13 = 0LL;
      v14 = 0LL;
    }
    else
    {
      v20 = a3 + a2;
      v19 = 1LL;
      v59 = a3 + a2;
      v18 = a3 + a2;
      v17 = 0x8000000000000001uLL;
      v60 = a3 + a2;
      v16 = a3 + a2;
      v15 = 0x8000000000000001uLL;
      v61 = a3 + a2;
      v62 = *a1;
      v63 = 2 * v62;
      v6 = sub_7FF7053E4680(2 * v62, a3 + a2);
      v64 = v6;
      v65 = &v11;
      if ( a5 == 1 )
      {
        v23 = 8LL;
      }
      else if ( a5 <= 0x400 )
      {
        v23 = 4LL;
      }
      else
      {
        v23 = 1LL;
      }
      v9 = sub_7FF7053E4680(v23, v6);
      v66 = v9;
      v30[0] = v11;
      v30[1] = v12;
      sub_7FF7053E54D0(&v40, v30, v9);
      if ( v40 )
      {
        v67 = v40;
        v68 = v41;
        v69 = v42;
        v38 = v40;
        v39 = v41;
        v70 = v40;
        v71 = v41;
        v28 = v40;
        v29 = v41;
        v27 = 0LL;
        v72 = v40;
        v73 = v41;
        v25 = v40;
        v26 = v41;
        v24 = 0LL;
        v7 = v40;
        v8 = v41;
        v74 = v40;
        v75 = v41;
        sub_7FF7053E22C0(v37, a1, v11, v12);
        sub_7FF7053E1F40(&v34, v7, v8, v37, (a1 + 2));
        if ( (v34 & 1) != 0 )
        {
          v80 = v35;
          v81 = v36;
          v45 = v35;
          v46 = v36;
          v32 = v35;
          v33 = v36;
          v31 = 1LL;
          v37[3] = v35;
          v37[4] = v36;
          v82 = v35;
          v83 = v36;
          v13 = v35;
          v14 = v36;
        }
        else
        {
          v76 = v35;
          v77 = v36;
          v32 = v35;
          v33 = v36;
          v31 = 0LL;
          v78 = v35;
          v79 = v36;
          a1[1] = v35;
          *a1 = v9;
          v13 = 0x8000000000000001uLL;
          v14 = 0LL;
        }
      }
      else
      {
        v38 = 0LL;
        v39 = 0LL;
        v28 = 0LL;
        v29 = 0LL;
        v27 = 1LL;
        v84 = 0LL;
        v85 = 0LL;
        v43 = 0LL;
        v44 = 0LL;
        v25 = 0LL;
        v26 = 0LL;
        v24 = 1LL;
        v30[2] = 0LL;
        v30[3] = 0LL;
        v86 = 0LL;
        v87 = 0LL;
        v13 = 0LL;
        v14 = 0LL;
      }
    }
  }
  else
  {
    v13 = 0LL;
    v14 = 0LL;
  }
  return v13;
}

//----- (00007FF7053E2B60) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E2B60(_QWORD *a1, unsigned __int64 a2, char a3, unsigned __int64 a4, unsigned __int64 a5)
{
  __int64 v5; // rcx
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // [rsp+40h] [rbp-40h]
  __int64 v10; // [rsp+48h] [rbp-38h]
  char v15; // [rsp+6Fh] [rbp-11h] BYREF
  _QWORD v16[2]; // [rsp+70h] [rbp-10h] BYREF
  _QWORD v17[5]; // [rsp+80h] [rbp+0h] BYREF
  unsigned __int64 v18[2]; // [rsp+A8h] [rbp+28h] BYREF
  __int64 v19; // [rsp+B8h] [rbp+38h]
  __int64 v20; // [rsp+C0h] [rbp+40h]
  __int64 v21; // [rsp+C8h] [rbp+48h]
  __int64 v22; // [rsp+D0h] [rbp+50h]
  __int64 v23; // [rsp+D8h] [rbp+58h]
  __int64 v24; // [rsp+E0h] [rbp+60h]
  __int64 v25; // [rsp+E8h] [rbp+68h] BYREF
  __int64 v26; // [rsp+F0h] [rbp+70h]
  __int64 v27; // [rsp+F8h] [rbp+78h]
  unsigned __int64 v28; // [rsp+100h] [rbp+80h]
  char v29; // [rsp+10Fh] [rbp+8Fh]
  unsigned __int64 v30; // [rsp+110h] [rbp+90h]
  __int64 v31; // [rsp+120h] [rbp+A0h]
  __int64 v32; // [rsp+130h] [rbp+B0h]
  __int64 v33; // [rsp+140h] [rbp+C0h]
  __int64 v34; // [rsp+148h] [rbp+C8h]
  __int64 v35; // [rsp+150h] [rbp+D0h]
  __int64 v36; // [rsp+158h] [rbp+D8h]
  __int64 v37; // [rsp+160h] [rbp+E0h]
  __int64 v38; // [rsp+168h] [rbp+E8h]
  __int64 v39; // [rsp+170h] [rbp+F0h]
  _QWORD *v40; // [rsp+178h] [rbp+F8h]
  __int64 v41; // [rsp+180h] [rbp+100h]
  _QWORD *v42; // [rsp+188h] [rbp+108h]
  __int64 v43; // [rsp+190h] [rbp+110h]
  _QWORD *v44; // [rsp+198h] [rbp+118h]
  __int64 v45; // [rsp+1A0h] [rbp+120h]
  __int64 v46; // [rsp+1A8h] [rbp+128h]
  __int64 v47; // [rsp+1B0h] [rbp+130h]
  __int64 v48; // [rsp+1B8h] [rbp+138h]

  v48 = -2LL;
  v16[0] = a4;
  v16[1] = a5;
  v28 = a2;
  v29 = a3 & 1;
  v30 = 0x8000000000000001uLL;
  v31 = 0LL;
  v32 = 0LL;
  v18[0] = a4;
  v18[1] = a5;
  sub_7FF7053E54D0(&v25, v18, a2);
  if ( v25 )
  {
    v33 = v25;
    v34 = v26;
    v35 = v27;
    v23 = v25;
    v24 = v26;
    v36 = v25;
    v37 = v26;
    v17[3] = v25;
    v17[4] = v26;
    v17[2] = 0LL;
    v9 = v25;
    v10 = v26;
    v38 = v25;
    v39 = v26;
    v17[0] = v25;
    v17[1] = v26;
    v40 = v17;
    v41 = v26;
    if ( v26 )
    {
      v44 = v17;
      if ( (a3 & 1) != 0 )
        v19 = sub_7FF7053E5270(&v15, v25, v26);
      else
        v19 = sub_7FF7053E52F0(&v15, v25, v26);
      v20 = v7;
      if ( v19 )
      {
        v8 = v19;
        v45 = v19;
        v46 = v20;
        v47 = v19;
        a1[1] = a2;
        a1[2] = v8;
        *a1 = 0LL;
      }
      else
      {
        v21 = v9;
        v22 = v10;
        a1[1] = v9;
        a1[2] = v10;
        *a1 = 1LL;
      }
    }
    else
    {
      v42 = v16;
      v43 = v16[0];
      v5 = v16[0];
      a1[1] = 0LL;
      a1[2] = v5;
      *a1 = 0LL;
    }
  }
  else
  {
    v23 = 0LL;
    v24 = 1LL;
    a1[1] = 0LL;
    a1[2] = 1LL;
    *a1 = 1LL;
  }
  return a1;
}
// 7FF7053E2D56: variable 'v7' is possibly undefined

//----- (00007FF7053E2E20) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E2E20(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v9; // [rsp+50h] [rbp-A8h] BYREF
  __int64 v10; // [rsp+58h] [rbp-A0h]
  __int64 v11; // [rsp+60h] [rbp-98h]
  _QWORD v12[2]; // [rsp+68h] [rbp-90h] BYREF
  _QWORD v13[2]; // [rsp+78h] [rbp-80h] BYREF
  unsigned __int64 v14; // [rsp+88h] [rbp-70h]
  unsigned __int64 v15; // [rsp+90h] [rbp-68h]
  unsigned __int64 v16; // [rsp+A0h] [rbp-58h]
  unsigned __int64 v17; // [rsp+A8h] [rbp-50h]
  __int64 v18; // [rsp+B0h] [rbp-48h]
  __int64 v19; // [rsp+B8h] [rbp-40h]
  _QWORD *v20; // [rsp+C0h] [rbp-38h]
  _QWORD *v21; // [rsp+C8h] [rbp-30h]
  unsigned __int64 v22; // [rsp+D0h] [rbp-28h]
  __int64 v23; // [rsp+D8h] [rbp-20h]
  bool v24; // [rsp+E7h] [rbp-11h]
  __int64 v25; // [rsp+E8h] [rbp-10h]
  __int64 v26; // [rsp+F0h] [rbp-8h]

  v15 = a1;
  v16 = a2;
  v17 = a3;
  v18 = 0LL;
  v19 = 0LL;
  sub_7FF7053E2B60(&v9, a1, 0, a2, a3);
  if ( (v9 & 1) != 0 )
  {
    v25 = v10;
    v26 = v11;
    sub_7FF7053FDFF0(v10, v11, a4);
  }
  v12[0] = v10;
  v12[1] = v11;
  v20 = v12;
  v13[0] = a2;
  v13[1] = a3;
  v21 = v13;
  v22 = a3;
  if ( a3 )
  {
    v23 = v12[0];
    v14 = v12[0];
  }
  else
  {
    v14 = -1LL;
  }
  v24 = a1 <= v14;
  sub_7FF7053E43E0(a1 <= v14, a4);
  return v12[0];
}

//----- (00007FF7053E2F80) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_BOOL8 __fastcall sub_7FF7053E2F80(
        unsigned __int64 *a1,
        __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 a5)
{
  __int64 v5; // rdx
  _BOOL8 result; // rax
  unsigned __int64 v7; // [rsp+30h] [rbp-48h]

  v7 = sub_7FF7053E2440(a1, a2, a3, a4, a5);
  result = v7 != 0x8000000000000001uLL;
  if ( v7 != 0x8000000000000001uLL )
    sub_7FF7053FDFF0(v7, v5, &off_7FF7053FFD58);
  return result;
}
// 7FF7053E2FF6: variable 'v5' is possibly undefined
// 7FF7053FFD58: using guessed type char *off_7FF7053FFD58;

//----- (00007FF7053E3010) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053E3010(unsigned __int64 a1, unsigned __int64 a2)
{
  sub_7FF7053E4770(a1, a2, &off_7FF7053FFDC8);
  return (a1 - a2) >> 5;
}
// 7FF7053FFDC8: using guessed type char *off_7FF7053FFDC8;

//----- (00007FF7053E3080) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 *__fastcall sub_7FF7053E3080(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 *result; // rax
  unsigned __int64 v5; // [rsp+38h] [rbp-20h]

  v5 = sub_7FF7053E3010(*(a2 + 24), *(a2 + 8));
  result = a1;
  *a1 = v5;
  a1[1] = 1LL;
  a1[2] = v5;
  return result;
}

//----- (00007FF7053E30F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053E30F0(__int64 a1)
{
  __int64 v2; // [rsp+38h] [rbp-A0h] BYREF
  __int64 v3; // [rsp+40h] [rbp-98h] BYREF
  unsigned __int64 v4; // [rsp+48h] [rbp-90h] BYREF
  __int64 v5; // [rsp+50h] [rbp-88h]
  __int64 v6; // [rsp+58h] [rbp-80h]
  __int64 v7; // [rsp+60h] [rbp-78h] BYREF
  unsigned __int64 v8; // [rsp+68h] [rbp-70h] BYREF
  __int128 v9[3]; // [rsp+70h] [rbp-68h] BYREF
  __int64 v10; // [rsp+A0h] [rbp-38h]
  char v11; // [rsp+AFh] [rbp-29h]
  unsigned __int64 v12; // [rsp+B0h] [rbp-28h]
  __int64 *v13; // [rsp+B8h] [rbp-20h]
  __int64 *v14; // [rsp+C0h] [rbp-18h]
  __int64 *v15; // [rsp+C8h] [rbp-10h]
  unsigned __int64 *v16; // [rsp+D0h] [rbp-8h]

  v10 = a1;
  v11 = 0;
  sub_7FF7053E3080(&v4, a1);
  v12 = v4;
  v2 = v5;
  v3 = v6;
  v13 = &v2;
  v8 = v4;
  v7 = 1LL;
  v14 = &v7;
  if ( (v5 & 1) == 0 || (v15 = &v3, v16 = &v8, v3 != v4) )
  {
    *&v9[0] = 0LL;
    sub_7FF7053FDE4D(0, &v2, &v7, v9, &off_7FF7053FFE40);
  }
  return v4;
}
// 7FF7053FFE40: using guessed type char *off_7FF7053FFE40;

//----- (00007FF7053E31E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E31E0(__int64 a1)
{
  return sub_7FF7053E1D30(a1);
}

//----- (00007FF7053E3200) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053E3200(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v5; // [rsp+58h] [rbp-50h]

  if ( !is_mul_ok(a4, a3) )
    sub_7FF7053FE1F0(
      "is_nonoverlapping: `size_of::<T>() * count` overflows a usize/rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\\libr"
      "ary\\core\\src\\iter\\adapters\\enumerate.rs",
      61LL);
  if ( a1 < a2 )
    v5 = a2 - a1;
  else
    v5 = a1 - a2;
  return v5 >= a4 * a3;
}

//----- (00007FF7053E32F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E32F0(unsigned __int64 **a1)
{
  unsigned __int64 v2[6]; // [rsp+38h] [rbp-50h] BYREF
  unsigned __int64 v3; // [rsp+68h] [rbp-20h]
  unsigned __int64 v4; // [rsp+70h] [rbp-18h]
  unsigned __int64 v5; // [rsp+78h] [rbp-10h]
  unsigned __int64 v6; // [rsp+80h] [rbp-8h]

  v2[3] = a1;
  v2[5] = (*a1 + 4);
  v3 = **a1;
  v4 = (*a1)[2];
  v5 = v3;
  v2[2] = v4;
  v6 = v4;
  v2[0] = v4;
  v2[1] = v3;
  return sub_7FF7053E3820(v2);
}

//----- (00007FF7053E3370) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3370(__int64 (**a1)(void))
{
  return sub_7FF7053E33B0(*a1);
}

//----- (00007FF7053E3390) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3390(__int64 (*a1)(void))
{
  return a1();
}

//----- (00007FF7053E33B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E33B0(__int64 (*a1)(void))
{
  __int64 (*v2[2])(void); // [rsp+30h] [rbp-10h] BYREF

  v2[1] = -2LL;
  v2[0] = a1;
  return sub_7FF7053E4720(v2);
}

//----- (00007FF7053E3400) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3400(unsigned __int64 **a1)
{
  return sub_7FF7053E32F0(a1);
}

//----- (00007FF7053E3420) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3420(unsigned __int64 *a1)
{
  return sub_7FF7053E3440(a1);
}

//----- (00007FF7053E3440) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3440(unsigned __int64 *a1)
{
  return sub_7FF7053E3580(a1);
}

//----- (00007FF7053E3460) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3460(unsigned __int64 *a1)
{
  return sub_7FF7053E3480(a1);
}

//----- (00007FF7053E3480) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3480(unsigned __int64 *a1)
{
  sub_7FF7053E38B0(a1);
  return sub_7FF7053E3670(a1);
}

//----- (00007FF7053E34E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E34E0(unsigned __int64 *a1)
{
  sub_7FF7053E3860(a1);
  return sub_7FF7053E3690(a1);
}

//----- (00007FF7053E3540) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3540(unsigned __int64 *a1)
{
  return sub_7FF7053E3560(a1);
}

//----- (00007FF7053E3560) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3560(unsigned __int64 *a1)
{
  return sub_7FF7053E35A0(a1);
}

//----- (00007FF7053E3580) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3580(unsigned __int64 *a1)
{
  return sub_7FF7053E3840(a1);
}

//----- (00007FF7053E35A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E35A0(unsigned __int64 *a1)
{
  return sub_7FF7053E3480(a1);
}

//----- (00007FF7053E35C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E35C0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned __int64 *v3; // rcx
  __int64 i; // [rsp+30h] [rbp-20h]

  for ( i = 0LL; ; ++i )
  {
    result = a2;
    if ( i == a2 )
      break;
    v3 = (a1 + 24 * i);
    sub_7FF7053E3460(v3);
  }
  return result;
}

//----- (00007FF7053E3670) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3670(unsigned __int64 *a1)
{
  return sub_7FF7053E3910(a1);
}

//----- (00007FF7053E3690) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3690(unsigned __int64 *a1)
{
  return sub_7FF7053E38D0(a1);
}

//----- (00007FF7053E36B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E36B0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned __int64 *v3; // rcx
  __int64 i; // [rsp+30h] [rbp-20h]

  for ( i = 0LL; ; ++i )
  {
    result = a2;
    if ( i == a2 )
      break;
    v3 = (32 * i + a1);
    sub_7FF7053E3540(v3);
  }
  return result;
}

//----- (00007FF7053E3760) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3760(unsigned __int64 *a1)
{
  sub_7FF7053E3880(a1);
  return sub_7FF7053E3800(a1);
}

//----- (00007FF7053E37C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E37C0(unsigned __int64 *a1)
{
  __int64 result; // rax

  result = *a1 != 0x8000000000000000uLL;
  if ( *a1 != 0x8000000000000000uLL )
    return sub_7FF7053E3460(a1);
  return result;
}

//----- (00007FF7053E3800) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3800(unsigned __int64 *a1)
{
  return sub_7FF7053E38F0(a1);
}

//----- (00007FF7053E3820) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3820(unsigned __int64 *a1)
{
  return sub_7FF7053E3930(a1);
}

//----- (00007FF7053E3840) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3840(unsigned __int64 *a1)
{
  return sub_7FF7053E3950(a1);
}

//----- (00007FF7053E3860) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3860(__int64 a1)
{
  return *(a1 + 16);
}

//----- (00007FF7053E3880) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3880(__int64 a1)
{
  return sub_7FF7053E35C0(*(a1 + 8), *(a1 + 16));
}

//----- (00007FF7053E38B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E38B0(__int64 a1)
{
  return *(a1 + 16);
}

//----- (00007FF7053E38D0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E38D0(unsigned __int64 *a1)
{
  return sub_7FF7053E2240(a1, 4uLL, 4uLL);
}

//----- (00007FF7053E38F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E38F0(unsigned __int64 *a1)
{
  return sub_7FF7053E2240(a1, 8uLL, 0x18uLL);
}

//----- (00007FF7053E3910) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3910(unsigned __int64 *a1)
{
  return sub_7FF7053E2240(a1, 1uLL, 1uLL);
}

//----- (00007FF7053E3930) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3930(unsigned __int64 *a1)
{
  return sub_7FF7053E2240(a1, 8uLL, 0x20uLL);
}

//----- (00007FF7053E3950) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3950(unsigned __int64 *a1)
{
  __int64 v2; // [rsp+20h] [rbp-50h]
  unsigned __int64 *v3; // [rsp+30h] [rbp-40h] BYREF
  _QWORD v4[5]; // [rsp+38h] [rbp-38h] BYREF
  unsigned __int64 v5; // [rsp+60h] [rbp-10h]
  __int64 v6; // [rsp+68h] [rbp-8h]

  v6 = -2LL;
  v4[1] = a1;
  v3 = a1;
  v4[0] = a1;
  v2 = a1[1];
  v4[2] = v2;
  v4[3] = v2;
  v4[4] = v4;
  v5 = sub_7FF7053E30F0(a1);
  sub_7FF7053E36B0(v2, v5);
  return sub_7FF7053E3400(&v3);
}

//----- (00007FF7053E39E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E39E0(__int64 *a1)
{
  __int64 v2; // [rsp+28h] [rbp-58h]
  __int64 v4; // [rsp+40h] [rbp-40h]

  if ( sub_7FF7053E1DE0(a1) )
  {
    v2 = a1[2];
    if ( v2 == -1 )
      sub_7FF7053FE520(&off_7FF7053FFEF8);
    a1[2] = v2 + 1;
    return v2;
  }
  return v4;
}
// 7FF7053E3A6B: variable 'v4' is possibly undefined
// 7FF7053FFEF8: using guessed type char *off_7FF7053FFEF8;

//----- (00007FF7053E3AD0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E3AD0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result; // rax

  result = a1;
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  return result;
}

//----- (00007FF7053E3AF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E3AF0(unsigned __int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  if ( a1 >= a3 )
    sub_7FF7053FE234(a1, a3, a4);
  return 24 * a1 + a2;
}

//----- (00007FF7053E3B50) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E3B50(__int64 a1, unsigned __int64 a2, char a3, __int64 a4)
{
  char result; // al
  __int128 v5; // [rsp+48h] [rbp-38h] BYREF
  __int64 v6; // [rsp+58h] [rbp-28h]
  __int64 v7; // [rsp+60h] [rbp-20h]
  __int64 v8; // [rsp+68h] [rbp-18h]
  _QWORD *v9; // [rsp+70h] [rbp-10h]
  _QWORD v10[2]; // [rsp+78h] [rbp-8h] BYREF
  _QWORD v11[8]; // [rsp+88h] [rbp+8h] BYREF
  char v12; // [rsp+CFh] [rbp+4Fh]
  const char *v13; // [rsp+D0h] [rbp+50h]
  __int64 v14; // [rsp+D8h] [rbp+58h]
  char **v15; // [rsp+E0h] [rbp+60h]
  unsigned int v16; // [rsp+ECh] [rbp+6Ch]
  _QWORD *v17; // [rsp+F0h] [rbp+70h]
  __int64 v18; // [rsp+F8h] [rbp+78h]

  v18 = -2LL;
  v11[6] = a1;
  v11[7] = a2;
  v12 = a3 & 1;
  v13 = aUnsafePrecondi_1;
  v14 = 228LL;
  v15 = &off_7FF705400020;
  v16 = ((0x101010101010101LL
        * (((((((a2 - ((a2 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
            + ((a2 - ((a2 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) >> 4)
          + (((a2 - ((a2 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
          + ((a2 - ((a2 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) & 0xF0F0F0F0F0F0F0FLL)) >> 32) >> 24;
  if ( v16 != 1 )
  {
    v11[0] = &off_7FF705400020;
    v11[1] = 1LL;
    v11[4] = 0LL;
    v11[2] = 8LL;
    v11[3] = 0LL;
    try
    {
      sub_7FF7053FE110(v11, &off_7FF705400088);
    }
    catch ( ... )
    {
      sub_7FF7053FE29A();
    }
  }
  if ( ((a2 - 1) & a1) != 0 || (result = a3, (a3 & 1) == 0) && (result = ~(a1 == 0), !a1) )
  {
    v10[0] = aUnsafePrecondi_1;
    v10[1] = 228LL;
    v17 = v10;
    *&v5 = v10;
    *(&v5 + 1) = 1LL;
    v8 = 0LL;
    v9 = v10;
    v6 = 8LL;
    v7 = 0LL;
    sub_7FF7053FE140(&v5, 0, a4);
  }
  return result;
}
// 7FF7053FE29A: using guessed type void __noreturn sub_7FF7053FE29A(void);
// 7FF705400020: using guessed type char *off_7FF705400020;
// 7FF705400088: using guessed type char *off_7FF705400088;

//----- (00007FF7053E3D10) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053E3D10(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 a5,
        __int64 a6)
{
  bool result; // al
  bool v7; // [rsp+5Fh] [rbp-21h]
  bool v8; // [rsp+6Fh] [rbp-11h]
  __int128 v9; // [rsp+70h] [rbp-10h] BYREF
  __int64 v10; // [rsp+80h] [rbp+0h]
  __int64 v11; // [rsp+88h] [rbp+8h]
  __int64 v12; // [rsp+90h] [rbp+10h]
  _QWORD *v13; // [rsp+98h] [rbp+18h]
  _QWORD v14[2]; // [rsp+A0h] [rbp+20h] BYREF
  _QWORD v15[6]; // [rsp+B0h] [rbp+30h] BYREF
  __int64 v16; // [rsp+E0h] [rbp+60h]
  unsigned __int64 v17; // [rsp+E8h] [rbp+68h]
  unsigned __int64 v18; // [rsp+F0h] [rbp+70h]
  unsigned int v19; // [rsp+FCh] [rbp+7Ch]
  _QWORD v20[15]; // [rsp+100h] [rbp+80h] BYREF
  bool v21; // [rsp+17Bh] [rbp+FBh]
  unsigned int v22; // [rsp+17Ch] [rbp+FCh]
  _QWORD *v23; // [rsp+180h] [rbp+100h]
  __int64 v24; // [rsp+188h] [rbp+108h]

  v24 = -2LL;
  v20[6] = a1;
  v20[7] = a2;
  v20[8] = a3;
  v20[9] = a4;
  v20[10] = aUnsafePrecondi_2;
  v20[11] = 283LL;
  v20[12] = &off_7FF705400020;
  v20[13] = &off_7FF705400020;
  if ( a5 )
  {
    v7 = a3 == 0;
    v8 = a3 == 0;
    v19 = ((0x101010101010101LL
          * (((((((a4 - ((a4 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
              + ((a4 - ((a4 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) >> 4)
            + (((a4 - ((a4 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
            + ((a4 - ((a4 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) & 0xF0F0F0F0F0F0F0FLL)) >> 32) >> 24;
    if ( v19 == 1 )
      goto LABEL_9;
  }
  else
  {
    v7 = 1;
    v19 = ((0x101010101010101LL
          * (((((((a4 - ((a4 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
              + ((a4 - ((a4 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) >> 4)
            + (((a4 - ((a4 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
            + ((a4 - ((a4 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) & 0xF0F0F0F0F0F0F0FLL)) >> 32) >> 24;
    if ( v19 == 1 )
    {
      v17 = a1;
      v18 = a4 - 1;
      v16 = (a4 - 1) & a1;
      if ( v16 )
        goto LABEL_19;
      goto LABEL_12;
    }
  }
  v15[0] = &off_7FF705400020;
  v15[1] = 1LL;
  v15[4] = 0LL;
  v15[2] = 8LL;
  v15[3] = 0LL;
  try
  {
    sub_7FF7053FE110(v15, &off_7FF705400088);
  }
  catch ( ... )
  {
    sub_7FF7053FE29A();
  }
LABEL_9:
  v17 = a1;
  v18 = a4 - 1;
  v16 = (a4 - 1) & a1;
  if ( v16 || !v8 && !v17 )
    goto LABEL_19;
LABEL_12:
  v20[14] = a2;
  v21 = v7;
  v22 = ((0x101010101010101LL
        * (((((((a4 - ((a4 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
            + ((a4 - ((a4 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) >> 4)
          + (((a4 - ((a4 >> 1) & 0x5555555555555555LL)) >> 2) & 0x3333333333333333LL)
          + ((a4 - ((a4 >> 1) & 0x5555555555555555LL)) & 0x3333333333333333LL)) & 0xF0F0F0F0F0F0F0FLL)) >> 32) >> 24;
  if ( v22 != 1 )
  {
    v20[0] = &off_7FF705400020;
    v20[1] = 1LL;
    v20[4] = 0LL;
    v20[2] = 8LL;
    v20[3] = 0LL;
    sub_7FF7053FE110(v20, &off_7FF705400088);
  }
  if ( (v18 & a2) != 0 || !v7 && !a2 || !(result = sub_7FF7053E3200(a1, a2, a3, a5)) )
  {
LABEL_19:
    v14[0] = aUnsafePrecondi_2;
    v14[1] = 283LL;
    v23 = v14;
    *&v9 = v14;
    *(&v9 + 1) = 1LL;
    v12 = 0LL;
    v13 = v14;
    v10 = 8LL;
    v11 = 0LL;
    sub_7FF7053FE140(&v9, 0, a6);
  }
  return result;
}
// 7FF7053FE29A: using guessed type void __noreturn sub_7FF7053FE29A(void);
// 7FF705400020: using guessed type char *off_7FF705400020;
// 7FF705400088: using guessed type char *off_7FF705400088;

//----- (00007FF7053E4120) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4120(int a1, int a2)
{
  if ( a2 < 0 != __OFADD__(a2, a1) )
    sub_7FF7053E4490(&off_7FF705400218);
  return (a2 + a1);
}
// 7FF705400218: using guessed type char *off_7FF705400218;

//----- (00007FF7053E41A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E41A0(__int64 a1, __int64 a2)
{
  sub_7FF7053E4260(a1, a2, &off_7FF705400218);
  return a2 + a1;
}
// 7FF705400218: using guessed type char *off_7FF705400218;

//----- (00007FF7053E41E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E41E0(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  result = a1;
  *a1 = a2;
  a1[1] = sub_7FF7053E18D0;
  return result;
}

//----- (00007FF7053E4220) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E4220(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  result = a1;
  *a1 = a2;
  a1[1] = sub_7FF7053F2BCD;
  return result;
}

//----- (00007FF7053E4260) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053E4260(__int64 a1, __int64 a2, __int64 a3)
{
  bool result; // al
  __int128 v4; // [rsp+30h] [rbp-68h] BYREF
  __int64 v5; // [rsp+40h] [rbp-58h]
  __int64 v6; // [rsp+48h] [rbp-50h]
  __int64 v7; // [rsp+50h] [rbp-48h]
  __int64 v8; // [rsp+58h] [rbp-40h]
  _QWORD v9[7]; // [rsp+60h] [rbp-38h] BYREF

  v9[2] = a1;
  v9[3] = a2;
  v9[4] = aUnsafePrecondi_3;
  v9[5] = 186LL;
  result = __CFADD__(a2, a1);
  if ( __CFADD__(a2, a1) )
  {
    v9[0] = aUnsafePrecondi_3;
    v9[1] = 186LL;
    v9[6] = v9;
    *&v4 = v9;
    *(&v4 + 1) = 1LL;
    v7 = 0LL;
    v8 = 0LL;
    v5 = 8LL;
    v6 = 0LL;
    sub_7FF7053FE140(&v4, 0, a3);
  }
  return result;
}

//----- (00007FF7053E4320) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053E4320(unsigned __int64 a1, unsigned __int64 a2, __int64 a3)
{
  bool result; // al
  __int128 v4; // [rsp+30h] [rbp-68h] BYREF
  __int64 v5; // [rsp+40h] [rbp-58h]
  __int64 v6; // [rsp+48h] [rbp-50h]
  __int64 v7; // [rsp+50h] [rbp-48h]
  __int64 v8; // [rsp+58h] [rbp-40h]
  _QWORD v9[7]; // [rsp+60h] [rbp-38h] BYREF

  v9[2] = a1;
  v9[3] = a2;
  v9[4] = aUnsafePrecondi_4;
  v9[5] = 186LL;
  result = (a2 * a1) >> 64 != 0;
  if ( !is_mul_ok(a2, a1) )
  {
    v9[0] = aUnsafePrecondi_4;
    v9[1] = 186LL;
    v9[6] = v9;
    *&v4 = v9;
    *(&v4 + 1) = 1LL;
    v7 = 0LL;
    v8 = 0LL;
    v5 = 8LL;
    v6 = 0LL;
    sub_7FF7053FE140(&v4, 0, a3);
  }
  return result;
}

//----- (00007FF7053E43E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
const char *__fastcall sub_7FF7053E43E0(char a1, __int64 a2)
{
  const char *result; // rax
  __int128 v3; // [rsp+28h] [rbp-60h] BYREF
  __int64 v4; // [rsp+38h] [rbp-50h]
  __int64 v5; // [rsp+40h] [rbp-48h]
  __int64 v6; // [rsp+48h] [rbp-40h]
  __int64 v7; // [rsp+50h] [rbp-38h]
  _QWORD v8[2]; // [rsp+58h] [rbp-30h] BYREF
  char v9; // [rsp+6Fh] [rbp-19h]
  const char *v10; // [rsp+70h] [rbp-18h]
  __int64 v11; // [rsp+78h] [rbp-10h]
  _QWORD *v12; // [rsp+80h] [rbp-8h]

  v9 = a1 & 1;
  result = aUnsafePrecondi_8;
  v10 = aUnsafePrecondi_8;
  v11 = 221LL;
  if ( (a1 & 1) == 0 )
  {
    v8[0] = aUnsafePrecondi_8;
    v8[1] = 221LL;
    v12 = v8;
    *&v3 = v8;
    *(&v3 + 1) = 1LL;
    v6 = 0LL;
    v7 = 0LL;
    v4 = 8LL;
    v5 = 0LL;
    sub_7FF7053FE140(&v3, 0, a2);
  }
  return result;
}

//----- (00007FF7053E4490) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053E4490(__int64 a1)
{
  __int128 v1; // [rsp+20h] [rbp-58h] BYREF
  __int64 v2; // [rsp+30h] [rbp-48h]
  __int64 v3; // [rsp+38h] [rbp-40h]
  __int64 v4; // [rsp+40h] [rbp-38h]
  __int64 v5; // [rsp+48h] [rbp-30h]
  _QWORD v6[5]; // [rsp+50h] [rbp-28h] BYREF

  v6[2] = aUnsafePrecondi_5;
  v6[3] = 199LL;
  v6[0] = aUnsafePrecondi_5;
  v6[1] = 199LL;
  v6[4] = v6;
  *&v1 = v6;
  *(&v1 + 1) = 1LL;
  v4 = 0LL;
  v5 = 0LL;
  v2 = 8LL;
  v3 = 0LL;
  sub_7FF7053FE140(&v1, 0, a1);
}

//----- (00007FF7053E4520) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4520(__int64 *a1)
{
  return sub_7FF7053E4600(a1);
}

//----- (00007FF7053E4540) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4540(int *a1)
{
  return sub_7FF7053E4590(a1);
}

//----- (00007FF7053E4560) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4560(unsigned int a1)
{
  return a1;
}

//----- (00007FF7053E4570) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4570(__int64 a1)
{
  return a1;
}

//----- (00007FF7053E4590) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4590(int *a1)
{
  if ( *a1 < a1[1] )
  {
    *a1 = sub_7FF7053E4120(*a1, 1);
    return 1;
  }
  else
  {
    return 0;
  }
}

//----- (00007FF7053E4600) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4600(__int64 *a1)
{
  if ( *a1 >= a1[1] )
    return 0LL;
  *a1 = sub_7FF7053E41A0(*a1, 1LL);
  return 1LL;
}

//----- (00007FF7053E4680) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053E4680(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [rsp+0h] [rbp-30h] BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-28h] BYREF
  char v6; // [rsp+1Fh] [rbp-11h]
  __int64 *v7; // [rsp+20h] [rbp-10h]
  __int64 *v8; // [rsp+28h] [rbp-8h]

  v3 = a1;
  v4 = a2;
  v6 = 1;
  v7 = &v4;
  v8 = &v3;
  if ( a2 >= a1 )
    return v4;
  v6 = 0;
  return v3;
}

//----- (00007FF7053E46E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E46E0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  _QWORD v5[4]; // [rsp+30h] [rbp-28h] BYREF
  char v6; // [rsp+57h] [rbp-1h]

  v5[1] = a1;
  v5[2] = a2;
  v5[3] = a3;
  v6 = a4;
  v5[0] = a1;
  return sub_7FF7053E7D90(v5, &unk_7FF705400570);
}

//----- (00007FF7053E4720) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4720(__int64 (**a1)(void))
{
  sub_7FF7053E4750(*a1);
  return sub_7FF7053E4740();
}

//----- (00007FF7053E4740) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053E4740()
{
  return 0LL;
}

//----- (00007FF7053E4750) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4750(__int64 (*a1)(void))
{
  return sub_7FF7053E3390(a1);
}

//----- (00007FF7053E4770) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
const char *__fastcall sub_7FF7053E4770(unsigned __int64 a1, unsigned __int64 a2, __int64 a3)
{
  const char *result; // rax
  __int128 v4; // [rsp+30h] [rbp-68h] BYREF
  __int64 v5; // [rsp+40h] [rbp-58h]
  __int64 v6; // [rsp+48h] [rbp-50h]
  __int64 v7; // [rsp+50h] [rbp-48h]
  __int64 v8; // [rsp+58h] [rbp-40h]
  _QWORD v9[7]; // [rsp+60h] [rbp-38h] BYREF

  v9[2] = a1;
  v9[3] = a2;
  result = aUnsafePrecondi_6;
  v9[4] = aUnsafePrecondi_6;
  v9[5] = 201LL;
  if ( a1 < a2 )
  {
    v9[0] = aUnsafePrecondi_6;
    v9[1] = 201LL;
    v9[6] = v9;
    *&v4 = v9;
    *(&v4 + 1) = 1LL;
    v7 = 0LL;
    v8 = 0LL;
    v5 = 8LL;
    v6 = 0LL;
    sub_7FF7053FE140(&v4, 0, a3);
  }
  return result;
}

//----- (00007FF7053E4820) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E4820(_QWORD *a1, __int128 *a2)
{
  __int128 v2; // xmm0
  _OWORD v5[2]; // [rsp+30h] [rbp-30h] BYREF
  char **v6; // [rsp+50h] [rbp-10h]
  __int64 v7; // [rsp+58h] [rbp-8h]

  v7 = -2LL;
  v6 = &off_7FF705400698;
  v2 = *a2;
  v5[1] = a2[1];
  v5[0] = v2;
  sub_7FF7053E5DB0(a1, v5, &off_7FF705400708);
  return a1;
}
// 7FF705400698: using guessed type char *off_7FF705400698;
// 7FF705400708: using guessed type char *off_7FF705400708;

//----- (00007FF7053E4890) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E4890(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result; // rax

  result = a1;
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  return result;
}

//----- (00007FF7053E48C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E48C0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v5; // [rsp+28h] [rbp-140h]
  __int64 v6; // [rsp+38h] [rbp-130h]
  __int64 v8; // [rsp+50h] [rbp-118h] BYREF
  __int64 v9; // [rsp+58h] [rbp-110h]
  __int64 v10; // [rsp+60h] [rbp-108h]
  __int64 v11; // [rsp+68h] [rbp-100h]
  __int64 v12; // [rsp+70h] [rbp-F8h]
  _QWORD v13[2]; // [rsp+78h] [rbp-F0h] BYREF
  _QWORD v14[3]; // [rsp+88h] [rbp-E0h] BYREF
  __int64 v15; // [rsp+A0h] [rbp-C8h]
  __int64 v16; // [rsp+A8h] [rbp-C0h]
  __int64 v17; // [rsp+B0h] [rbp-B8h]
  char v18; // [rsp+BEh] [rbp-AAh]
  __int64 v19; // [rsp+C0h] [rbp-A8h]
  __int64 v20; // [rsp+C8h] [rbp-A0h]
  __int64 *v21; // [rsp+D8h] [rbp-90h]
  __int64 v22; // [rsp+E0h] [rbp-88h]
  __int64 *v23; // [rsp+E8h] [rbp-80h]
  __int64 v24; // [rsp+F0h] [rbp-78h]
  __int64 v25; // [rsp+F8h] [rbp-70h]
  __int64 v26; // [rsp+100h] [rbp-68h]
  __int64 v27; // [rsp+108h] [rbp-60h]
  _QWORD *v28; // [rsp+110h] [rbp-58h]
  _QWORD *v29; // [rsp+118h] [rbp-50h]
  _QWORD *v30; // [rsp+120h] [rbp-48h]
  _QWORD *v31; // [rsp+128h] [rbp-40h]
  __int64 v32; // [rsp+130h] [rbp-38h]
  __int64 v33; // [rsp+138h] [rbp-30h]
  __int64 v34; // [rsp+140h] [rbp-28h]
  __int64 v35; // [rsp+148h] [rbp-20h]
  __int64 v36; // [rsp+150h] [rbp-18h]
  __int64 v37; // [rsp+158h] [rbp-10h]
  __int64 v38; // [rsp+160h] [rbp-8h]

  v8 = a2;
  v9 = a3;
  v17 = a1;
  v18 = a4 & 1;
  v19 = 0LL;
  v20 = 0LL;
  v21 = &v8;
  v22 = a3;
  if ( a3 )
  {
    if ( (a4 & 1) != 0 )
    {
      v13[0] = v8;
      v13[1] = v9;
      nullsub_1();
      v30 = v13;
      v31 = v13;
      v12 = sub_7FF7053E5E60(a3, v8);
    }
    else
    {
      v14[0] = v8;
      v14[1] = v9;
      nullsub_1();
      v28 = v14;
      v29 = v14;
      v12 = sub_7FF7053E5E30(a3, v8);
    }
    v5 = v12;
    v32 = v12;
    if ( v12 )
    {
      sub_7FF7053E1BC0(v12, &off_7FF7054007A0);
      v16 = v5;
      v33 = v5;
      v15 = v5;
      v34 = v5;
      v14[2] = v5;
      v35 = v5;
      v36 = v5;
      v37 = v5;
      v38 = a3;
      sub_7FF7053E1BC0(v5, &off_7FF705400778);
      v10 = v5;
      v11 = a3;
    }
    else
    {
      v16 = 0LL;
      v15 = 0LL;
      v10 = 0LL;
      v11 = 0LL;
    }
  }
  else
  {
    v23 = &v8;
    v24 = v8;
    v6 = v8;
    v25 = v8;
    v26 = v8;
    v27 = 0LL;
    sub_7FF7053E1BC0(v8, &off_7FF705400778);
    v10 = v6;
    v11 = 0LL;
  }
  return v10;
}
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E60: using guessed type __int64 __fastcall sub_7FF7053E5E60(_QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 nullsub_1(void);
// 7FF705400778: using guessed type char *off_7FF705400778;
// 7FF7054007A0: using guessed type char *off_7FF7054007A0;

//----- (00007FF7053E4B60) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E4B60(
        __int64 a1,
        void *a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        unsigned __int64 a6,
        char a7)
{
  unsigned __int64 v7; // rdx
  __int64 v9; // rax
  unsigned __int64 v10; // rdx
  __int64 v11; // rax
  void *v12; // [rsp+38h] [rbp-260h]
  size_t v13; // [rsp+40h] [rbp-258h]
  __int64 v14; // [rsp+48h] [rbp-250h]
  void *v15; // [rsp+50h] [rbp-248h]
  unsigned __int64 v16; // [rsp+58h] [rbp-240h]
  unsigned __int64 v17; // [rsp+60h] [rbp-238h]
  __int64 v18; // [rsp+70h] [rbp-228h]
  __int64 v20; // [rsp+90h] [rbp-208h] BYREF
  unsigned __int64 v21; // [rsp+98h] [rbp-200h]
  __int64 v22; // [rsp+A0h] [rbp-1F8h] BYREF
  unsigned __int64 v23; // [rsp+A8h] [rbp-1F0h]
  __int64 v24; // [rsp+B0h] [rbp-1E8h]
  unsigned __int64 v25; // [rsp+B8h] [rbp-1E0h]
  size_t v26; // [rsp+C0h] [rbp-1D8h] BYREF
  __int64 v27; // [rsp+C8h] [rbp-1D0h]
  _QWORD v28[3]; // [rsp+D0h] [rbp-1C8h] BYREF
  __int64 v29; // [rsp+E8h] [rbp-1B0h]
  __int64 v30; // [rsp+F0h] [rbp-1A8h]
  unsigned __int64 v31; // [rsp+F8h] [rbp-1A0h]
  unsigned __int64 v32; // [rsp+100h] [rbp-198h]
  void *v33; // [rsp+108h] [rbp-190h]
  unsigned __int64 v34; // [rsp+110h] [rbp-188h]
  _QWORD v35[2]; // [rsp+118h] [rbp-180h] BYREF
  __int64 v36; // [rsp+128h] [rbp-170h]
  _QWORD v37[4]; // [rsp+130h] [rbp-168h] BYREF
  char v38; // [rsp+155h] [rbp-143h]
  char **v39; // [rsp+158h] [rbp-140h]
  char v40; // [rsp+16Ah] [rbp-12Eh]
  char v41; // [rsp+16Bh] [rbp-12Dh]
  __int64 *v42; // [rsp+170h] [rbp-128h]
  unsigned __int64 *v43; // [rsp+178h] [rbp-120h]
  __int64 *v44; // [rsp+180h] [rbp-118h]
  __int64 *v45; // [rsp+188h] [rbp-110h]
  unsigned __int64 v46; // [rsp+190h] [rbp-108h]
  unsigned __int64 v47; // [rsp+198h] [rbp-100h]
  unsigned __int64 v48; // [rsp+1A0h] [rbp-F8h]
  unsigned __int64 v49; // [rsp+1A8h] [rbp-F0h]
  unsigned __int64 v50; // [rsp+1B0h] [rbp-E8h]
  void *v51; // [rsp+1B8h] [rbp-E0h]
  void *v52; // [rsp+1C0h] [rbp-D8h]
  unsigned __int64 v53; // [rsp+1C8h] [rbp-D0h]
  unsigned __int64 v54; // [rsp+1D0h] [rbp-C8h]
  _QWORD *v55; // [rsp+1D8h] [rbp-C0h]
  _QWORD *v56; // [rsp+1E0h] [rbp-B8h]
  _QWORD *v57; // [rsp+1E8h] [rbp-B0h]
  unsigned __int64 v58; // [rsp+1F0h] [rbp-A8h]
  __int64 *v59; // [rsp+1F8h] [rbp-A0h]
  unsigned __int64 v60; // [rsp+200h] [rbp-98h]
  __int64 *v61; // [rsp+208h] [rbp-90h]
  bool v62; // [rsp+217h] [rbp-81h]
  void *v63; // [rsp+218h] [rbp-80h]
  void *v64; // [rsp+220h] [rbp-78h]
  unsigned __int64 v65; // [rsp+228h] [rbp-70h]
  _QWORD *v66; // [rsp+230h] [rbp-68h]
  _QWORD *v67; // [rsp+238h] [rbp-60h]
  __int64 v68; // [rsp+240h] [rbp-58h]
  __int64 v69; // [rsp+248h] [rbp-50h]
  __int64 v70; // [rsp+250h] [rbp-48h]
  __int64 v71; // [rsp+258h] [rbp-40h]
  __int64 v72; // [rsp+260h] [rbp-38h]
  unsigned __int64 v73; // [rsp+268h] [rbp-30h]
  size_t v74; // [rsp+270h] [rbp-28h]
  unsigned __int64 v75; // [rsp+278h] [rbp-20h]
  __int64 v76; // [rsp+280h] [rbp-18h]
  __int64 v77; // [rsp+288h] [rbp-10h]
  unsigned __int64 v78; // [rsp+290h] [rbp-8h]

  v20 = a3;
  v21 = a4;
  v22 = a5;
  v23 = a6;
  v37[2] = a1;
  v37[3] = a2;
  v38 = a7 & 1;
  v39 = &off_7FF705400800;
  v40 = 0;
  v41 = 0;
  v42 = &v20;
  v26 = a4;
  if ( a4 )
  {
    v43 = &v26;
    v44 = &v20;
    v18 = v20;
    v45 = &v22;
    if ( v20 == v22 )
    {
      v58 = v26;
      v59 = &v22;
      v17 = v23;
      v60 = v23;
      v61 = &v20;
      v62 = v23 >= v26;
      sub_7FF7053E43E0(v23 >= v26, &off_7FF7054008C8);
      v63 = a2;
      v64 = a2;
      v28[0] = v20;
      v28[1] = v21;
      v65 = v17;
      v66 = v28;
      v67 = v28;
      v11 = sub_7FF7053E5E50(a2);
      v27 = v11;
      v68 = v11;
      v36 = v11;
      if ( v11 )
      {
        sub_7FF7053E1BC0(v27, &off_7FF7054007A0);
        v30 = v36;
      }
      else
      {
        v30 = 0LL;
      }
      if ( v30 )
      {
        v69 = v30;
        v29 = v30;
      }
      else
      {
        v29 = 0LL;
      }
      if ( v29 )
      {
        v70 = v29;
        v28[2] = v29;
        v14 = v29;
        v71 = v29;
        if ( (a7 & 1) != 0 )
        {
          v72 = v27;
          v73 = v26;
          v12 = (v26 + v27);
          v74 = v26 + v27;
          v13 = v17 - v26;
          v75 = v17 - v26;
          sub_7FF7053E3B50(v26 + v27, 1uLL, v17 == v26, &off_7FF7054008E0);
          memset(v12, 0, v13);
        }
        v76 = v14;
        v77 = v14;
        v78 = v17;
        sub_7FF7053E1BC0(v14, &off_7FF705400778);
        v24 = v14;
        v25 = v17;
      }
      else
      {
        v24 = 0LL;
        v25 = 0LL;
      }
    }
    else
    {
      v46 = v26;
      v9 = sub_7FF7053E48C0(a1, v22, v23, a7 & 1);
      v33 = v9;
      v34 = v10;
      if ( v9 )
      {
        v47 = v33;
        v48 = v34;
        v31 = v33;
        v32 = v34;
        v15 = v33;
        v16 = v34;
        v49 = v33;
        v50 = v34;
        v51 = a2;
        v52 = a2;
        v53 = v33;
        v54 = v26;
        sub_7FF7053E3D10(a2, v33, 1uLL, 1uLL, v26, &off_7FF705400860);
        memcpy(v15, a2, v26);
        v35[0] = v20;
        v35[1] = v21;
        v55 = v35;
        if ( v26 )
        {
          v37[0] = v20;
          v37[1] = v21;
          v56 = v37;
          v57 = v37;
          sub_7FF7053E5E40(a2, v26, v18);
        }
        v24 = v15;
        v25 = v16;
      }
      else
      {
        v24 = 0LL;
        v25 = 0LL;
      }
    }
  }
  else
  {
    v24 = sub_7FF7053E48C0(a1, v22, v23, a7 & 1);
    v25 = v7;
  }
  return v24;
}
// 7FF7053E4C4C: variable 'v7' is possibly undefined
// 7FF7053E4CFF: variable 'v10' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705400778: using guessed type char *off_7FF705400778;
// 7FF7054007A0: using guessed type char *off_7FF7054007A0;
// 7FF705400800: using guessed type char *off_7FF705400800;
// 7FF705400860: using guessed type char *off_7FF705400860;
// 7FF7054008C8: using guessed type char *off_7FF7054008C8;
// 7FF7054008E0: using guessed type char *off_7FF7054008E0;

//----- (00007FF7053E51E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E51E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v5; // [rsp+38h] [rbp-50h] BYREF
  __int64 v6; // [rsp+40h] [rbp-48h]
  _QWORD v7[8]; // [rsp+48h] [rbp-40h] BYREF

  v5 = a3;
  v6 = a4;
  v7[2] = a1;
  v7[3] = a2;
  v7[4] = &v5;
  result = a4;
  if ( a4 )
  {
    v7[5] = a2;
    v7[0] = v5;
    v7[1] = v6;
    v7[6] = v7;
    v7[7] = v7;
    return sub_7FF7053E5E40(a2, a4, v5);
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E5270) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E5270(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_7FF7053E48C0(a1, a2, a3, 1);
}

//----- (00007FF7053E52A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E52A0(
        __int64 a1,
        void *a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        unsigned __int64 a6)
{
  return sub_7FF7053E4B60(a1, a2, a3, a4, a5, a6, 0);
}

//----- (00007FF7053E52F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E52F0(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_7FF7053E48C0(a1, a2, a3, 0);
}

//----- (00007FF7053E5320) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053E5320(unsigned __int64 *a1, unsigned __int64 a2)
{
  if ( !is_mul_ok(a2, a1[1]) )
    return 0LL;
  if ( a2 * a1[1] > 0x8000000000000000uLL - *a1 )
    return 0LL;
  return *a1;
}

//----- (00007FF7053E5400) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053E5400(unsigned __int64 a1, unsigned __int64 a2, __int64 a3)
{
  bool result; // al
  __int128 v5; // [rsp+30h] [rbp-50h] BYREF
  __int64 v6; // [rsp+40h] [rbp-40h]
  __int64 v7; // [rsp+48h] [rbp-38h]
  __int64 v8; // [rsp+50h] [rbp-30h]
  _QWORD *v9; // [rsp+58h] [rbp-28h]
  _QWORD v10[8]; // [rsp+60h] [rbp-20h] BYREF

  v10[7] = -2LL;
  v10[2] = a1;
  v10[3] = a2;
  v10[4] = "unsafe precondition(s) violated: Layout::from_size_align_unchecked requires that align is a power of 2 and th"
           "e rounded-up allocation size does not exceed isize::MAX\n"
           "\n"
           "This indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for s"
           "afety./rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\\library\\core\\src\\alloc\\layout.rs";
  v10[5] = 281LL;
  try
  {
    result = sub_7FF7053FBD80(a1, a2);
  }
  catch ( ... )
  {
    sub_7FF7053FE29A();
  }
  if ( !result )
  {
    v10[0] = "unsafe precondition(s) violated: Layout::from_size_align_unchecked requires that align is a power of 2 and "
             "the rounded-up allocation size does not exceed isize::MAX\n"
             "\n"
             "This indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for"
             " safety./rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\\library\\core\\src\\alloc\\layout.rs";
    v10[1] = 281LL;
    v10[6] = v10;
    *&v5 = v10;
    *(&v5 + 1) = 1LL;
    v8 = 0LL;
    v9 = v10;
    v6 = 8LL;
    v7 = 0LL;
    sub_7FF7053FE140(&v5, 0, a3);
  }
  return result;
}
// 7FF7053FE29A: using guessed type void __noreturn sub_7FF7053FE29A(void);

//----- (00007FF7053E54D0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 *__fastcall sub_7FF7053E54D0(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdx
  unsigned __int64 v8; // [rsp+48h] [rbp-80h]
  unsigned __int64 v9[2]; // [rsp+50h] [rbp-78h] BYREF
  unsigned __int64 v10; // [rsp+60h] [rbp-68h]
  unsigned __int64 v11; // [rsp+68h] [rbp-60h]
  unsigned __int64 v12; // [rsp+70h] [rbp-58h]
  unsigned __int64 v13; // [rsp+78h] [rbp-50h]
  unsigned __int64 v14; // [rsp+80h] [rbp-48h]
  unsigned __int64 *v15; // [rsp+88h] [rbp-40h]
  unsigned __int64 v16; // [rsp+90h] [rbp-38h]
  unsigned __int64 v17; // [rsp+98h] [rbp-30h]
  unsigned __int64 v18; // [rsp+A0h] [rbp-28h]
  unsigned __int64 v19; // [rsp+A8h] [rbp-20h]
  unsigned __int64 v20; // [rsp+B0h] [rbp-18h]
  unsigned __int64 v21; // [rsp+B8h] [rbp-10h]
  unsigned __int64 *v22; // [rsp+C0h] [rbp-8h]

  v15 = a2;
  v16 = a3;
  v17 = *a2;
  v18 = v17;
  v8 = ~(v17 - 1) & (a2[1] + v17 - 1);
  v19 = v8;
  sub_7FF7053E5400(v8, v17, &off_7FF705400A78);
  v9[1] = v8;
  v9[0] = v17;
  v10 = sub_7FF7053E5320(v9, a3);
  v11 = v3;
  if ( v10 )
  {
    v20 = v10;
    v21 = v11;
    v22 = v9;
    v12 = v10;
    v13 = v11;
    v14 = v8;
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v14;
  }
  else
  {
    *a1 = 0LL;
  }
  return a1;
}
// 7FF7053E556B: variable 'v3' is possibly undefined
// 7FF705400A78: using guessed type char *off_7FF705400A78;

//----- (00007FF7053E5610) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E5610(_QWORD *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // rax
  __int64 v5; // rdx
  __int128 v6; // xmm0
  __int128 v11; // [rsp+60h] [rbp-20h] BYREF
  __int64 v12; // [rsp+70h] [rbp-10h]
  __int128 v13; // [rsp+78h] [rbp-8h] BYREF
  __int64 v14; // [rsp+88h] [rbp+8h]
  __int128 v15; // [rsp+90h] [rbp+10h]
  __int64 v16; // [rsp+A0h] [rbp+20h]
  unsigned __int64 v17[3]; // [rsp+B0h] [rbp+30h] BYREF
  __int128 v18; // [rsp+C8h] [rbp+48h] BYREF
  __int64 v19; // [rsp+D8h] [rbp+58h]
  __int128 v20; // [rsp+E0h] [rbp+60h]
  __int64 v21; // [rsp+F0h] [rbp+70h]
  _OWORD v22[2]; // [rsp+100h] [rbp+80h] BYREF
  char v23; // [rsp+127h] [rbp+A7h]
  __int64 v24; // [rsp+128h] [rbp+A8h]
  __int64 v25; // [rsp+130h] [rbp+B0h]
  __int64 v26; // [rsp+138h] [rbp+B8h]
  unsigned __int64 v27; // [rsp+140h] [rbp+C0h]
  unsigned __int64 v28; // [rsp+148h] [rbp+C8h]
  unsigned __int64 v29; // [rsp+150h] [rbp+D0h]
  unsigned __int64 v30; // [rsp+158h] [rbp+D8h]
  __int128 *v31; // [rsp+160h] [rbp+E0h]
  __int64 v32; // [rsp+168h] [rbp+E8h]
  __int128 *v33; // [rsp+170h] [rbp+F0h]
  __int64 v34; // [rsp+178h] [rbp+F8h]

  v34 = -2LL;
  v24 = 1LL;
  v25 = 4LL;
  v26 = 1LL;
  v23 = 1;
  sub_7FF7053E9290(&v13, a2);
  if ( v13 == 0x8000000000000000uLL )
  {
    *a1 = 0LL;
    a1[1] = 8LL;
    a1[2] = 0LL;
    sub_7FF7053E3420(a2);
  }
  else
  {
    v16 = v14;
    v15 = v13;
    sub_7FF7053E1B90(v17, a2);
    v27 = v17[0];
    v4 = v17[0] + 1;
    if ( v17[0] == -1LL )
      v4 = -1LL;
    v28 = v4;
    v29 = v4;
    v30 = sub_7FF7053E4680(4uLL, v4);
    *&v18 = sub_7FF7053E2E20(v30, 8uLL, 0x18uLL, a3);
    *(&v18 + 1) = v5;
    v31 = &v18;
    v32 = v5;
    v21 = v16;
    v20 = v15;
    *(v5 + 16) = v16;
    *v5 = v20;
    v33 = &v18;
    v19 = 1LL;
    v12 = 1LL;
    v11 = v18;
    v23 = 0;
    v6 = *a2;
    v22[1] = *(a2 + 16);
    v22[0] = v6;
    sub_7FF7053E5DF0(&v11, v22);
    *a1 = v11;
    a1[2] = v12;
  }
  return a1;
}
// 7FF7053E575C: variable 'v5' is possibly undefined

//----- (00007FF7053E58A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E58A0(_QWORD *a1)
{
  _QWORD *result; // rax

  result = a1;
  *a1 = 0LL;
  a1[1] = 4LL;
  a1[2] = 0LL;
  return result;
}

//----- (00007FF7053E58C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E58C0(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // rdx
  unsigned __int64 v3; // rax
  unsigned __int64 v5; // [rsp+20h] [rbp-60h]
  unsigned __int64 v8[3]; // [rsp+40h] [rbp-40h] BYREF
  unsigned __int64 v9; // [rsp+58h] [rbp-28h]
  unsigned __int64 v10; // [rsp+60h] [rbp-20h]
  unsigned __int64 v11; // [rsp+68h] [rbp-18h]
  unsigned __int64 v12; // [rsp+70h] [rbp-10h]
  unsigned __int64 v13[4]; // [rsp+78h] [rbp-8h] BYREF
  unsigned __int64 v14; // [rsp+98h] [rbp+18h]
  unsigned __int64 v15; // [rsp+A0h] [rbp+20h]
  unsigned __int64 *v16; // [rsp+A8h] [rbp+28h]
  __int64 v17; // [rsp+B0h] [rbp+30h]
  unsigned __int64 v18; // [rsp+B8h] [rbp+38h]
  unsigned __int64 *v19; // [rsp+C0h] [rbp+40h]
  unsigned __int64 *v20; // [rsp+C8h] [rbp+48h]
  __int64 v21; // [rsp+D0h] [rbp+50h]
  unsigned __int64 v22; // [rsp+D8h] [rbp+58h]
  unsigned __int64 v23; // [rsp+E0h] [rbp+60h]
  unsigned __int64 v24; // [rsp+E8h] [rbp+68h]
  unsigned __int64 v25; // [rsp+F0h] [rbp+70h]
  unsigned __int64 *v26; // [rsp+F8h] [rbp+78h]
  unsigned __int64 v27; // [rsp+100h] [rbp+80h]
  __int64 v28; // [rsp+108h] [rbp+88h]

  v28 = -2LL;
  v16 = a1;
  v17 = 1LL;
  while ( 1 )
  {
    sub_7FF7053E9290(v8, a2);
    if ( v8[0] == 0x8000000000000000uLL )
      break;
    v9 = v8[0];
    v10 = v8[1];
    v11 = v8[2];
    v5 = a1[2];
    v18 = v5;
    v19 = a1;
    v20 = a1;
    v21 = 24LL;
    v22 = *a1;
    v12 = v22;
    if ( v5 == v22 )
    {
      sub_7FF7053E1B90(v13, a2);
      v23 = v13[0];
      v3 = v13[0] + 1;
      if ( v13[0] == -1LL )
        v3 = -1LL;
      v24 = v3;
      sub_7FF7053E5B70(a1, v3);
    }
    v25 = a1[1];
    v2 = (24 * v5 + v25);
    v26 = v2;
    v13[3] = v9;
    v14 = v10;
    v15 = v11;
    *v2 = v9;
    v2[1] = v14;
    v2[2] = v15;
    v27 = v5 + 1;
    a1[2] = v5 + 1;
  }
  sub_7FF7053E37C0(v8);
  return sub_7FF7053E3420(a2);
}

//----- (00007FF7053E5A90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E5A90(__int64 a1)
{
  return *(a1 + 16);
}

//----- (00007FF7053E5AA0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 *__fastcall sub_7FF7053E5AA0(unsigned __int64 *a1, int a2, __int64 a3)
{
  unsigned __int64 *result; // rax
  unsigned __int64 v6; // [rsp+38h] [rbp-48h]

  v6 = a1[2];
  if ( v6 == *a1 )
    sub_7FF7053E21A0(a1, a3);
  result = a1;
  *(4 * v6 + a1[1]) = a2;
  a1[2] = v6 + 1;
  return result;
}

//----- (00007FF7053E5B70) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_BOOL8 __fastcall sub_7FF7053E5B70(unsigned __int64 *a1, unsigned __int64 a2)
{
  _BOOL8 result; // rax
  __int64 v3; // [rsp+38h] [rbp-70h]
  _QWORD v4[12]; // [rsp+40h] [rbp-68h] BYREF
  unsigned __int64 v5; // [rsp+A0h] [rbp-8h]

  v4[3] = a1;
  v4[4] = a2;
  v4[5] = a1;
  v3 = a1[2];
  v4[6] = v3;
  v4[7] = a1;
  v4[8] = 8LL;
  v4[9] = 24LL;
  v4[0] = 8LL;
  v4[1] = 24LL;
  v4[10] = v4;
  v4[11] = 24LL;
  v5 = *a1;
  v4[2] = v5;
  result = a2;
  if ( a2 > v5 - v3 )
    return sub_7FF7053E2F80(a1, v3, a2, 8uLL, 0x18uLL);
  return result;
}

//----- (00007FF7053E5C40) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E5C40(__int64 a1)
{
  __int64 v2; // [rsp+30h] [rbp-28h]

  v2 = *(a1 + 8);
  sub_7FF7053E1950(v2, 4uLL, 4uLL, *(a1 + 16), &off_7FF705400AE0);
  return v2;
}
// 7FF705400AE0: using guessed type char *off_7FF705400AE0;

//----- (00007FF7053E5CA0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E5CA0(__int64 a1)
{
  __int64 v2; // [rsp+30h] [rbp-28h]

  v2 = *(a1 + 8);
  sub_7FF7053E1950(v2, 1uLL, 1uLL, *(a1 + 16), &off_7FF705400AE0);
  return v2;
}
// 7FF705400AE0: using guessed type char *off_7FF705400AE0;

//----- (00007FF7053E5D00) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E5D00(__int64 a1)
{
  return sub_7FF7053E5C40(a1);
}

//----- (00007FF7053E5D20) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E5D20(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v6; // [rsp+38h] [rbp-40h]
  unsigned __int64 v7; // [rsp+40h] [rbp-38h]

  v6 = *(a1 + 8);
  v7 = *(a1 + 16);
  sub_7FF7053E1950(v6, 0x18uLL, 8uLL, v7, &off_7FF705400AE0);
  return sub_7FF7053E3AF0(a2, v6, v7, a3);
}
// 7FF705400AE0: using guessed type char *off_7FF705400AE0;

//----- (00007FF7053E5DB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E5DB0(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  _QWORD v7[4]; // [rsp+38h] [rbp-20h] BYREF

  sub_7FF7053E4890(v7, a2);
  sub_7FF7053E5E10(a1, v7, a3);
  return a1;
}

//----- (00007FF7053E5DF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E5DF0(unsigned __int64 *a1, unsigned __int64 *a2)
{
  return sub_7FF7053E58C0(a1, a2);
}

//----- (00007FF7053E5E10) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E5E10(_QWORD *a1, __int64 a2, __int64 a3)
{
  sub_7FF7053E5610(a1, a2, a3);
  return a1;
}

//----- (00007FF7053E5E90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 sub_7FF7053E5E90()
{
  return 0xB98B1B7157A64178uLL;
}

//----- (00007FF7053E5EB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053E5EB0()
{
  return 0x6723D68C895B2603LL;
}

//----- (00007FF7053E5ED0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E5ED0(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rcx
  int v3; // eax

  v2 = *a1;
  v3 = *(a2 + 16);
  if ( (v3 & 0x2000000) != 0 )
    return sub_7FF7053FBDB0(v2, a2);
  if ( (v3 & 0x4000000) != 0 )
    return sub_7FF7053FBE40(v2, a2);
  return sub_7FF7053FC080(v2, a2);
}

//----- (00007FF7053E5F00) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E5F00(__int64 a1, __int64 *a2)
{
  return sub_7FF7053F9980(a2, "(): ", 2uLL);
}

//----- (00007FF7053E5F20) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E5F20(_BYTE **a1, char *a2)
{
  _BYTE *v2; // rcx
  _BYTE *v4; // [rsp+28h] [rbp-8h] BYREF

  v2 = *a1;
  if ( *v2 != 1 )
    return sub_7FF7053F9DC0(a2);
  v4 = v2 + 1;
  return sub_7FF7053F9F80(a2, aSome_0, 4LL, &v4, &unk_7FF705400B38);
}

//----- (00007FF7053E5F90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E5F90(__int64 a1, __int64 *a2)
{
  return sub_7FF7053FA4C0(*a1, *(a1 + 8), a2);
}

//----- (00007FF7053E5FB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E5FB0(_QWORD **a1, __int64 *a2)
{
  _QWORD *v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // r9
  _QWORD v7[6]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v8[6]; // [rsp+50h] [rbp-30h] BYREF
  _QWORD v9[2]; // [rsp+80h] [rbp+0h] BYREF

  v2 = *a1;
  v3 = *a2;
  v4 = a2[1];
  v5 = v2[1] - 1LL;
  v9[0] = *v2;
  v9[1] = v5;
  v8[0] = v9;
  v8[1] = sub_7FF7053E5F90;
  v8[2] = v2 + 2;
  v8[3] = sub_7FF7053FC130;
  v8[4] = v2 + 20;
  v8[5] = sub_7FF7053FC130;
  v7[0] = &unk_7FF705400E90;
  v7[1] = 3LL;
  v7[4] = 0LL;
  v7[2] = v8;
  v7[3] = 3LL;
  return sub_7FF7053F9220(v3, v4, v7);
}

//----- (00007FF7053E6050) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6050(unsigned __int64 *a1, __int64 a2)
{
  int v2; // eax

  v2 = *(a2 + 16);
  if ( (v2 & 0x2000000) != 0 )
    return sub_7FF7053FBF60(a1, a2);
  if ( (v2 & 0x4000000) != 0 )
    return sub_7FF7053FBFF0(a1, a2);
  return sub_7FF7053FC390(a1, a2);
}

//----- (00007FF7053E6070) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053E6070(__int64 a1, unsigned int a2)
{
  unsigned __int64 v3; // r8
  char **v4; // rax
  char **v6; // [rsp+28h] [rbp-18h]
  __int64 *v7; // [rsp+30h] [rbp-10h]
  int v8; // [rsp+3Ch] [rbp-4h] BYREF
  __int64 v9; // [rsp+40h] [rbp+0h]

  v9 = -2LL;
  v8 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(v8) = (a2 >> 18) | 0xF0;
        BYTE1(v8) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(v8) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(v8) = a2 & 0x3F | 0x80;
        v3 = 4LL;
      }
      else
      {
        LOBYTE(v8) = (a2 >> 12) | 0xE0;
        BYTE1(v8) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(v8) = a2 & 0x3F | 0x80;
        v3 = 3LL;
      }
    }
    else
    {
      LOBYTE(v8) = (a2 >> 6) | 0xC0;
      BYTE1(v8) = a2 & 0x3F | 0x80;
      v3 = 2LL;
    }
  }
  else
  {
    LOBYTE(v8) = a2;
    v3 = 1LL;
  }
  v4 = sub_7FF7053EAF30(*a1, &v8, v3);
  if ( v4 )
  {
    v6 = v4;
    v7 = (a1 + 8);
    if ( *(a1 + 8) )
      sub_7FF7053E69E0(v7);
    v4 = v6;
    *v7 = v6;
  }
  return v4 != 0LL;
}

//----- (00007FF7053E61A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053E61A0(__int64 **a1, unsigned int a2)
{
  unsigned __int64 v3; // r8
  __int64 v4; // rax
  char **v5; // rax
  char **v6; // r8
  __int64 v8; // [rsp+28h] [rbp-18h]
  __int64 v9; // [rsp+30h] [rbp-10h]
  __int64 *v10; // [rsp+30h] [rbp-10h]
  int v11; // [rsp+3Ch] [rbp-4h] BYREF
  __int64 v12; // [rsp+40h] [rbp+0h]

  v12 = -2LL;
  v11 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(v11) = (a2 >> 18) | 0xF0;
        BYTE1(v11) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(v11) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(v11) = a2 & 0x3F | 0x80;
        v3 = 4LL;
      }
      else
      {
        LOBYTE(v11) = (a2 >> 12) | 0xE0;
        BYTE1(v11) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(v11) = a2 & 0x3F | 0x80;
        v3 = 3LL;
      }
    }
    else
    {
      LOBYTE(v11) = (a2 >> 6) | 0xC0;
      BYTE1(v11) = a2 & 0x3F | 0x80;
      v3 = 2LL;
    }
  }
  else
  {
    LOBYTE(v11) = a2;
    v3 = 1LL;
  }
  v4 = **a1;
  if ( *(v4 + 16) )
    sub_7FF7053FE030(&off_7FF7054016B0);
  *(v4 + 16) = -1LL;
  v9 = v4;
  v5 = sub_7FF7053EAF30((v4 + 24), &v11, v3);
  v6 = 0LL;
  if ( (v5 & 0xFFFFFFFF00000003uLL) != 0x600000002LL )
    v6 = v5;
  ++*(v9 + 16);
  if ( v6 )
  {
    v8 = v6;
    v10 = (a1 + 1);
    if ( a1[1] )
      sub_7FF7053E69E0(v10);
    v6 = v8;
    *v10 = v8;
  }
  return v6 != 0LL;
}
// 7FF7054016B0: using guessed type char *off_7FF7054016B0;

//----- (00007FF7053E6340) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053E6340(__int64 *a1, unsigned int a2)
{
  unsigned __int64 v3; // rbx
  _QWORD *v4; // r15
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // r12
  unsigned __int64 v7; // rcx
  size_t v8; // r14
  void *v9; // rcx
  size_t v10; // rdi
  __int64 *v12; // [rsp+28h] [rbp-18h]
  int Src; // [rsp+34h] [rbp-Ch] BYREF
  __int64 v14; // [rsp+38h] [rbp-8h]

  v14 = -2LL;
  Src = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(Src) = (a2 >> 18) | 0xF0;
        BYTE1(Src) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(Src) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(Src) = a2 & 0x3F | 0x80;
        v3 = 4LL;
      }
      else
      {
        LOBYTE(Src) = (a2 >> 12) | 0xE0;
        BYTE1(Src) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(Src) = a2 & 0x3F | 0x80;
        v3 = 3LL;
      }
    }
    else
    {
      LOBYTE(Src) = (a2 >> 6) | 0xC0;
      BYTE1(Src) = a2 & 0x3F | 0x80;
      v3 = 2LL;
    }
  }
  else
  {
    LOBYTE(Src) = a2;
    v3 = 1LL;
  }
  v4 = *a1;
  v5 = *(*a1 + 8);
  v7 = *(*a1 + 16);
  v6 = v7;
  if ( v5 < v7 )
    v7 = *(*a1 + 8);
  v8 = v5 - v7;
  v9 = (*v4 + v7);
  v10 = v3;
  if ( v8 < v3 )
    v10 = v8;
  memcpy(v9, &Src, v10);
  v4[2] = v6 + v10;
  if ( v8 < v3 )
  {
    v12 = a1 + 1;
    if ( a1[1] )
      sub_7FF7053E69E0(v12);
    *v12 = &off_7FF705401318;
  }
  return v8 < v3;
}
// 7FF705401318: using guessed type char *off_7FF705401318;

//----- (00007FF7053E64B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053E64B0(__int64 a1, unsigned int a2)
{
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rax
  unsigned __int64 v6; // [rsp+28h] [rbp-18h]
  __int64 *v7; // [rsp+30h] [rbp-10h]
  int v8; // [rsp+3Ch] [rbp-4h] BYREF
  __int64 v9; // [rsp+40h] [rbp+0h]

  v9 = -2LL;
  v8 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(v8) = (a2 >> 18) | 0xF0;
        BYTE1(v8) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(v8) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(v8) = a2 & 0x3F | 0x80;
        v3 = 4LL;
      }
      else
      {
        LOBYTE(v8) = (a2 >> 12) | 0xE0;
        BYTE1(v8) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(v8) = a2 & 0x3F | 0x80;
        v3 = 3LL;
      }
    }
    else
    {
      LOBYTE(v8) = (a2 >> 6) | 0xC0;
      BYTE1(v8) = a2 & 0x3F | 0x80;
      v3 = 2LL;
    }
  }
  else
  {
    LOBYTE(v8) = a2;
    v3 = 1LL;
  }
  v4 = sub_7FF7053E9F00(*a1, &v8, v3);
  if ( v4 )
  {
    v6 = v4;
    v7 = (a1 + 8);
    if ( *(a1 + 8) )
      sub_7FF7053E69E0(v7);
    v4 = v6;
    *v7 = v6;
  }
  return v4 != 0;
}

//----- (00007FF7053E65E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E65E0(unsigned __int64 **a1, unsigned int a2)
{
  size_t v2; // rsi
  unsigned __int64 *v3; // rdi
  __int64 v4; // rbx
  int Src; // [rsp+34h] [rbp+4h] BYREF

  Src = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(Src) = (a2 >> 18) | 0xF0;
        BYTE1(Src) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(Src) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(Src) = a2 & 0x3F | 0x80;
        v2 = 4LL;
      }
      else
      {
        LOBYTE(Src) = (a2 >> 12) | 0xE0;
        BYTE1(Src) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(Src) = a2 & 0x3F | 0x80;
        v2 = 3LL;
      }
    }
    else
    {
      LOBYTE(Src) = (a2 >> 6) | 0xC0;
      BYTE1(Src) = a2 & 0x3F | 0x80;
      v2 = 2LL;
    }
  }
  else
  {
    LOBYTE(Src) = a2;
    v2 = 1LL;
  }
  v3 = *a1;
  v4 = (*a1)[2];
  if ( v2 > **a1 - v4 )
  {
    sub_7FF7053FD5A0(v3, v4, v2, 1LL, 1LL);
    v4 = v3[2];
  }
  memcpy((v4 + v3[1]), &Src, v2);
  v3[2] = v2 + v4;
  return 0LL;
}

//----- (00007FF7053E66E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E66E0(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9220(a1, &off_7FF705400F50, a2);
}
// 7FF705400F50: using guessed type __int64 (__fastcall *off_7FF705400F50)();

//----- (00007FF7053E66F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E66F0(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9220(a1, &off_7FF705400FB0, a2);
}
// 7FF705400FB0: using guessed type __int64 (__fastcall *off_7FF705400FB0)();

//----- (00007FF7053E6700) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E6700(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9220(a1, &off_7FF705400EC0, a2);
}
// 7FF705400EC0: using guessed type __int64 (__fastcall *off_7FF705400EC0)();

//----- (00007FF7053E6710) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E6710(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9220(a1, &off_7FF705400F20, a2);
}
// 7FF705400F20: using guessed type __int64 (__fastcall *off_7FF705400F20)();

//----- (00007FF7053E6720) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E6720(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9220(a1, &off_7FF705400F80, a2);
}
// 7FF705400F80: using guessed type __int64 (__fastcall *off_7FF705400F80)();

//----- (00007FF7053E6730) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E6730(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9220(a1, &off_7FF705400EF0, a2);
}
// 7FF705400EF0: using guessed type __int64 (__fastcall *off_7FF705400EF0)();

//----- (00007FF7053E6740) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6740(__int64 **a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 result; // rax

  v3 = **a1;
  **a1 = 0LL;
  if ( !v3 )
    sub_7FF7053FE090(&off_7FF705401AB0);
  nullsub_1(a1, a2, a3);
  result = sub_7FF7053E5E30(1024LL, 1LL);
  if ( !result )
    sub_7FF7053FDFF0(1LL, 1024LL, &off_7FF705401218);
  *v3 = 0LL;
  *(v3 + 8) = 0;
  *(v3 + 12) = 0;
  *(v3 + 16) = 0LL;
  *(v3 + 24) = 1024LL;
  *(v3 + 32) = result;
  *(v3 + 40) = 0LL;
  *(v3 + 48) = 0;
  *(v3 + 53) = 0;
  *(v3 + 49) = 0;
  return result;
}
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD);
// 7FF705401218: using guessed type char *off_7FF705401218;
// 7FF705401AB0: using guessed type char *off_7FF705401AB0;

//----- (00007FF7053E67E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E67E0(char **a1)
{
  char *v2; // [rsp+28h] [rbp-8h] BYREF

  v2 = *a1;
  return sub_7FF7053ECBB0(&v2);
}

//----- (00007FF7053E6810) ----------------------------------------------------
char __fastcall sub_7FF7053E6810(__int64 a1, __int64 *a2, __int128 *a3)
{
  char v3; // r8
  __int64 v4; // rsi
  __int64 v5; // r9
  bool v6; // of
  char result; // al
  char v8; // bl
  __int128 v9; // [rsp+28h] [rbp-28h] BYREF
  __int64 v10; // [rsp+38h] [rbp-18h]
  __int64 v11; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v12 = -2LL;
  v9 = *a3;
  v10 = *(a3 + 2);
  v3 = *(a1 + 32);
  v4 = *a1;
  v5 = 0LL;
  v6 = __OFSUB__(-*a1, 1LL);
  v11 = a1;
  if ( !v6 )
    v5 = a1;
  result = sub_7FF7053ED890(a2, &v9, v3, v5);
  if ( 2 * v4 )
  {
    v8 = result;
    sub_7FF7053E5E40(*(v11 + 8), v4, 1LL);
    return v8;
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E68D0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E68D0(_QWORD **a1)
{
  _QWORD *v1; // rdx
  _BYTE *v2; // rcx
  __int64 result; // rax
  _BYTE v4[19]; // [rsp+2Dh] [rbp-13h]

  v1 = *a1;
  v2 = **a1;
  result = v1[1];
  *v1 = 0LL;
  if ( !v2 )
    sub_7FF7053FE090(&off_7FF705401AB0);
  *v2 = 1;
  *&v4[3] = 0LL;
  *result = 0LL;
  *(result + 8) = 0;
  *(result + 12) = 0;
  *(result + 13) = *v4;
  *(result + 28) = 0;
  *(result + 32) = 1LL;
  *(result + 40) = 0LL;
  *(result + 48) = 0;
  *(result + 53) = 0;
  *(result + 49) = 0;
  return result;
}
// 7FF7053E6910: variable 'v4' is possibly undefined
// 7FF705401AB0: using guessed type char *off_7FF705401AB0;

//----- (00007FF7053E6950) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E6950(__int64 a1)
{
  __int64 result; // rax

  if ( *(a1 + 8) )
    return sub_7FF7053E69E0((a1 + 8));
  return result;
}

//----- (00007FF7053E6970) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053E6970(__int64 a1)
{
  char v2; // al

  if ( (*(a1 + 8))-- == 1 )
  {
    *a1 = 0LL;
    v2 = *(a1 + 12);
    *(a1 + 12) = 0;
    if ( v2 == 2 )
      WakeByAddressSingle((a1 + 12));
  }
}

//----- (00007FF7053E69A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053E69A0(__int64 a1)
{
  volatile signed __int64 *v1; // rax

  if ( (*a1 & 1) == 0 )
  {
    v1 = *(a1 + 8);
    if ( v1 )
    {
      if ( !_InterlockedDecrement64(v1) )
        sub_7FF7053E7980((a1 + 8));
    }
  }
}

//----- (00007FF7053E69C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E69C0(_QWORD *a1)
{
  __int64 result; // rax

  if ( *a1 )
    return sub_7FF7053E5E40(a1[1], *a1, 1LL);
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E69E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E69E0(__int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // rdx
  __int64 v3; // [rsp+20h] [rbp-20h]
  __int64 v4; // [rsp+28h] [rbp-18h]
  __int64 v5; // [rsp+30h] [rbp-10h]

  result = *a1;
  if ( (*a1 & 3) == 1 )
  {
    v3 = result - 1;
    v4 = *(result - 1);
    v5 = *(result + 7);
    if ( *v5 )
      (*v5)(v4);
    v2 = *(v5 + 8);
    if ( v2 )
      sub_7FF7053E5E40(v4, v2, *(v5 + 16));
    return sub_7FF7053E5E40(v3, 24LL, 8LL);
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E6AB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6AB0(_QWORD *a1)
{
  __int64 result; // rax

  if ( *a1 )
    return sub_7FF7053E5E40(a1[1], *a1, 1LL);
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E6AD0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053E6AD0(_BYTE *a1, char a2)
{
  char v2; // al
  _BYTE *v3; // rsi
  bool v4; // al

  if ( (a2 & 1) == 0 )
  {
    if ( 2 * qword_7FF70540B1E0 )
    {
      v3 = a1;
      v4 = sub_7FF7053FD820();
      a1 = v3;
      if ( !v4 )
        v3[1] = 1;
    }
  }
  v2 = *a1;
  *a1 = 0;
  if ( v2 == 2 )
    WakeByAddressSingle(a1);
}
// 7FF70540B1E0: using guessed type __int64 qword_7FF70540B1E0;

//----- (00007FF7053E6B20) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6B20(_QWORD *a1)
{
  __int64 result; // rax

  if ( *a1 )
    return sub_7FF7053E5E40(a1[1], *a1, 1LL);
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E6B40) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6B40(_QWORD *a1)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  _QWORD *v4; // r14
  __int64 v5; // rdx
  __int64 result; // rax

  v2 = a1[1];
  v3 = a1[2];
  if ( v3 )
  {
    v4 = (v2 + 8);
    do
    {
      v5 = *(v4 - 1);
      if ( v5 )
        result = sub_7FF7053E5E40(*v4, v5, 1LL);
      v4 += 4;
      --v3;
    }
    while ( v3 );
  }
  if ( *a1 )
    return sub_7FF7053E5E40(v2, 32LL * *a1, 8LL);
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E6BD0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6BD0(_QWORD *a1)
{
  __int64 result; // rax

  result = 2LL * *a1;
  if ( result )
    return sub_7FF7053E5E40(a1[1], *a1, 1LL);
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E6BF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6BF0(__int64 *a1)
{
  __int64 result; // rax

  if ( *a1 )
    return sub_7FF7053E69E0(a1);
  return result;
}

//----- (00007FF7053E6C00) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6C00(_QWORD *a1)
{
  __int64 result; // rax

  result = 2LL * *a1;
  if ( result )
    return sub_7FF7053E5E40(a1[1], *a1, 1LL);
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E6C20) ----------------------------------------------------
void __fastcall sub_7FF7053E6C20(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  bool v3; // cf
  size_t v4; // rsi

  if ( a2 )
  {
    v2 = *(a1 + 16);
    v3 = v2 < a2;
    v4 = v2 - a2;
    if ( v3 )
      sub_7FF7053FE4E0(a2, *(a1 + 16), &off_7FF705400D40);
    *(a1 + 16) = 0LL;
    if ( v4 )
    {
      memmove(*(a1 + 8), (*(a1 + 8) + a2), v4);
      *(a1 + 16) = v4;
    }
  }
}
// 7FF705400D40: using guessed type char *off_7FF705400D40;

//----- (00007FF7053E6C80) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053E6C80(volatile signed __int32 *a1)
{
  signed __int32 v1; // edx

  v1 = _InterlockedDecrement(a1);
  if ( __OFSUB__(-(v1 & 0xBFFFFFFF), 1) )
    sub_7FF7053FDD40(a1, v1);
}

//----- (00007FF7053E6CA0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053E6CA0(__int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rdx
  unsigned __int64 v4; // [rsp+28h] [rbp-28h]
  __int64 v5; // [rsp+30h] [rbp-20h]
  __int64 v6; // [rsp+38h] [rbp-18h]
  __int64 *v7; // [rsp+40h] [rbp-10h]

  if ( *(a1 + 24) || (v7 = a1, v1 = sub_7FF7053E9430(a1), a1 = v7, (v1 & 3) != 1) )
  {
    v2 = *a1;
    if ( !*a1 )
      return;
    goto LABEL_4;
  }
  v4 = v1 - 1;
  v5 = *(v1 - 1);
  v6 = *(v1 + 7);
  if ( *v6 )
    (*v6)(v5);
  v3 = *(v6 + 8);
  if ( v3 )
    sub_7FF7053E5E40(v5, v3, *(v6 + 16));
  sub_7FF7053E5E40(v4, 24LL, 8LL);
  a1 = v7;
  v2 = *v7;
  if ( *v7 )
LABEL_4:
    sub_7FF7053E5E40(*(a1 + 8), v2, 1LL);
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E6DF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053E6DF0()
{
  return 0LL;
}

//----- (00007FF7053E6E00) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6E00(unsigned __int64 *a1, __int64 a2)
{
  return sub_7FF7053FA660(*a1, a2);
}

//----- (00007FF7053E6E10) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E6E10(_QWORD *a1)
{
  return (*(a1[1] + 24LL))(*a1);
}

//----- (00007FF7053E6E30) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E6E30(char *Buf1, size_t Size, char *Buf2, size_t a4)
{
  char *v4; // r12
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rbx
  unsigned __int8 v8; // al
  size_t v9; // rdx
  char *v10; // r8
  __int64 v11; // r9
  char *v12; // rdi
  unsigned __int64 v13; // rcx
  unsigned __int8 v14; // cl
  size_t v15; // rdx
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // r11
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // r9
  size_t v20; // r14
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // r12
  bool v23; // zf
  unsigned __int64 v24; // r10
  unsigned __int64 v25; // r8
  char v26; // r10
  unsigned int v27; // eax
  __int64 v28; // r9
  int v29; // r9d
  int v30; // r11d
  int v31; // eax
  __m128i v32; // xmm0
  __m128i v33; // xmm6
  __m128i v34; // xmm0
  __m128i v35; // xmm7
  __int64 v36; // r15
  __m128i v37; // xmm12
  __m128i v38; // xmm10
  __m128i v39; // xmm8
  __m128i v40; // xmm13
  __m128i v41; // xmm11
  __m128i v42; // xmm9
  int v43; // r8d
  int v44; // r8d
  int v45; // r8d
  int v46; // r8d
  size_t v47; // rax
  int v48; // eax
  char v49; // al
  int v50; // eax
  char v51; // al
  int v52; // eax
  char v53; // al
  int v54; // eax
  const __m128i *v55; // r13
  char **v56; // rcx
  int v57; // r8d
  unsigned __int64 v58; // rax
  int v59; // eax
  int v60; // r8d
  int v61; // eax
  unsigned __int64 v62; // r15
  unsigned __int64 v63; // r9
  unsigned __int64 v64; // r12
  unsigned __int64 v66; // r15
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // rcx
  size_t v69; // r9
  __int64 v70; // r9
  char *v71; // r10
  unsigned __int64 v72; // rsi
  char v73; // r14
  unsigned __int64 v74; // r10
  unsigned __int64 v75; // r9
  char v76; // cl
  unsigned __int64 v77; // rcx
  unsigned __int64 v78; // r15
  char *v79; // [rsp+38h] [rbp-48h] BYREF
  unsigned __int64 v80; // [rsp+40h] [rbp-40h]
  unsigned __int64 v81; // [rsp+48h] [rbp-38h]
  size_t v82; // [rsp+50h] [rbp-30h]
  size_t v83; // [rsp+58h] [rbp-28h]
  unsigned __int64 v84; // [rsp+60h] [rbp-20h]
  unsigned __int64 v85; // [rsp+70h] [rbp-10h]
  _BYTE *v86; // [rsp+80h] [rbp+0h]
  unsigned __int64 v87; // [rsp+88h] [rbp+8h]
  __int64 v88; // [rsp+90h] [rbp+10h]
  unsigned __int64 v89; // [rsp+98h] [rbp+18h]
  unsigned __int64 v90; // [rsp+A0h] [rbp+20h]
  size_t v91; // [rsp+A8h] [rbp+28h]

  v4 = Buf2;
  v6 = Buf1;
  if ( Size < a4 )
  {
    v7 = a4;
    v8 = *Buf1;
    v9 = Size - 4;
    v10 = Buf1 - 1;
    v11 = 0LL;
    v12 = v4;
    while ( v9 < Size + v11 )
    {
      v13 = Size + v11 - 1;
      if ( v13 >= Size )
        sub_7FF7053FE234(v13, Size, &off_7FF705400BA8);
      v14 = v10[Size];
      --v12;
      --v11;
      --v10;
      if ( v14 != v8 )
      {
        v15 = Size + 15;
        if ( v7 < Size + 15 )
        {
          while ( memcmp(v4, v6, Size) )
          {
            ++v4;
            if ( Size > --v7 )
              goto LABEL_80;
          }
LABEL_55:
          LOBYTE(v6) = 1;
          goto LABEL_81;
        }
        v32 = _mm_cvtsi32_si128(v8);
        v33 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v32, v32), 0), 0);
        v34 = _mm_cvtsi32_si128(v14);
        v35 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v34, v34), 0), 0);
        v79 = v4;
        v80 = v7;
        v81 = v6 + 1;
        v90 = Size - 1;
        v82 = Size - 1;
        v91 = Size + 15;
        if ( Size + 63 >= v7 )
        {
          LODWORD(v6) = 0;
          v36 = 0LL;
        }
        else
        {
          LODWORD(v6) = 0;
          v36 = 0LL;
          do
          {
            if ( (v6 & 1) != 0 )
              break;
            v37 = _mm_loadu_si128(&v4[v36 + 16]);
            v38 = _mm_loadu_si128(&v4[v36 + 32]);
            v39 = _mm_loadu_si128(&v4[v36 + 48]);
            v40 = _mm_loadu_si128(&v12[Size + 16 + v36]);
            v41 = _mm_loadu_si128(&v12[Size + 32 + v36]);
            v42 = _mm_loadu_si128(&v12[Size + 48 + v36]);
            v43 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_loadu_si128(&v12[Size + v36]), v35),
                      _mm_cmpeq_epi8(_mm_loadu_si128(&v4[v36]), v33)));
            if ( v43 )
            {
              LOBYTE(v48) = sub_7FF7053FD420(&v79, v36, v43, 0);
              v15 = v91;
              LODWORD(v6) = v48;
            }
            v44 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v40, v35), _mm_cmpeq_epi8(v37, v33)));
            if ( v44 )
            {
              v49 = sub_7FF7053FD420(&v79, v36 | 0x10, v44, v6);
              v15 = v91;
              LOBYTE(v50) = (v6 | v49) & 1;
              LODWORD(v6) = v50;
            }
            v45 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v41, v35), _mm_cmpeq_epi8(v38, v33)));
            if ( v45 )
            {
              v51 = sub_7FF7053FD420(&v79, v36 | 0x20, v45, v6);
              v15 = v91;
              LOBYTE(v52) = (v6 | v51) & 1;
              LODWORD(v6) = v52;
            }
            v46 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v42, v35), _mm_cmpeq_epi8(v39, v33)));
            if ( v46 )
            {
              v53 = sub_7FF7053FD420(&v79, v36 | 0x30, v46, v6);
              v15 = v91;
              LOBYTE(v54) = (v6 | v53) & 1;
              LODWORD(v6) = v54;
            }
            v47 = v36 + Size + 63 + 64;
            v36 += 64LL;
          }
          while ( v47 < v7 );
        }
        if ( v36 + v15 < v7 )
        {
          v55 = &v4[v36];
          v56 = &v79;
          do
          {
            if ( (v6 & 1) != 0 )
              break;
            v57 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_loadu_si128(&v12[Size + v36]), v35),
                      _mm_cmpeq_epi8(_mm_loadu_si128(v55), v33)));
            if ( v57 )
            {
              v6 = v56;
              LOBYTE(v59) = sub_7FF7053FD420(v56, v36, v57, 0);
              v56 = v6;
              v15 = v91;
              LODWORD(v6) = v59;
            }
            v58 = v15 + v36 + 16;
            v36 += 16LL;
            ++v55;
          }
          while ( v58 < v7 );
        }
        v60 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_loadu_si128(&v12[v7 - 15]), v35),
                  _mm_cmpeq_epi8(_mm_loadu_si128(&v4[v7 - v90 - 16]), v33)));
        if ( v60 )
        {
          LOBYTE(v61) = (v6 | sub_7FF7053FD420(&v79, v7 - v90 - 16, v60, v6)) & 1;
          LODWORD(v6) = v61;
        }
        goto LABEL_81;
      }
    }
    sub_7FF7053FB220(&v79, v4, v7, v6, Size);
    if ( v79 != 1 )
    {
      if ( BYTE2(v82) )
        goto LABEL_80;
      v25 = v80;
      LODWORD(v6) = v82;
      while ( 1 )
      {
        if ( v25 )
        {
          if ( v25 >= v87 )
          {
            if ( v25 != v87 )
LABEL_107:
              sub_7FF7053FE500(v86, v87, v25, v87, &off_7FF705400FE0);
          }
          else if ( v86[v25] < -64 )
          {
            goto LABEL_107;
          }
        }
        if ( v25 == v87 )
          break;
        v26 = v86[v25];
        v27 = v26;
        if ( v26 < 0 )
        {
          v29 = v26 & 0x1F;
          v30 = v86[v25 + 1] & 0x3F;
          if ( v26 <= 0xDFu )
          {
            v27 = v30 | (v29 << 6);
            if ( (v6 & 1) != 0 )
              goto LABEL_55;
          }
          else
          {
            v31 = (v30 << 6) | v86[v25 + 2] & 0x3F;
            if ( v26 < 0xF0u )
            {
              v27 = (v29 << 12) | v31;
              if ( (v6 & 1) != 0 )
                goto LABEL_55;
            }
            else
            {
              v27 = ((v26 & 7) << 18) | (v31 << 6) | v86[v25 + 3] & 0x3F;
              if ( (v6 & 1) != 0 )
                goto LABEL_55;
            }
          }
        }
        else if ( (v6 & 1) != 0 )
        {
          goto LABEL_55;
        }
        v28 = 1LL;
        if ( v27 >= 0x80 )
        {
          v28 = 2LL;
          if ( v27 >= 0x800 )
            v28 = 4LL - (v27 < 0x10000);
        }
        LOBYTE(v6) = v6 ^ 1;
        v25 += v28;
      }
      LOBYTE(v6) = v6 & 1;
      goto LABEL_81;
    }
    v16 = v85;
    v17 = v89 - 1;
    if ( v85 != -1LL )
    {
      v18 = v84;
      v19 = v84 + v17;
      if ( v84 + v17 >= v87 )
        goto LABEL_80;
      v20 = v83;
      v91 = v82;
      v90 = v89 - v82;
      while ( !_bittest64(&v20, v86[v19]) )
      {
        v18 += v89;
LABEL_25:
        v16 = 0LL;
LABEL_26:
        v19 = v18 + v17;
        LODWORD(v6) = 0;
        if ( v18 + v17 >= v87 )
          goto LABEL_81;
      }
      v21 = v80;
      if ( v16 > v80 )
        v21 = v16;
      v6 = v21;
      while ( v6 < v89 )
      {
        if ( v18 + v6 >= v87 )
        {
          v77 = v21 + v18;
          if ( v87 > v77 )
            v77 = v87;
          sub_7FF7053FE234(v77, v87, &off_7FF705400BF0);
        }
        v22 = v6 + 1;
        v23 = *(v88 + v6) == v86[v18 + v6];
        ++v6;
        if ( !v23 )
        {
          v18 = v22 + v18 - v80;
          goto LABEL_25;
        }
      }
      v24 = v80;
      while ( v16 < v24 )
      {
        if ( --v24 >= v89 )
          sub_7FF7053FE234(v24, v89, &off_7FF705400BC0);
        if ( v24 + v18 >= v87 )
          sub_7FF7053FE234(v24 + v18, v87, &off_7FF705400BD8);
        LODWORD(v6) = *(v88 + v24);
        if ( v6 != v86[v24 + v18] )
        {
          v18 += v91;
          v16 = v90;
          goto LABEL_26;
        }
      }
      goto LABEL_55;
    }
    v62 = v84;
    v63 = v84 + v17;
    if ( v84 + v17 < v87 )
    {
      v91 = v83;
      v64 = v80 - 1;
      v90 = 1 - v80;
      while ( 1 )
      {
        v68 = v86[v63];
        v69 = v91;
        if ( _bittest64(&v69, v68) )
          break;
        v66 = v89 + v62;
LABEL_83:
        v67 = v66;
LABEL_84:
        v63 = v67 + v17;
        LODWORD(v6) = 0;
        v62 = v67;
        if ( v67 + v17 >= v87 )
          goto LABEL_81;
      }
      v70 = 0LL;
      v71 = (v80 + v88);
      v72 = v62;
      while ( v80 + v70 < v89 )
      {
        if ( v80 + v72 >= v87 )
        {
          v78 = v80 + v62;
          if ( v87 > v78 )
            v78 = v87;
          sub_7FF7053FE234(v78, v87, &off_7FF705400BF0);
        }
        v73 = *v71;
        v67 = v72 + 1;
        ++v71;
        ++v70;
        v23 = v73 == v86[v80 + v72++];
        if ( !v23 )
          goto LABEL_84;
      }
      v74 = v64 + v62;
      v6 = v88 + v80 - 1;
      v75 = v90;
      while ( v75 != 1 )
      {
        if ( v64 >= v89 )
          sub_7FF7053FE234(-v75, v89, &off_7FF705400BC0);
        if ( v74 >= v87 )
          sub_7FF7053FE234(v74, v87, &off_7FF705400BD8);
        v76 = *v6;
        ++v75;
        --v6;
        v23 = v76 == v86[v74--];
        if ( !v23 )
        {
          v66 = v82 + v62;
          goto LABEL_83;
        }
      }
      goto LABEL_55;
    }
    goto LABEL_80;
  }
  if ( Size != a4 )
  {
LABEL_80:
    LODWORD(v6) = 0;
    goto LABEL_81;
  }
  LOBYTE(v6) = memcmp(Buf1, Buf2, Size) == 0;
LABEL_81:
  LOBYTE(v6) = v6 & 1;
  return v6;
}
// 7FF7053E72B4: variable 'v48' is possibly undefined
// 7FF7053E72D4: variable 'v50' is possibly undefined
// 7FF7053E72F7: variable 'v52' is possibly undefined
// 7FF7053E731A: variable 'v54' is possibly undefined
// 7FF7053E7397: variable 'v59' is possibly undefined
// 7FF7053E73DA: variable 'v61' is possibly undefined
// 7FF705400BA8: using guessed type char *off_7FF705400BA8;
// 7FF705400BC0: using guessed type char *off_7FF705400BC0;
// 7FF705400BD8: using guessed type char *off_7FF705400BD8;
// 7FF705400BF0: using guessed type char *off_7FF705400BF0;
// 7FF705400FE0: using guessed type char *off_7FF705400FE0;

//----- (00007FF7053E75C0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E75C0(unsigned __int64 *a1, unsigned int a2)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r8
  unsigned __int64 *v6; // rbx
  unsigned int v7; // r14d

  v2 = a1[2];
  v3 = 1LL;
  if ( a2 >= 0x80 )
  {
    v3 = 2LL;
    if ( a2 >= 0x800 )
      v3 = 4LL - (a2 < 0x10000);
  }
  v4 = a1[2];
  if ( v3 > *a1 - v2 )
  {
    v6 = a1;
    v7 = a2;
    sub_7FF7053FD5A0(a1, v2, v3, 1LL, 1LL);
    a2 = v7;
    a1 = v6;
    v4 = v6[2];
    v5 = v6[1];
    if ( v7 < 0x80 )
      goto LABEL_6;
  }
  else
  {
    v5 = a1[1];
    if ( a2 < 0x80 )
    {
LABEL_6:
      *(v5 + v4) = a2;
      goto LABEL_13;
    }
  }
  if ( a2 >= 0x800 )
  {
    if ( a2 >= 0x10000 )
    {
      *(v5 + v4) = (a2 >> 18) | 0xF0;
      *(v5 + v4 + 1) = (a2 >> 12) & 0x3F | 0x80;
      *(v5 + v4 + 2) = (a2 >> 6) & 0x3F | 0x80;
      *(v5 + v4 + 3) = a2 & 0x3F | 0x80;
    }
    else
    {
      *(v5 + v4) = (a2 >> 12) | 0xE0;
      *(v5 + v4 + 1) = (a2 >> 6) & 0x3F | 0x80;
      *(v5 + v4 + 2) = a2 & 0x3F | 0x80;
    }
  }
  else
  {
    *(v5 + v4) = (a2 >> 6) | 0xC0;
    *(v5 + v4 + 1) = a2 & 0x3F | 0x80;
  }
LABEL_13:
  a1[2] = v2 + v3;
  return 0LL;
}

//----- (00007FF7053E7710) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E7710(unsigned __int64 *a1, const void *a2, size_t a3)
{
  __int64 v5; // rbx
  const void *v7; // r14

  v5 = a1[2];
  if ( a3 > *a1 - v5 )
  {
    v7 = a2;
    sub_7FF7053FD5A0(a1, v5, a3, 1LL, 1LL);
    a2 = v7;
    v5 = a1[2];
  }
  memcpy((v5 + a1[1]), a2, a3);
  a1[2] = a3 + v5;
  return 0LL;
}

//----- (00007FF7053E7780) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053E7780(unsigned __int64 *a1, char **a2)
{
  unsigned int v4; // r12d
  char *v5; // r13
  unsigned __int8 *v6; // r14
  __int16 v7; // r15
  __int64 v8; // rbx
  unsigned __int8 *v9; // rax
  char v10; // dl
  int v11; // ecx
  int v12; // r8d
  int v13; // r12d
  unsigned int v14; // ecx
  __int16 v15; // r12
  unsigned __int64 v16; // r8

  LOWORD(v4) = *(a2 + 8);
  v5 = *a2;
  v6 = a2[1];
  while ( 1 )
  {
    if ( v4 )
    {
      *(a2 + 8) = 0;
      v7 = 0;
      goto LABEL_4;
    }
    if ( v5 == v6 )
      break;
    v9 = (v5 + 1);
    *a2 = v5 + 1;
    v10 = *v5;
    LOWORD(v4) = *v5;
    if ( *v5 >= 0 )
      goto LABEL_3;
    v11 = v4 & 0x1F;
    v9 = (v5 + 2);
    *a2 = v5 + 2;
    v12 = v5[1] & 0x3F;
    if ( v4 <= 0xDFu )
    {
      LOWORD(v4) = v12 | (v11 << 6);
LABEL_3:
      v7 = 0;
      v5 = v9;
      goto LABEL_4;
    }
    v9 = (v5 + 3);
    *a2 = v5 + 3;
    v13 = (v12 << 6) | v5[2] & 0x3F;
    if ( v10 < 0xF0u )
    {
      v4 = (v11 << 12) | v13;
      if ( v4 <= 0xFFFF )
        goto LABEL_3;
    }
    else
    {
      v9 = (v5 + 4);
      *a2 = v5 + 4;
      v4 = ((v11 & 7) << 18) | (v13 << 6) | v5[3] & 0x3F;
      if ( v4 <= 0xFFFF )
        goto LABEL_3;
    }
    v14 = ((v4 + 16711680) >> 10) | 0xD800;
    v15 = v4 & 0x3FF | 0xDC00;
    *(a2 + 8) = v15;
    v5 = v9;
    v7 = v15;
    LOWORD(v4) = v14;
LABEL_4:
    v8 = a1[2];
    if ( v8 == *a1 )
    {
      v16 = v6 - v5 + 3;
      if ( (v6 - v5) >= 0xFFFFFFFFFFFFFFFDuLL )
        v16 = -1LL;
      sub_7FF7053FD5A0(a1, v8, (v16 >> 2) - (v7 == 0) + 2, 2LL, 2LL);
    }
    *(a1[1] + 2 * v8) = v4;
    a1[2] = v8 + 1;
    LOWORD(v4) = v7;
  }
}

//----- (00007FF7053E7920) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E7920(__int64 *a1)
{
  __int64 v1; // rsi
  _BYTE *v2; // rcx
  __int64 v3; // rdx
  __int64 result; // rax

  v1 = *a1;
  v2 = *(*a1 + 24);
  if ( v2 )
  {
    v3 = *(v1 + 32);
    *v2 = 0;
    if ( v3 )
      result = sub_7FF7053E5E40(v2, v3, 1LL);
  }
  if ( v1 != -1 && !_InterlockedDecrement64((v1 + 8)) )
    return sub_7FF7053E5E40(v1, 48LL, 8LL);
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E7980) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E7980(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdx
  __int64 result; // rax

  v1 = *a1;
  v2 = *(*a1 + 24);
  if ( v2 )
    result = sub_7FF7053E5E40(*(v1 + 32), v2, 1LL);
  if ( v1 != -1 && !_InterlockedDecrement64((v1 + 8)) )
    return sub_7FF7053E5E40(v1, 48LL, 8LL);
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053E79E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E79E0(__int64 *a1, __int64 a2)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rax
  __int64 result; // rax
  _QWORD v11[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v12; // [rsp+40h] [rbp-10h] BYREF
  __int64 v13; // [rsp+48h] [rbp-8h]
  __int64 v14; // [rsp+50h] [rbp+0h]

  v3 = *a1;
  v4 = 2 * *a1;
  v5 = 4LL;
  if ( v4 >= 5 )
    v5 = v4;
  v7 = 0LL;
  v8 = v3 >> 58;
  if ( v3 >> 58 )
    sub_7FF7053FDFF0(0LL, v8, a2);
  if ( (32 * v5) > 0x7FFFFFFFFFFFFFF8LL )
LABEL_12:
    sub_7FF7053FDFF0(v7, v8, a2);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 32 * v3;
    v9 = 8LL;
  }
  else
  {
    v9 = 0LL;
  }
  v11[1] = v9;
  sub_7FF7053FD530(&v12, 8LL, 32 * v5, v11);
  if ( v12 == 1 )
  {
    v7 = v13;
    v8 = v14;
    goto LABEL_12;
  }
  result = v13;
  a1[1] = v13;
  *a1 = v5;
  return result;
}

//----- (00007FF7053E7A90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E7A90(__int64 *a1, __int64 a2)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rax
  __int64 result; // rax
  _QWORD v11[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v12; // [rsp+40h] [rbp-10h] BYREF
  __int64 v13; // [rsp+48h] [rbp-8h]
  __int64 v14; // [rsp+50h] [rbp+0h]

  v3 = *a1;
  v4 = 2 * *a1;
  v5 = 4LL;
  if ( v4 >= 5 )
    v5 = v4;
  v7 = 0LL;
  v8 = v3 >> 59;
  if ( v3 >> 59 )
    sub_7FF7053FDFF0(0LL, v8, a2);
  if ( (16 * v5) > 0x7FFFFFFFFFFFFFF8LL )
LABEL_12:
    sub_7FF7053FDFF0(v7, v8, a2);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 16 * v3;
    v9 = 8LL;
  }
  else
  {
    v9 = 0LL;
  }
  v11[1] = v9;
  sub_7FF7053FD530(&v12, 8LL, 16 * v5, v11);
  if ( v12 == 1 )
  {
    v7 = v13;
    v8 = v14;
    goto LABEL_12;
  }
  result = v13;
  a1[1] = v13;
  *a1 = v5;
  return result;
}

//----- (00007FF7053E7B40) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E7B40(__int64 *a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v4; // r9
  unsigned __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 result; // rax
  _QWORD v10[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v11; // [rsp+40h] [rbp-10h] BYREF
  __int64 v12; // [rsp+48h] [rbp-8h]
  __int64 v13; // [rsp+50h] [rbp+0h]

  v2 = a2;
  v4 = *a1;
  v5 = 2 * *a1;
  v6 = 4LL;
  if ( v5 >= 5 )
    v6 = 2 * *a1;
  v7 = 0LL;
  if ( v6 < 0 )
    sub_7FF7053FDFF0(0LL, a2, a2);
  if ( (2 * v6) > 0x7FFFFFFFFFFFFFFELL )
LABEL_12:
    sub_7FF7053FDFF0(v7, a2, v2);
  if ( v4 )
  {
    v10[0] = a1[1];
    v10[2] = v5;
    v8 = 2LL;
  }
  else
  {
    v8 = 0LL;
  }
  v10[1] = v8;
  sub_7FF7053FD530(&v11, 2LL, 2 * v6, v10);
  if ( v11 == 1 )
  {
    v7 = v12;
    a2 = v13;
    goto LABEL_12;
  }
  result = v12;
  a1[1] = v12;
  *a1 = v6;
  return result;
}

//----- (00007FF7053E7BF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E7BF0(__int64 a1, __int64 *a2)
{
  return sub_7FF7053FA4C0(*(a1 + 8), *(a1 + 16), a2);
}

//----- (00007FF7053E7C10) ----------------------------------------------------
char __fastcall sub_7FF7053E7C10(__int64 a1, char *a2)
{
  __int64 v3; // [rsp+58h] [rbp-8h] BYREF

  v3 = a1 + 8;
  return sub_7FF7053F9E90(
           a2,
           aUtf8error,
           9LL,
           aValidUpToerror,
           0xBuLL,
           a1,
           &unk_7FF705400DF8,
           &aValidUpToerror[11],
           9uLL,
           &v3,
           &unk_7FF705400E18);
}

//----- (00007FF7053E7C90) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E7C90(__int64 a1, char *a2)
{
  __int64 v3; // [rsp+28h] [rbp-8h] BYREF

  v3 = a1;
  return sub_7FF7053F9F80(a2, aTryfrominterro, 15LL, &v3, &unk_7FF705400E60);
}

//----- (00007FF7053E7CD0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __noreturn sub_7FF7053E7CD0()
{
  _QWORD v0[3]; // [rsp+20h] [rbp-40h] BYREF
  __int128 v1; // [rsp+38h] [rbp-28h]
  __int64 v2; // [rsp+50h] [rbp-10h] BYREF
  int v3; // [rsp+58h] [rbp-8h] BYREF
  char v4; // [rsp+5Ch] [rbp-4h]

  v3 = 0;
  v4 = 0;
  v0[0] = &off_7FF705401038;
  v0[1] = 1LL;
  v0[2] = 8LL;
  v1 = 0LL;
  v2 = sub_7FF7053EB620(&v3, v0);
  sub_7FF7053E6BF0(&v2);
  __fastfail(7u);
}
// 7FF705401038: using guessed type char *off_7FF705401038;

//----- (00007FF7053E7D30) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void sub_7FF7053E7D30()
{
  char *v0; // [rsp+30h] [rbp-10h] BYREF
  char v1; // [rsp+3Fh] [rbp-1h] BYREF

  if ( dword_7FF70540B144 != 3 )
  {
    v1 = 1;
    v0 = &v1;
    sub_7FF7053FD950(&dword_7FF70540B144, 0, &v0, &unk_7FF7054019E0, &off_7FF705401060);
  }
}
// 7FF705401060: using guessed type char *off_7FF705401060;
// 7FF70540B144: using guessed type int dword_7FF70540B144;

//----- (00007FF7053E7D90) ----------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E7D90(__int64 a1, __int64 a2)
{
  HANDLE CurrentThread; // rax
  __int64 v5; // rax
  __int64 v6; // rdx
  __int64 *v7; // rcx
  signed __int64 v8; // rax
  signed __int64 v9; // rtt
  bool v10; // zf
  __int64 v11; // rdx
  __int64 result; // rax
  __int64 v13; // rsi
  __int64 v14; // rdx
  __int64 v15; // rdx
  ULONG StackSizeInBytes[2]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v17; // [rsp+38h] [rbp-48h]
  __int64 v18; // [rsp+40h] [rbp-40h]
  __int128 v19; // [rsp+48h] [rbp-38h]
  __int64 v20; // [rsp+60h] [rbp-20h] BYREF
  int v21; // [rsp+68h] [rbp-18h] BYREF
  char v22; // [rsp+6Ch] [rbp-14h]
  __int64 v23; // [rsp+70h] [rbp-10h]
  __int64 v24; // [rsp+78h] [rbp-8h]
  __int64 v25; // [rsp+80h] [rbp+0h]
  __int64 v26; // [rsp+90h] [rbp+10h] BYREF
  __int64 v27; // [rsp+98h] [rbp+18h] BYREF

  v25 = -2LL;
  AddVectoredExceptionHandler(0, Handler);
  StackSizeInBytes[0] = 20480;
  SetThreadStackGuarantee(StackSizeInBytes);
  CurrentThread = GetCurrentThread();
  off_7FF70540B028(CurrentThread, L"main");
  v5 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  v6 = *(v5 + 8);
  if ( !v6 )
  {
    v7 = (v5 + 8);
    v8 = qword_7FF70540B1F8;
    do
    {
      if ( v8 == -1 )
        sub_7FF7053FD680();
      v6 = v8 + 1;
      v9 = v8;
      v8 = _InterlockedCompareExchange64(&qword_7FF70540B1F8, v8 + 1, v8);
    }
    while ( v9 != v8 );
    *v7 = v6;
  }
  qword_7FF70540B200 = v6;
  try
  {
    result = (*(a2 + 40))(a1);
    v10 = dword_7FF70540B144 == 3;
  }
  catch ( __int64 v26 )
  {
    v23 = sub_7FF7053FD83F(v26);
    v24 = v14;
    goto LABEL_10;
  }
  catch ( ... )
  {
    v23 = sub_7FF7053FD83F(0LL);
    v24 = v15;
LABEL_10:
    if ( *v24 )
    {
      try
      {
        (*v24)(v23);
      }
      catch ( __int64 v27 )
      {
        sub_7FF7053FD83F(v27);
        goto LABEL_15;
      }
      catch ( ... )
      {
        sub_7FF7053FD83F(0LL);
LABEL_15:
        v21 = 0;
        v22 = 0;
        *StackSizeInBytes = &off_7FF7054010C0;
        v17 = 1LL;
        v18 = 8LL;
        v19 = 0LL;
        v20 = sub_7FF7053EB620(&v21, StackSizeInBytes);
        sub_7FF7053E6BF0(&v20);
        __fastfail(7u);
      }
    }
    v11 = *(v24 + 8);
    if ( v11 )
      sub_7FF7053E5E40(v23, v11, *(v24 + 16));
    result = 101LL;
    if ( dword_7FF70540B144 != 3 )
      goto LABEL_14;
    return result;
  }
  if ( !v10 )
  {
LABEL_14:
    v13 = result;
    LOBYTE(v20) = 1;
    *StackSizeInBytes = &v20;
    sub_7FF7053FD950(&dword_7FF70540B144, 0, StackSizeInBytes, &unk_7FF7054019E0, &off_7FF705401060);
    return v13;
  }
  return result;
}
// 7FF70540B028: invalid function type '?' has been ignored
// 7FF7053E7F15: bad sp value at call
// 7FF7053E7F22: bad sp value at call
// 7FF7053E7F60: variable 'v14' is possibly undefined
// 7FF7053E7F9E: variable 'v15' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF7053FD83F: using guessed type __int64 __fastcall sub_7FF7053FD83F(_QWORD);
// 7FF705401060: using guessed type char *off_7FF705401060;
// 7FF7054010C0: using guessed type char *off_7FF7054010C0;
// 7FF7054025D0: using guessed type wchar_t aMain[5];
// 7FF70540B000: using guessed type TypeDescriptor stru_7FF70540B000[1];
// 7FF70540B028: using guessed type __int64 (__fastcall *off_7FF70540B028)(_QWORD, _QWORD);
// 7FF70540B144: using guessed type int dword_7FF70540B144;
// 7FF70540B1F8: using guessed type __int64 qword_7FF70540B1F8;
// 7FF70540B200: using guessed type __int64 qword_7FF70540B200;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053E80C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E80C0(__int64 a1)
{
  unsigned __int64 v1; // r8
  unsigned __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rbx
  unsigned __int64 v5; // r14
  WCHAR *p_Buffer; // r15
  unsigned __int64 i; // r12
  unsigned __int64 v8; // r8
  DWORD CurrentDirectoryW; // eax
  bool v10; // cc
  unsigned __int64 v11; // r12
  __int128 v12; // xmm0
  _QWORD *v13; // rsi
  unsigned __int64 v14; // rdx
  __int64 v16; // rax
  WCHAR Buffer; // [rsp+28h] [rbp-58h] BYREF
  _OWORD v18[2]; // [rsp+428h] [rbp+3A8h] BYREF
  __int64 v19; // [rsp+448h] [rbp+3C8h]
  __int64 v20; // [rsp+450h] [rbp+3D0h]
  unsigned __int64 v21; // [rsp+458h] [rbp+3D8h] BYREF
  __int64 v22; // [rsp+460h] [rbp+3E0h]
  __int64 v23; // [rsp+468h] [rbp+3E8h]
  __int64 v24; // [rsp+470h] [rbp+3F0h]

  v24 = -2LL;
  v20 = a1;
  v21 = 0LL;
  v22 = 2LL;
  v23 = 0LL;
  v1 = 512LL;
  v19 = 2LL;
  v2 = 0LL;
  v3 = 0LL;
  v4 = 0LL;
LABEL_4:
  while ( 2 )
  {
    v5 = 512LL;
    p_Buffer = &Buffer;
    for ( i = v1; ; i = v4 )
    {
      SetLastError(0);
      CurrentDirectoryW = GetCurrentDirectoryW(i, p_Buffer);
      if ( !CurrentDirectoryW )
        break;
      v1 = CurrentDirectoryW;
      v10 = CurrentDirectoryW <= i;
      if ( CurrentDirectoryW != i )
        goto LABEL_2;
LABEL_15:
      if ( GetLastError() != 122 )
        sub_7FF7053FE1B0(
          "internal error: entered unreachable code/rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\\library\\alloc\\src\\vec\\mod.rs",
          40LL,
          &off_7FF705402698);
      v11 = 2 * i;
      if ( v11 >= 0xFFFFFFFF )
        v11 = 0xFFFFFFFFLL;
      v1 = v11;
      if ( v11 < 0x201 )
        goto LABEL_4;
LABEL_5:
      v8 = v1 - v4;
      if ( v8 > v3 - v4 )
      {
        sub_7FF7053FD5A0(&v21, v4, v8, 2LL, 2LL);
        v2 = v21;
        v19 = v22;
      }
      v4 = 0xFFFFFFFFLL;
      if ( v2 < 0xFFFFFFFF )
        v4 = v2;
      v23 = v4;
      v3 = v2;
      v5 = v4;
      p_Buffer = v19;
    }
    if ( GetLastError() )
    {
      LODWORD(v16) = GetLastError();
      v13 = v20;
      *(v20 + 8) = (v16 << 32) | 2;
      *v13 = 0x8000000000000000uLL;
      v14 = v21;
      if ( !v21 )
        return v13;
LABEL_22:
      sub_7FF7053E5E40(v22, 2 * v14, 2LL);
      return v13;
    }
    v1 = 0LL;
    v10 = 1;
    if ( !i )
      goto LABEL_15;
LABEL_2:
    if ( !v10 )
    {
      if ( v1 < 0x201 )
        continue;
      goto LABEL_5;
    }
    break;
  }
  if ( v1 > v5 )
    sub_7FF7053FE4E0(v1, v5, &off_7FF705402680);
  sub_7FF7053EB920(v18, p_Buffer, v1);
  v12 = v18[0];
  v13 = v20;
  *(v20 + 16) = v18[1];
  *v13 = v12;
  v14 = v21;
  if ( v21 )
    goto LABEL_22;
  return v13;
}
// 7FF7053E82B2: variable 'v16' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705402680: using guessed type char *off_7FF705402680;
// 7FF705402698: using guessed type char *off_7FF705402698;

//----- (00007FF7053E8370) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E8370(__int64 a1, char *a2, __int64 a3)
{
  __int64 v4; // rdx
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rsi
  __int64 v8; // r14
  unsigned __int64 v9; // r15
  WCHAR *v10; // r12
  unsigned __int64 i; // r13
  unsigned __int64 v12; // r8
  DWORD EnvironmentVariableW; // eax
  bool v14; // cc
  unsigned __int64 v15; // r13
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rsi
  unsigned __int64 v18; // rdx
  __int64 v19; // rdx
  __int64 v21; // rdx
  WCHAR Buffer[4]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v23; // [rsp+38h] [rbp-48h]
  _OWORD v24[2]; // [rsp+430h] [rbp+3B0h] BYREF
  __int128 v25; // [rsp+450h] [rbp+3D0h]
  unsigned __int64 v26; // [rsp+460h] [rbp+3E0h]
  unsigned __int64 v27; // [rsp+468h] [rbp+3E8h] BYREF
  __int64 v28; // [rsp+470h] [rbp+3F0h]
  __int64 v29; // [rsp+478h] [rbp+3F8h]
  __int64 v30; // [rsp+480h] [rbp+400h]
  LPCWSTR lpName; // [rsp+488h] [rbp+408h]
  __int64 v32; // [rsp+490h] [rbp+410h]
  __int64 v33; // [rsp+498h] [rbp+418h]
  __int64 v34; // [rsp+4A0h] [rbp+420h]

  v34 = -2LL;
  sub_7FF7053F0910(Buffer, a2, a3);
  if ( __OFSUB__(-*Buffer, 1LL) )
  {
    if ( (v23 & 3) == 1 )
    {
      v30 = v23 - 1;
      lpName = *(v23 - 1);
      v33 = *(v23 + 7);
      if ( *v33 )
        (*v33)(lpName);
      v4 = *(v33 + 8);
      if ( v4 )
        sub_7FF7053E5E40(lpName, v4, *(v33 + 16));
      sub_7FF7053E5E40(v30, 24LL, 8LL);
    }
    *a1 = 0x8000000000000000uLL;
    return a1;
  }
  v32 = a1;
  v30 = *Buffer;
  lpName = v23;
  v27 = 0LL;
  v28 = 2LL;
  v29 = 0LL;
  v5 = 512LL;
  v33 = 2LL;
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
LABEL_12:
  v9 = 512LL;
  v10 = Buffer;
  for ( i = v5; ; i = v8 )
  {
    SetLastError(0);
    EnvironmentVariableW = GetEnvironmentVariableW(lpName, v10, i);
    if ( EnvironmentVariableW )
    {
      v5 = EnvironmentVariableW;
      v14 = EnvironmentVariableW <= i;
      if ( EnvironmentVariableW != i )
        goto LABEL_10;
      goto LABEL_23;
    }
    if ( GetLastError() )
      break;
    v5 = 0LL;
    v14 = 1;
    if ( i )
    {
LABEL_10:
      if ( !v14 )
      {
        if ( v5 < 0x201 )
          goto LABEL_12;
        goto LABEL_13;
      }
      if ( v5 > v9 )
        sub_7FF7053FE4E0(v5, v9, &off_7FF705402680);
      sub_7FF7053EB920(v24, v10, v5);
      v16 = *(&v24[0] + 1);
      v17 = *&v24[0];
      v25 = v24[1];
      v18 = v27;
      a1 = v32;
      if ( v27 )
      {
LABEL_34:
        sub_7FF7053E5E40(v28, 2 * v18, 2LL);
        if ( __OFSUB__(-v17, 1LL) )
          goto LABEL_38;
      }
      else if ( __OFSUB__(-*&v24[0], 1LL) )
      {
        goto LABEL_38;
      }
      *(a1 + 16) = v25;
      *a1 = v17;
      *(a1 + 8) = v16;
      v19 = v30;
      if ( !v30 )
        return a1;
LABEL_40:
      sub_7FF7053E5E40(lpName, 2 * v19, 2LL);
      return a1;
    }
LABEL_23:
    if ( GetLastError() != 122 )
      sub_7FF7053FE1B0(
        "internal error: entered unreachable code/rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\\library\\alloc\\src\\vec\\mod.rs",
        40LL,
        &off_7FF705402698);
    v15 = 2 * i;
    if ( v15 >= 0xFFFFFFFF )
      v15 = 0xFFFFFFFFLL;
    v5 = v15;
    if ( v15 < 0x201 )
      goto LABEL_12;
LABEL_13:
    v12 = v5 - v8;
    if ( v12 > v7 - v8 )
    {
      sub_7FF7053FD5A0(&v27, v8, v12, 2LL, 2LL);
      v6 = v27;
      v33 = v28;
    }
    v8 = 0xFFFFFFFFLL;
    if ( v6 < 0xFFFFFFFF )
      v8 = v6;
    v29 = v8;
    v7 = v6;
    v9 = v8;
    v10 = v33;
  }
  v16 = (GetLastError() << 32) | 2;
  v18 = v27;
  if ( v27 )
  {
    v17 = 0x8000000000000000uLL;
    a1 = v32;
    goto LABEL_34;
  }
  a1 = v32;
LABEL_38:
  *a1 = 0x8000000000000000uLL;
  if ( (v16 & 3) != 1 )
  {
    v19 = v30;
    if ( !v30 )
      return a1;
    goto LABEL_40;
  }
  v26 = v16 - 1;
  v33 = *(v16 - 1);
  v32 = *(v16 + 7);
  if ( *v32 )
    (*v32)(v33);
  v21 = *(v32 + 8);
  if ( v21 )
    sub_7FF7053E5E40(v33, v21, *(v32 + 16));
  sub_7FF7053E5E40(v26, 24LL, 8LL);
  v19 = v30;
  if ( v30 )
    goto LABEL_40;
  return a1;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705402680: using guessed type char *off_7FF705402680;
// 7FF705402698: using guessed type char *off_7FF705402698;

//----- (00007FF7053E88E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 *__fastcall sub_7FF7053E88E0(__int64 *a1)
{
  sub_7FF7053E8900(a1);
  return a1;
}

//----- (00007FF7053E8900) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 *__fastcall sub_7FF7053E8900(__int64 *a1)
{
  LPWSTR CommandLineW; // rax
  LPWSTR v3; // rdi
  WCHAR v4; // si
  __int64 v5; // rax
  __int64 v6; // rbx
  char v7; // r12
  int v8; // eax
  __int64 v9; // rsi
  _OWORD *v10; // rax
  __int128 v11; // xmm0
  __int64 v12; // rbx
  __int64 v13; // r12
  int v14; // eax
  int v15; // r15d
  int v16; // esi
  unsigned __int16 *v17; // r14
  __int64 v18; // rsi
  __int64 v19; // rax
  __int64 v20; // rcx
  __int128 v21; // xmm0
  int v22; // eax
  WCHAR v23; // ax
  __int64 i; // rsi
  unsigned __int64 v25; // r14
  unsigned __int64 v26; // r13
  __int64 v27; // rax
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rcx
  __int64 v30; // rdx
  __int64 v31; // r8
  __int64 v32; // rsi
  bool v33; // bl
  unsigned __int64 v34; // rcx
  __int64 v35; // rdx
  __int64 v36; // r8
  char v37; // bl
  __int64 v38; // rsi
  __int64 v39; // rdi
  __int64 v40; // rax
  __int128 v41; // xmm0
  __int64 v42; // rsi
  __int64 v43; // rbx
  __int64 v44; // rdx
  __int64 v45; // rsi
  __int64 v46; // rdx
  int v47; // eax
  __int64 v49; // [rsp+30h] [rbp-50h]
  __int64 v50; // [rsp+38h] [rbp-48h] BYREF
  __int64 v51; // [rsp+40h] [rbp-40h]
  __int64 v52; // [rsp+48h] [rbp-38h]
  __int64 v53; // [rsp+50h] [rbp-30h]
  __int128 v54; // [rsp+58h] [rbp-28h] BYREF
  __int128 v55; // [rsp+68h] [rbp-18h]
  __int64 v56; // [rsp+78h] [rbp-8h]
  __int64 v57; // [rsp+80h] [rbp+0h] BYREF
  __int64 v58; // [rsp+88h] [rbp+8h]
  __int64 v59; // [rsp+90h] [rbp+10h]
  __int64 v60; // [rsp+98h] [rbp+18h] BYREF
  __int64 v61; // [rsp+A0h] [rbp+20h]
  __int64 v62; // [rsp+A8h] [rbp+28h]
  __int64 *v63; // [rsp+B0h] [rbp+30h]
  __int64 v64; // [rsp+B8h] [rbp+38h]

  v64 = -2LL;
  CommandLineW = GetCommandLineW();
  v57 = 0LL;
  v58 = 8LL;
  v59 = 0LL;
  if ( !CommandLineW || (v3 = CommandLineW, (v4 = *CommandLineW) == 0) )
  {
    sub_7FF7053F0650(&v54);
    if ( __OFSUB__(-v54, 1LL) )
    {
      v37 = 1;
      if ( (BYTE8(v54) & 3) == 1 )
      {
        v49 = *(&v54 + 1) - 1LL;
        v63 = *(*(&v54 + 1) - 1LL);
        v53 = *(*(&v54 + 1) + 7LL);
        if ( *v53 )
          (*v53)(v63);
        v56 = 1LL;
        v46 = *(v53 + 8);
        if ( v46 )
          sub_7FF7053E5E40(v63, v46, *(v53 + 16));
        sub_7FF7053E5E40(v49, 24LL, 8LL);
      }
      else
      {
        v56 = 1LL;
      }
      v45 = 0LL;
      v63 = 0LL;
    }
    else
    {
      v63 = v54;
      v45 = v55;
      v37 = BYTE8(v55);
      LODWORD(v60) = *(&v55 + 9);
      *(&v60 + 3) = HIDWORD(v55);
      v56 = *(&v54 + 1);
    }
    sub_7FF7053E79E0(&v57, &off_7FF7054027E0);
    v39 = v58;
    *v58 = v63;
    *(v39 + 8) = v56;
    *(v39 + 16) = v45;
    *(v39 + 24) = v37;
    v47 = v60;
    *(v39 + 28) = *(&v60 + 3);
    *(v39 + 25) = v47;
    v42 = 1LL;
    v43 = v57;
    goto LABEL_90;
  }
  v63 = a1;
  v50 = 0LL;
  v51 = 2LL;
  v52 = 0LL;
  v5 = 2LL;
  v6 = 0LL;
  v7 = 0;
  do
  {
    while ( 1 )
    {
      ++v3;
      if ( v4 == 9 || v4 == 32 )
        break;
      if ( v4 != 34 )
        goto LABEL_11;
      v7 ^= 1u;
      v4 = *v3;
      if ( !*v3 )
        goto LABEL_14;
    }
    if ( (v7 & 1) == 0 )
      break;
LABEL_11:
    if ( v6 == v50 )
    {
      sub_7FF7053E7B40(&v50, &off_7FF7054027C8);
      v5 = v51;
    }
    *(v5 + 2 * v6++) = v4;
    v52 = v6;
    v4 = *v3;
  }
  while ( *v3 );
LABEL_14:
  while ( 1 )
  {
    v8 = *v3;
    if ( v8 != 32 && v8 != 9 )
      break;
    ++v3;
  }
  v9 = v51;
  sub_7FF7053EB920(&v54, v51, v6);
  v56 = v9;
  sub_7FF7053E79E0(&v57, &off_7FF705402738);
  v10 = v58;
  v11 = v54;
  *(v58 + 16) = v55;
  *v10 = v11;
  v59 = 1LL;
  v60 = 0LL;
  v61 = 2LL;
  v62 = 0LL;
  v12 = 2LL;
  v13 = 0LL;
  v14 = 0;
  while ( 1 )
  {
    v15 = v14;
    v16 = *v3;
    if ( !*v3 )
      break;
    v17 = v3++;
    if ( v16 > 33 )
    {
      if ( v16 == 34 )
      {
        LOBYTE(v14) = 1;
        if ( (v15 & 1) != 0 )
        {
          if ( *v3 == 34 )
          {
            if ( v13 == v60 )
              sub_7FF7053E7B40(&v60, &off_7FF705402780);
            v12 = v61;
            *(v61 + 2 * v13++) = 34;
            v62 = v13;
            if ( v17[1] )
              v3 = v17 + 2;
            v14 = v15;
          }
          else
          {
            v14 = 0;
            if ( !*v3 )
              break;
          }
        }
      }
      else
      {
        if ( v16 != 92 )
          goto LABEL_41;
        v23 = *v3;
        for ( i = 0LL; v23 == 92; ++i )
        {
          ++v3;
          v23 = v17[i + 2];
        }
        v25 = i + 1;
        if ( v23 != 34 )
        {
          if ( v25 > v60 - v13 )
          {
            sub_7FF7053FD5A0(&v60, v13, i + 1, 2LL, 2LL);
            v12 = v61;
            v13 = v62;
            if ( v25 >= 0x10 )
              goto LABEL_66;
LABEL_50:
            v28 = i + 1;
            do
            {
LABEL_69:
              *(v12 + 2 * v13++) = 92;
              --v28;
            }
            while ( v28 );
          }
          else if ( i != -1 )
          {
            if ( v25 < 0x10 )
              goto LABEL_50;
LABEL_66:
            v34 = v25 & 0xFFFFFFFFFFFFFFF0uLL;
            v28 = v25 & 0xF;
            v35 = v12 + 2 * v13 + 16;
            v13 += v25 & 0xFFFFFFFFFFFFFFF0uLL;
            v36 = 0LL;
            do
            {
              *(v35 + 2 * v36 - 16) = xmmword_7FF705400B00;
              *(v35 + 2 * v36) = xmmword_7FF705400B00;
              v36 += 16LL;
            }
            while ( v34 != v36 );
            if ( v25 != v34 )
              goto LABEL_69;
          }
LABEL_19:
          v62 = v13;
          v14 = v15;
          continue;
        }
        v26 = v25 >> 1;
        if ( v25 >> 1 > v60 - v13 )
        {
          sub_7FF7053FD5A0(&v60, v13, v25 >> 1, 2LL, 2LL);
          v13 = v62;
          v12 = v61;
          if ( v25 >= 0x20 )
          {
LABEL_57:
            v29 = v26 & 0xFFFFFFFFFFFFFFF0uLL;
            v27 = (v25 >> 1) & 0xF;
            v30 = v12 + 2 * v13 + 16;
            v13 += v26 & 0xFFFFFFFFFFFFFFF0uLL;
            v31 = 0LL;
            do
            {
              *(v30 + 2 * v31 - 16) = xmmword_7FF705400B00;
              *(v30 + 2 * v31) = xmmword_7FF705400B00;
              v31 += 16LL;
            }
            while ( v29 != v31 );
            if ( v26 == v29 )
              goto LABEL_61;
            goto LABEL_60;
          }
LABEL_40:
          v27 = v25 >> 1;
          do
          {
LABEL_60:
            *(v12 + 2 * v13++) = 92;
            --v27;
          }
          while ( v27 );
          goto LABEL_61;
        }
        if ( v25 >= 2 )
        {
          v12 = v61;
          if ( v25 >= 0x20 )
            goto LABEL_57;
          goto LABEL_40;
        }
LABEL_61:
        v62 = v13;
        v14 = v15;
        if ( (i & 1) == 0 )
        {
          v32 = 0LL;
          v33 = *v3 != 0;
          if ( v13 == v60 )
            sub_7FF7053E7B40(&v60, &off_7FF705402768);
          LOBYTE(v32) = v33;
          v3 += v32;
          v12 = v61;
          *(v61 + 2 * v13) = 34;
          goto LABEL_18;
        }
      }
    }
    else
    {
      if ( v16 != 9 && v16 != 32 || (v14 & 1) != 0 )
      {
LABEL_41:
        if ( v13 == v60 )
          sub_7FF7053E7B40(&v60, &off_7FF705402798);
        v12 = v61;
        *(v61 + 2 * v13) = v16;
LABEL_18:
        ++v13;
        goto LABEL_19;
      }
      v12 = v61;
      sub_7FF7053EB920(&v54, v61, v13);
      v18 = v59;
      if ( v59 == v57 )
        sub_7FF7053E79E0(&v57, &off_7FF705402750);
      v19 = v58;
      v20 = 32 * v18;
      v21 = v54;
      *(v58 + v20 + 16) = v55;
      *(v19 + v20) = v21;
      v59 = v18 + 1;
      v62 = 0LL;
      while ( 1 )
      {
        v22 = *v3;
        if ( v22 != 32 && v22 != 9 )
          break;
        ++v3;
      }
      v13 = 0LL;
      v14 = v15;
    }
  }
  if ( v13 || (v15 & 1) != 0 )
  {
    sub_7FF7053EB920(&v54, v61, v13);
    v38 = v59;
    a1 = v63;
    if ( v59 == v57 )
      sub_7FF7053E79E0(&v57, &off_7FF7054027B0);
    v39 = v58;
    v40 = 32 * v38;
    v41 = v54;
    *(v58 + v40 + 16) = v55;
    *(v39 + v40) = v41;
    v42 = v38 + 1;
    v43 = v57;
    v44 = v60;
    if ( v60 )
LABEL_79:
      sub_7FF7053E5E40(v61, 2 * v44, 2LL);
  }
  else
  {
    v39 = v58;
    v42 = v59;
    a1 = v63;
    v43 = v57;
    v44 = v60;
    if ( v60 )
      goto LABEL_79;
  }
  if ( v50 )
    sub_7FF7053E5E40(v56, 2 * v50, 2LL);
LABEL_90:
  *a1 = v39;
  a1[1] = v39;
  a1[2] = v43;
  a1[3] = v39 + 32 * v42;
  return a1;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705400B00: using guessed type __int128 xmmword_7FF705400B00;
// 7FF705402738: using guessed type char *off_7FF705402738;
// 7FF705402750: using guessed type char *off_7FF705402750;
// 7FF705402768: using guessed type char *off_7FF705402768;
// 7FF705402780: using guessed type char *off_7FF705402780;
// 7FF705402798: using guessed type char *off_7FF705402798;
// 7FF7054027B0: using guessed type char *off_7FF7054027B0;
// 7FF7054027C8: using guessed type char *off_7FF7054027C8;
// 7FF7054027E0: using guessed type char *off_7FF7054027E0;

//----- (00007FF7053E9290) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053E9290(_QWORD *a1, __int64 a2)
{
  __int64 *v2; // r10
  __int64 v3; // rax
  char *v4; // r8
  __int64 v5; // rdx
  unsigned __int8 v6; // r9
  unsigned __int64 v7; // r10
  char *v8; // r11
  char *v9; // rdi
  char *v10; // rdi
  char *v11; // rsi
  char v12; // bl
  char *v13; // rdi
  _QWORD v15[8]; // [rsp+30h] [rbp-20h] BYREF

  v15[4] = -2LL;
  v2 = *(a2 + 8);
  if ( v2 == *(a2 + 24) || (*(a2 + 8) = v2 + 4, v3 = *v2, __OFSUB__(-*v2, 1LL)) )
  {
    *a1 = 0x8000000000000000uLL;
  }
  else
  {
    v4 = v2[1];
    v5 = v2[2];
    v6 = *(v2 + 24);
    if ( (v6 & 1) == 0 && v5 )
    {
      v7 = ((*(v2 + 29) | (*(v2 + 31) << 16)) << 32) | *(v2 + 25);
      v8 = &v4[v5];
      v9 = v4;
      do
      {
        v11 = v9 + 1;
        v12 = *v9;
        if ( *v9 < 0 )
        {
          if ( v12 < 0xE0u )
          {
            v10 = v9 + 2;
            if ( v11 != v8 )
              v11 = v10;
          }
          else if ( v12 == -19 )
          {
            if ( v11 == v8 || v9 + 2 == v8 )
              break;
            if ( v9[1] > 0x9Fu )
            {
              v15[0] = v3;
              v15[1] = v4;
              v15[2] = v5;
              v15[3] = v6 | (v7 << 8);
              sub_7FF7053FE440(aCalledResultUn, 43LL, v15, &off_7FF705400C88, &off_7FF7054011B0);
            }
            v11 = v9 + 3;
          }
          else
          {
            v13 = v9 + 2;
            if ( v11 == v8 )
              v13 = v11;
            v11 = &v13[v13 != v8];
            if ( v12 >= 0xF0u )
              v11 += v11 != v8;
          }
        }
        v9 = v11;
      }
      while ( v11 != v8 );
    }
    *a1 = v3;
    a1[1] = v4;
    a1[2] = v5;
  }
  return a1;
}
// 7FF705400C88: using guessed type __int64 (__fastcall *off_7FF705400C88)();
// 7FF7054011B0: using guessed type char *off_7FF7054011B0;

//----- (00007FF7053E9430) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053E9430(__int64 a1)
{
  __int64 v1; // r13
  unsigned __int8 *v2; // rsi
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rdi
  unsigned __int8 v6; // al
  unsigned __int64 v7; // rdx
  bool v8; // cl
  __int64 v9; // rdx
  size_t v10; // rsi
  _QWORD *v13; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v1 = a1;
  v2 = (a1 + 25);
  v3 = 0LL;
  while ( 2 )
  {
    v14 = v3;
    while ( 1 )
    {
      v4 = *(v1 + 16);
      v5 = v4 - v3;
      if ( v4 <= v3 )
      {
        if ( !v3 )
          return 0LL;
        v10 = 0LL;
        v5 = 0LL;
        if ( v4 >= v3 )
          goto LABEL_32;
        goto LABEL_34;
      }
      *(v1 + 24) = 1;
      v6 = sub_7FF7053F1350(0xFFFFFFF5, (v3 + *(v1 + 8)), v5, v2);
      v8 = (v7 & 0xFFFFFFFF00000003uLL) == 0x600000002LL;
      if ( (v6 & v8) == 0 )
        v5 = v7;
      v1 = a1;
      *(a1 + 24) = 0;
      if ( (v6 & v8) != 0 || (v6 & 1) == 0 )
        break;
      switch ( v5 & 3 )
      {
        case 0uLL:
          v3 = v14;
          if ( *(v5 + 16) != 35 )
            goto LABEL_28;
          continue;
        case 1uLL:
          if ( *(v5 + 15) != 35 )
            goto LABEL_27;
          v3 = v14;
          if ( (v5 & 3) == 1 )
          {
            v13 = *(v5 + 7);
            if ( *v13 )
              JUMPOUT(0x7FF7053E9537LL);
            v9 = v13[1];
            if ( v9 )
              sub_7FF7053E5E40(*(v5 - 1), v9, v13[2]);
            sub_7FF7053E5E40(v5 - 1, 24LL, 8LL);
            v1 = a1;
            v3 = v14;
          }
          break;
        case 2uLL:
          goto LABEL_27;
        case 3uLL:
          v3 = v14;
          if ( HIDWORD(v5) != 35 )
            goto LABEL_28;
          continue;
      }
    }
    if ( v5 )
    {
      v3 = v5 + v14;
      continue;
    }
    break;
  }
  v5 = &off_7FF705401258;
LABEL_27:
  v3 = v14;
LABEL_28:
  if ( !v3 )
    return v5;
  v4 = *(a1 + 16);
  v10 = v4 - v3;
  if ( v4 < v3 )
LABEL_34:
    sub_7FF7053FE4E0(v3, v4, &off_7FF705400D40);
  *(a1 + 16) = 0LL;
  if ( v10 )
  {
    memmove(*(a1 + 8), (*(a1 + 8) + v3), v10);
LABEL_32:
    *(v1 + 16) = v10;
  }
  return v5;
}
// 7FF7053E9535: control flows out of bounds to 7FF7053E9537
// 7FF7053E94AF: variable 'v7' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705400D40: using guessed type char *off_7FF705400D40;
// 7FF705401258: using guessed type char *off_7FF705401258;

//----- (00007FF7053E96C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053E96C0(__int64 *a1, __int64 *a2)
{
  __int64 v3; // rdx
  char result; // al
  __int64 v5; // rdx
  char (__fastcall *v6)(__int64, __int64 *); // rax
  void *v7; // [rsp+20h] [rbp-60h] BYREF
  __int64 v8; // [rsp+28h] [rbp-58h]
  __int64 *v9; // [rsp+30h] [rbp-50h]
  __int64 v10; // [rsp+38h] [rbp-48h]
  __int64 v11; // [rsp+40h] [rbp-40h]
  __int64 *v12; // [rsp+50h] [rbp-30h] BYREF
  char (__fastcall *v13)(__int64, __int64 *); // [rsp+58h] [rbp-28h]
  int *v14; // [rsp+60h] [rbp-20h]
  __int64 (__fastcall *v15)(int *, __int64); // [rsp+68h] [rbp-18h]
  __int64 v16[3]; // [rsp+70h] [rbp-10h] BYREF
  int v17; // [rsp+8Ch] [rbp+Ch] BYREF
  __int64 v18; // [rsp+90h] [rbp+10h]

  v18 = -2LL;
  v3 = *a1;
  switch ( *a1 & 3 )
  {
    case 0LL:
      result = sub_7FF7053FA4C0(*v3, *(v3 + 8), a2);
      break;
    case 1LL:
      result = (*(*(v3 + 7) + 32LL))(*(v3 - 1), a2);
      break;
    case 2LL:
      v17 = HIDWORD(*a1);
      sub_7FF7053F0260(v16, HIDWORD(v3));
      v12 = v16;
      v13 = sub_7FF7053E7BF0;
      v14 = &v17;
      v15 = sub_7FF7053FC250;
      v7 = &unk_7FF705401630;
      v8 = 3LL;
      v11 = 0LL;
      v9 = &v12;
      v10 = 2LL;
      JUMPOUT(0x7FF7053E9777LL);
    case 3LL:
      v5 = v3 >> 32;
      v6 = qword_7FF705402E20[v5];
      v12 = (&off_7FF705402F70)[v5];
      v13 = v6;
      v16[0] = &v12;
      v16[1] = sub_7FF7053E5F90;
      v7 = &unk_7FF705401270;
      v8 = 1LL;
      v11 = 0LL;
      v9 = v16;
      v10 = 1LL;
      result = sub_7FF7053F9220(*a2, a2[1], &v7);
      break;
  }
  return result;
}
// 7FF7053E9773: control flows out of bounds to 7FF7053E9777
// 7FF705402E20: using guessed type _QWORD qword_7FF705402E20[42];
// 7FF705402F70: using guessed type char *off_7FF705402F70;

//----- (00007FF7053E9880) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E9880(unsigned __int64 *a1, const void *a2, size_t a3)
{
  __int64 v5; // rbx
  const void *v7; // r14

  v5 = a1[2];
  if ( a3 > *a1 - v5 )
  {
    v7 = a2;
    sub_7FF7053FD5A0(a1, v5, a3, 1LL, 1LL);
    a2 = v7;
    v5 = a1[2];
  }
  memcpy((v5 + a1[1]), a2, a3);
  a1[2] = a3 + v5;
  return 0LL;
}

//----- (00007FF7053E9900) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E9900(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rcx
  unsigned __int64 v10; // rdx
  unsigned int *v11; // r8
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rdx
  __int64 v16; // r15
  __int64 v17; // rsi
  __int64 v18; // r13
  const void *v19; // rdx
  size_t v20; // r12
  const void *v21; // [rsp+30h] [rbp+0h]

  if ( a3 )
  {
    v6 = a3 & 3;
    if ( a3 >= 4 )
    {
      v10 = a3 & 0xFFFFFFFFFFFFFFFCuLL;
      v11 = (a2 + 48);
      v7 = 0LL;
      v8 = 0LL;
      do
      {
        v7 += *(v11 - 12) + *(v11 - 8) + *(v11 - 4) + *v11;
        v8 += 4LL;
        v11 += 16;
      }
      while ( v10 != v8 );
    }
    else
    {
      v7 = 0LL;
      v8 = 0LL;
    }
    if ( v6 )
    {
      v12 = a2 + 16 * v8;
      v13 = (16 * v6);
      v14 = 0LL;
      do
      {
        v7 += *(v12 + v14);
        v14 += 16LL;
      }
      while ( v13 != v14 );
    }
    v15 = a1[2];
    if ( v7 > *a1 - v15 )
      sub_7FF7053FD5A0(a1, v15, v7, 1LL, 1LL);
    v16 = a1[2];
    v17 = 16 * a3;
    v18 = 0LL;
    do
    {
      v19 = *(a2 + v18 + 8);
      v20 = *(a2 + v18);
      if ( *a1 - v16 < v20 )
      {
        v21 = *(a2 + v18 + 8);
        sub_7FF7053FD5A0(a1, v16, v20, 1LL, 1LL);
        v19 = v21;
        v16 = a1[2];
      }
      memcpy((v16 + a1[1]), v19, v20);
      v16 += v20;
      a1[2] = v16;
      v18 += 16LL;
    }
    while ( v17 != v18 );
  }
  return 0LL;
}

//----- (00007FF7053E9A60) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char sub_7FF7053E9A60()
{
  return 1;
}

//----- (00007FF7053E9A70) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E9A70(unsigned __int64 *a1, const void *a2, size_t a3)
{
  __int64 v5; // rbx
  const void *v7; // r14

  v5 = a1[2];
  if ( a3 > *a1 - v5 )
  {
    v7 = a2;
    sub_7FF7053FD5A0(a1, v5, a3, 1LL, 1LL);
    a2 = v7;
    v5 = a1[2];
  }
  memcpy((v5 + a1[1]), a2, a3);
  a1[2] = a3 + v5;
  return 0LL;
}

//----- (00007FF7053E9AE0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053E9AE0(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r8
  __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned int *v10; // r9
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // r14
  __int64 v15; // rsi
  __int64 v16; // r12
  const void *v17; // rdx
  size_t v18; // r15
  const void *v19; // r13

  if ( a3 )
  {
    v6 = a3 & 3;
    if ( a3 >= 4 )
    {
      v9 = a3 & 0xFFFFFFFFFFFFFFFCuLL;
      v10 = (a2 + 48);
      v7 = 0LL;
      v8 = 0LL;
      do
      {
        v7 += *(v10 - 12) + *(v10 - 8) + *(v10 - 4) + *v10;
        v8 += 4LL;
        v10 += 16;
      }
      while ( v9 != v8 );
    }
    else
    {
      v7 = 0LL;
      v8 = 0LL;
    }
    if ( v6 )
    {
      v11 = a2 + 16 * v8;
      v12 = (16 * v6);
      v13 = 0LL;
      do
      {
        v7 += *(v11 + v13);
        v13 += 16LL;
      }
      while ( v12 != v13 );
    }
    v14 = a1[2];
    if ( v7 > *a1 - v14 )
    {
      sub_7FF7053FD5A0(a1, v14, v7, 1LL, 1LL);
      v14 = a1[2];
    }
    v15 = 16 * a3;
    v16 = 0LL;
    do
    {
      v17 = *(a2 + v16 + 8);
      v18 = *(a2 + v16);
      if ( *a1 - v14 < v18 )
      {
        v19 = *(a2 + v16 + 8);
        sub_7FF7053FD5A0(a1, v14, v18, 1LL, 1LL);
        v17 = v19;
        v14 = a1[2];
      }
      memcpy((v14 + a1[1]), v17, v18);
      v14 += v18;
      a1[2] = v14;
      v16 += 16LL;
    }
    while ( v15 != v16 );
  }
  return 0LL;
}

//----- (00007FF7053E9C40) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053E9C40()
{
  return 0LL;
}

//----- (00007FF7053E9C50) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053E9C50(__int64 **a1, _QWORD *a2)
{
  __int64 v3; // rdi
  __int64 v4; // rax
  signed __int64 v5; // rbx
  int v6; // eax
  signed __int64 *v7; // rcx
  signed __int64 v8; // rax
  signed __int64 v9; // rtt
  char v10; // cl
  __int64 result; // rax
  __int64 v12; // rcx
  bool v13; // zf
  char v14; // dl
  __int64 v15; // rdx
  __int64 v16; // rsi
  _QWORD v17[3]; // [rsp+20h] [rbp-60h] BYREF
  __int128 v18; // [rsp+38h] [rbp-48h]
  __int64 *v19; // [rsp+50h] [rbp-30h] BYREF
  __int64 v20; // [rsp+58h] [rbp-28h]
  __int64 v21; // [rsp+60h] [rbp-20h]
  __int64 v22; // [rsp+68h] [rbp-18h] BYREF
  __int64 v23; // [rsp+70h] [rbp-10h]
  __int64 v24; // [rsp+78h] [rbp-8h]
  __int64 v25; // [rsp+80h] [rbp+0h]

  v25 = -2LL;
  v3 = **a1;
  v4 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  v5 = *(v4 + 8);
  if ( v5 )
  {
    if ( v5 == *v3 )
    {
LABEL_3:
      v6 = *(v3 + 8);
      if ( v6 == -1 )
        sub_7FF7053FE0B0(
          "lock count overflow in reentrant mutexlibrary\\std\\src\\sync\\reentrant_lock.rs",
          38LL,
          &off_7FF705401B18);
      *(v3 + 8) = v6 + 1;
      goto LABEL_12;
    }
  }
  else
  {
    v7 = (v4 + 8);
    v8 = qword_7FF70540B1F8;
    do
    {
      if ( v8 == -1 )
        sub_7FF7053FD680();
      v5 = v8 + 1;
      v9 = v8;
      v8 = _InterlockedCompareExchange64(&qword_7FF70540B1F8, v8 + 1, v8);
    }
    while ( v9 != v8 );
    *v7 = v5;
    if ( v5 == *v3 )
      goto LABEL_3;
  }
  if ( _InterlockedCompareExchange8((v3 + 12), 1, 0) )
    sub_7FF7053FD890((v3 + 12));
  *v3 = v5;
  *(v3 + 8) = 1;
LABEL_12:
  v22 = v3;
  v19 = &v22;
  v20 = 0LL;
  v10 = sub_7FF7053F9220(&v19, &off_7FF705400FB0, a2);
  result = v20;
  if ( v10 )
  {
    if ( !v20 )
    {
      v17[0] = &off_7FF705401798;
      v17[1] = 1LL;
      v17[2] = 8LL;
      v18 = 0LL;
      sub_7FF7053FE110(v17, &off_7FF7054017A8);
    }
    v12 = v22;
    v13 = (*(v22 + 8))-- == 1;
    if ( v13 )
    {
LABEL_18:
      *v12 = 0LL;
      v14 = *(v12 + 12);
      *(v12 + 12) = 0;
      if ( v14 == 2 )
      {
        v16 = result;
        WakeByAddressSingle((v12 + 12));
        return v16;
      }
    }
  }
  else
  {
    if ( (v20 & 3) == 1 )
    {
      v21 = v20 - 1;
      v23 = *(v20 - 1);
      v24 = *(v20 + 7);
      if ( *v24 )
        (*v24)(v23);
      v15 = *(v24 + 8);
      if ( v15 )
        sub_7FF7053E5E40(v23, v15, *(v24 + 16));
      sub_7FF7053E5E40(v21, 24LL, 8LL);
    }
    result = 0LL;
    v12 = v22;
    v13 = (*(v22 + 8))-- == 1;
    if ( v13 )
      goto LABEL_18;
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705400FB0: using guessed type __int64 (__fastcall *off_7FF705400FB0)();
// 7FF705401798: using guessed type char *off_7FF705401798;
// 7FF7054017A8: using guessed type char *off_7FF7054017A8;
// 7FF705401B18: using guessed type char *off_7FF705401B18;
// 7FF70540B1F8: using guessed type __int64 qword_7FF70540B1F8;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053E9F00) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053E9F00(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rsi
  char *v5; // rdi
  __int64 v6; // rdx
  _QWORD *v7; // r12
  _QWORD *v8; // rbx
  unsigned __int64 v9; // r14
  bool v10; // cf
  __int64 v11; // r15
  unsigned __int64 result; // rax
  __int64 v13; // r14
  _QWORD v14[3]; // [rsp+20h] [rbp-40h] BYREF
  __int128 v15; // [rsp+38h] [rbp-28h]
  __int64 v16; // [rsp+50h] [rbp-10h]
  __int64 v17; // [rsp+58h] [rbp-8h]

  v17 = -2LL;
  v3 = *a1;
  if ( *(*a1 + 16) )
    sub_7FF7053FE030(&off_7FF705401698);
  v4 = a3;
  v5 = a2;
  v16 = *a1;
  *(v3 + 16) = -1LL;
  v7 = v16;
  v8 = (v16 + 24);
  if ( (sub_7FF7053FA810(0xAu, a2, a3) & 1) != 0 )
  {
    v9 = v6 + 1;
    v10 = v4 < v6 + 1;
    v4 -= v6 + 1;
    if ( v10 )
    {
      v14[0] = &off_7FF705400C18;
      v14[1] = 1LL;
      v14[2] = 8LL;
      v15 = 0LL;
      sub_7FF7053FE110(v14, &off_7FF7054012E0);
    }
    v11 = *(v16 + 40);
    if ( v11 )
    {
      if ( v9 >= *v8 - v11 )
      {
        result = sub_7FF7053FD6C0(v16 + 24, v5, v9);
        if ( result )
          goto LABEL_24;
      }
      else
      {
        memcpy((v11 + *(v16 + 32)), v5, v9);
        *(v16 + 40) = v9 + v11;
      }
      result = sub_7FF7053E9430(v8);
      if ( !result )
      {
LABEL_18:
        v5 += v9;
        v7 = v16;
        v13 = *(v16 + 40);
        if ( v4 < *(v16 + 24) - v13 )
          goto LABEL_19;
        goto LABEL_23;
      }
    }
    else
    {
      result = sub_7FF7053EAD30((v16 + 49), v5, v9);
      if ( (result & 0xFFFFFFFF00000003uLL) == 0x600000002LL || result == 0 )
        goto LABEL_18;
    }
LABEL_24:
    v7 = v16;
    goto LABEL_25;
  }
  v13 = *(v16 + 40);
  if ( !v13 )
  {
    v13 = 0LL;
LABEL_15:
    if ( v4 >= *v8 - v13 )
      goto LABEL_23;
    goto LABEL_19;
  }
  if ( *(*(v16 + 32) + v13 - 1) != 10 )
    goto LABEL_15;
  result = sub_7FF7053E9430(v16 + 24);
  if ( result )
    goto LABEL_24;
  v7 = v16;
  v13 = *(v16 + 40);
  if ( v4 >= *v8 - v13 )
  {
LABEL_23:
    result = sub_7FF7053FD6C0(v8, v5, v4);
    goto LABEL_24;
  }
LABEL_19:
  memcpy((v13 + v7[4]), v5, v4);
  v7[5] = v4 + v13;
  result = 0LL;
LABEL_25:
  ++v7[2];
  return result;
}
// 7FF7053E9F52: variable 'v6' is possibly undefined
// 7FF705400C18: using guessed type char *off_7FF705400C18;
// 7FF7054012E0: using guessed type char *off_7FF7054012E0;
// 7FF705401698: using guessed type char *off_7FF705401698;

//----- (00007FF7053EA130) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EA130(__int64 **a1, _QWORD *a2)
{
  __int64 v3; // rdi
  __int64 v4; // rax
  signed __int64 v5; // rbx
  int v6; // eax
  signed __int64 *v7; // rcx
  signed __int64 v8; // rax
  signed __int64 v9; // rtt
  char v10; // cl
  __int64 result; // rax
  __int64 v12; // rcx
  bool v13; // zf
  char v14; // dl
  __int64 v15; // rdx
  __int64 v16; // rsi
  _QWORD v17[3]; // [rsp+20h] [rbp-60h] BYREF
  __int128 v18; // [rsp+38h] [rbp-48h]
  __int64 *v19; // [rsp+50h] [rbp-30h] BYREF
  __int64 v20; // [rsp+58h] [rbp-28h]
  __int64 v21; // [rsp+60h] [rbp-20h]
  __int64 v22; // [rsp+68h] [rbp-18h] BYREF
  __int64 v23; // [rsp+70h] [rbp-10h]
  __int64 v24; // [rsp+78h] [rbp-8h]
  __int64 v25; // [rsp+80h] [rbp+0h]

  v25 = -2LL;
  v3 = **a1;
  v4 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  v5 = *(v4 + 8);
  if ( v5 )
  {
    if ( v5 == *v3 )
    {
LABEL_3:
      v6 = *(v3 + 8);
      if ( v6 == -1 )
        sub_7FF7053FE0B0(
          "lock count overflow in reentrant mutexlibrary\\std\\src\\sync\\reentrant_lock.rs",
          38LL,
          &off_7FF705401B18);
      *(v3 + 8) = v6 + 1;
      goto LABEL_12;
    }
  }
  else
  {
    v7 = (v4 + 8);
    v8 = qword_7FF70540B1F8;
    do
    {
      if ( v8 == -1 )
        sub_7FF7053FD680();
      v5 = v8 + 1;
      v9 = v8;
      v8 = _InterlockedCompareExchange64(&qword_7FF70540B1F8, v8 + 1, v8);
    }
    while ( v9 != v8 );
    *v7 = v5;
    if ( v5 == *v3 )
      goto LABEL_3;
  }
  if ( _InterlockedCompareExchange8((v3 + 12), 1, 0) )
    sub_7FF7053FD890((v3 + 12));
  *v3 = v5;
  *(v3 + 8) = 1;
LABEL_12:
  v22 = v3;
  v19 = &v22;
  v20 = 0LL;
  v10 = sub_7FF7053F9220(&v19, &off_7FF705400F50, a2);
  result = v20;
  if ( v10 )
  {
    if ( !v20 )
    {
      v17[0] = &off_7FF705401798;
      v17[1] = 1LL;
      v17[2] = 8LL;
      v18 = 0LL;
      sub_7FF7053FE110(v17, &off_7FF7054017A8);
    }
    v12 = v22;
    v13 = (*(v22 + 8))-- == 1;
    if ( v13 )
    {
LABEL_18:
      *v12 = 0LL;
      v14 = *(v12 + 12);
      *(v12 + 12) = 0;
      if ( v14 == 2 )
      {
        v16 = result;
        WakeByAddressSingle((v12 + 12));
        return v16;
      }
    }
  }
  else
  {
    if ( (v20 & 3) == 1 )
    {
      v21 = v20 - 1;
      v23 = *(v20 - 1);
      v24 = *(v20 + 7);
      if ( *v24 )
        (*v24)(v23);
      v15 = *(v24 + 8);
      if ( v15 )
        sub_7FF7053E5E40(v23, v15, *(v24 + 16));
      sub_7FF7053E5E40(v21, 24LL, 8LL);
    }
    result = 0LL;
    v12 = v22;
    v13 = (*(v22 + 8))-- == 1;
    if ( v13 )
      goto LABEL_18;
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705400F50: using guessed type __int64 (__fastcall *off_7FF705400F50)();
// 7FF705401798: using guessed type char *off_7FF705401798;
// 7FF7054017A8: using guessed type char *off_7FF7054017A8;
// 7FF705401B18: using guessed type char *off_7FF705401B18;
// 7FF70540B1F8: using guessed type __int64 qword_7FF70540B1F8;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053EA3E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EA3E0(volatile signed __int64 *a1)
{
  __int64 v1; // rax
  __int64 v2; // rsi
  int v3; // eax
  __int64 result; // rax
  volatile signed __int64 *v5; // [rsp+20h] [rbp-10h] BYREF
  volatile signed __int64 *v6; // [rsp+28h] [rbp-8h]
  __int64 v7; // [rsp+30h] [rbp+0h]

  v7 = -2LL;
  if ( !a1 && !byte_7FF70540B148 )
    return 0LL;
  byte_7FF70540B148 = 1;
  v5 = a1;
  v1 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  v2 = v1 + 64;
  v3 = *(v1 + 72);
  if ( v3 == 1 )
  {
LABEL_9:
    *v2 = a1;
    return 0LL;
  }
  if ( v3 != 2 )
  {
    v6 = a1;
    sub_7FF7053F1940(v2, sub_7FF7053F1920);
    *(v2 + 8) = 1;
    a1 = v6;
    goto LABEL_9;
  }
  result = 1LL;
  if ( a1 )
  {
    if ( !_InterlockedDecrement64(a1) )
    {
      sub_7FF7053E7980(&v5);
      return 1LL;
    }
  }
  return result;
}
// 7FF70540B148: using guessed type char byte_7FF70540B148;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053EA4D0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053EA4D0(_QWORD *a1)
{
  __int64 v1; // rax
  __int64 v2; // rsi
  int v3; // eax
  _QWORD *v4; // rdi
  __int64 v5; // rbx
  _QWORD *v6; // rdi
  __int64 v7; // rax
  PVOID v8; // rcx
  char v9; // al
  volatile signed __int64 *v10; // rax
  __int64 v12; // rdx
  _QWORD *v13; // rdi
  int v14; // eax
  __int64 v15[2]; // [rsp+28h] [rbp-48h] BYREF
  PVOID Address; // [rsp+38h] [rbp-38h]
  __int64 v17; // [rsp+40h] [rbp-30h]
  __int64 v18; // [rsp+48h] [rbp-28h]
  __int64 v19; // [rsp+50h] [rbp-20h]
  __int64 v20; // [rsp+58h] [rbp-18h]
  int v21; // [rsp+64h] [rbp-Ch]
  __int64 v22; // [rsp+68h] [rbp-8h]

  v22 = -2LL;
  if ( !byte_7FF70540B148 )
    return 0;
  v1 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  v2 = v1 + 64;
  v3 = *(v1 + 72);
  if ( v3 != 1 )
  {
    if ( v3 == 2 )
      return 0;
    v4 = a1;
    sub_7FF7053F1940(v2, sub_7FF7053F1920);
    a1 = v4;
    *(v2 + 8) = 1;
  }
  v5 = *v2;
  *v2 = 0LL;
  if ( !v5 )
    return 0;
  v15[1] = v5;
  if ( _InterlockedCompareExchange8((v5 + 16), 1, 0) )
  {
    v13 = a1;
    sub_7FF7053FD890((v5 + 16));
    a1 = v13;
  }
  v6 = a1;
  Address = (v5 + 16);
  if ( 2 * qword_7FF70540B1E0 )
  {
    LOBYTE(v14) = !sub_7FF7053FD820();
    v21 = v14;
  }
  else
  {
    v21 = 0;
  }
  v18 = v5;
  v7 = sub_7FF7053EB4A0(v5 + 24, v6);
  if ( (v7 & 3) == 1 )
  {
    v17 = v7 - 1;
    v19 = *(v7 - 1);
    v20 = *(v7 + 7);
    if ( *v20 )
      (*v20)(v19);
    v12 = *(v20 + 8);
    if ( v12 )
      sub_7FF7053E5E40(v19, v12, *(v20 + 16));
    sub_7FF7053E5E40(v17, 24LL, 8LL);
    if ( v21 )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( !v21 )
  {
LABEL_12:
    if ( 2 * qword_7FF70540B1E0 && !sub_7FF7053FD820() )
      *(v18 + 17) = 1;
  }
LABEL_13:
  v8 = Address;
  v9 = *Address;
  *Address = 0;
  if ( v9 == 2 )
    WakeByAddressSingle(v8);
  v15[0] = *v2;
  v10 = v15[0];
  *v2 = v18;
  if ( v10 )
  {
    if ( !_InterlockedDecrement64(v10) )
      sub_7FF7053E7980(v15);
  }
  return 1;
}
// 7FF7053EA682: variable 'v14' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF70540B148: using guessed type char byte_7FF70540B148;
// 7FF70540B1E0: using guessed type __int64 qword_7FF70540B1E0;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053EA750) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053EA750(_QWORD *a1)
{
  __int64 v2; // rax
  _QWORD v4[4]; // [rsp+20h] [rbp-60h] BYREF
  __int64 *v5[6]; // [rsp+40h] [rbp-40h] BYREF
  _QWORD v6[2]; // [rsp+70h] [rbp-10h] BYREF
  __int64 *v7; // [rsp+80h] [rbp+0h] BYREF
  _QWORD v8[3]; // [rsp+88h] [rbp+8h] BYREF

  v8[1] = -2LL;
  v6[0] = "stdoutstderrlibrary\\std\\src\\io\\mod.rs";
  v6[1] = 6LL;
  LOBYTE(v2) = sub_7FF7053EA4D0(a1);
  if ( !v2 )
  {
    if ( dword_7FF70540B188 != 3 )
      sub_7FF7053FD7BA();
    v7 = &qword_7FF70540B150;
    v5[0] = &v7;
    v2 = sub_7FF7053E9C50(v5, a1);
    if ( v2 )
    {
      v8[0] = v2;
      v4[0] = v6;
      v4[1] = sub_7FF7053E5F90;
      v4[2] = v8;
      v4[3] = sub_7FF7053E96C0;
      v5[0] = &off_7FF7054016E0;
      v5[1] = 2;
      v5[4] = 0LL;
      v5[2] = v4;
      v5[3] = 2;
      sub_7FF7053FE110(v5, &off_7FF705401700);
    }
  }
  return v2;
}
// 7FF7054016E0: using guessed type char *off_7FF7054016E0;
// 7FF705401700: using guessed type char *off_7FF705401700;
// 7FF70540B150: using guessed type __int64 qword_7FF70540B150;
// 7FF70540B188: using guessed type int dword_7FF70540B188;

//----- (00007FF7053EA860) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053EA860(_QWORD *a1)
{
  __int64 v2; // rax
  _QWORD v4[4]; // [rsp+20h] [rbp-60h] BYREF
  __int64 *v5[6]; // [rsp+40h] [rbp-40h] BYREF
  _QWORD v6[2]; // [rsp+70h] [rbp-10h] BYREF
  void *v7; // [rsp+80h] [rbp+0h] BYREF
  _QWORD v8[3]; // [rsp+88h] [rbp+8h] BYREF

  v8[1] = -2LL;
  v6[0] = "stderrlibrary\\std\\src\\io\\mod.rs";
  v6[1] = 6LL;
  LOBYTE(v2) = sub_7FF7053EA4D0(a1);
  if ( !v2 )
  {
    v7 = &unk_7FF70540B190;
    v5[0] = &v7;
    v2 = sub_7FF7053EA130(v5, a1);
    if ( v2 )
    {
      v8[0] = v2;
      v4[0] = v6;
      v4[1] = sub_7FF7053E5F90;
      v4[2] = v8;
      v4[3] = sub_7FF7053E96C0;
      v5[0] = &off_7FF7054016E0;
      v5[1] = 2;
      v5[4] = 0LL;
      v5[2] = v4;
      v5[3] = 2;
      sub_7FF7053FE110(v5, &off_7FF705401700);
    }
  }
  return v2;
}
// 7FF7054016E0: using guessed type char *off_7FF7054016E0;
// 7FF705401700: using guessed type char *off_7FF705401700;

//----- (00007FF7053EA960) ----------------------------------------------------
bool __fastcall sub_7FF7053EA960(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v6; // [rsp+20h] [rbp-10h]
  __int64 *v7; // [rsp+28h] [rbp-8h]

  v4 = sub_7FF7053E9F00(*a1, a2, a3);
  if ( v4 )
  {
    v6 = v4;
    v7 = (a1 + 8);
    if ( *(a1 + 8) )
      sub_7FF7053E69E0(v7);
    v4 = v6;
    *v7 = v6;
  }
  return v4 != 0;
}

//----- (00007FF7053EA9F0) ----------------------------------------------------
bool __fastcall sub_7FF7053EA9F0(__int64 **a1, char *a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  char **v5; // rax
  char **v6; // r8
  __int64 v8; // [rsp+20h] [rbp-10h]
  __int64 v9; // [rsp+28h] [rbp-8h]
  __int64 *v10; // [rsp+28h] [rbp-8h]

  v3 = **a1;
  if ( *(v3 + 16) )
    sub_7FF7053FE030(&off_7FF7054016B0);
  *(v3 + 16) = -1LL;
  v9 = v3;
  v5 = sub_7FF7053EAF30((v3 + 24), a2, a3);
  v6 = 0LL;
  if ( (v5 & 0xFFFFFFFF00000003uLL) != 0x600000002LL )
    v6 = v5;
  ++*(v9 + 16);
  if ( v6 )
  {
    v8 = v6;
    v10 = (a1 + 1);
    if ( a1[1] )
      sub_7FF7053E69E0(v10);
    v6 = v8;
    *v10 = v8;
  }
  return v6 != 0LL;
}
// 7FF7054016B0: using guessed type char *off_7FF7054016B0;

//----- (00007FF7053EAAF0) ----------------------------------------------------
bool __fastcall sub_7FF7053EAAF0(__int64 a1, char *a2, unsigned __int64 a3)
{
  char **v4; // rax
  char **v6; // [rsp+20h] [rbp-10h]
  __int64 *v7; // [rsp+28h] [rbp-8h]

  v4 = sub_7FF7053EAF30(*a1, a2, a3);
  if ( v4 )
  {
    v6 = v4;
    v7 = (a1 + 8);
    if ( *(a1 + 8) )
      sub_7FF7053E69E0(v7);
    v4 = v6;
    *v7 = v6;
  }
  return v4 != 0LL;
}

//----- (00007FF7053EAB80) ----------------------------------------------------
__int64 __fastcall sub_7FF7053EAB80(unsigned __int64 **a1, const void *a2, size_t a3)
{
  unsigned __int64 *v4; // rdi
  __int64 v5; // rbx
  const void *v7; // r14

  v4 = *a1;
  v5 = (*a1)[2];
  if ( a3 > **a1 - v5 )
  {
    v7 = a2;
    sub_7FF7053FD5A0(v4, v5, a3, 1LL, 1LL);
    a2 = v7;
    v5 = v4[2];
  }
  memcpy((v5 + v4[1]), a2, a3);
  v4[2] = a3 + v5;
  return 0LL;
}

//----- (00007FF7053EABF0) ----------------------------------------------------
bool __fastcall sub_7FF7053EABF0(__int64 *a1, const void *a2, size_t a3)
{
  _QWORD *v5; // r15
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // rcx
  size_t v9; // r14
  void *v10; // rcx
  size_t v11; // rbx
  __int64 *v13; // [rsp+20h] [rbp-10h]

  v5 = *a1;
  v6 = *(*a1 + 8);
  v8 = *(*a1 + 16);
  v7 = v8;
  if ( v6 < v8 )
    v8 = v6;
  v9 = v6 - v8;
  v10 = (*v5 + v8);
  v11 = a3;
  if ( v9 < a3 )
    v11 = v9;
  memcpy(v10, a2, v11);
  v5[2] = v7 + v11;
  if ( v9 < a3 )
  {
    v13 = a1 + 1;
    if ( a1[1] )
      sub_7FF7053E69E0(v13);
    *v13 = &off_7FF705401318;
  }
  return v9 < a3;
}
// 7FF705401318: using guessed type char *off_7FF705401318;

//----- (00007FF7053EACD0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053EACD0(unsigned __int8 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r8
  __int64 v5; // rcx
  unsigned __int64 v6; // rax

  v4 = 16 * a3;
  v5 = 0LL;
  while ( v4 != v5 )
  {
    v6 = *(a2 + v5);
    v5 += 16LL;
    if ( v6 )
      return sub_7FF7053F1350(0xFFFFFFF4, *(a2 + v5 - 8), v6, a1);
  }
  return sub_7FF7053F1350(0xFFFFFFF4, 1, 0LL, a1);
}

//----- (00007FF7053EAD20) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053EAD20()
{
  return 0LL;
}

//----- (00007FF7053EAD30) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char **__fastcall sub_7FF7053EAD30(unsigned __int8 *a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  unsigned __int64 v6; // rdx
  __int64 v7; // rdx
  unsigned __int64 v9; // [rsp+38h] [rbp-18h]
  _QWORD *v10; // [rsp+40h] [rbp-10h]
  __int64 v11; // [rsp+48h] [rbp-8h]

  if ( a3 )
  {
    v3 = a3;
    do
    {
      if ( (sub_7FF7053F1350(0xFFFFFFF5, a2, v3, a1) & 1) != 0 )
      {
        switch ( v6 & 3 )
        {
          case 0uLL:
            if ( *(v6 + 16) != 35 )
              return v6;
            break;
          case 1uLL:
            if ( *(v6 + 15) != 35 )
              return v6;
            if ( (v6 & 3) == 1 )
            {
              v9 = v6 - 1;
              v11 = *(v6 - 1);
              v10 = *(v6 + 7);
              if ( *v10 )
                JUMPOUT(0x7FF7053EAE1ALL);
              v7 = v10[1];
              if ( v7 )
                sub_7FF7053E5E40(v11, v7, v10[2]);
              sub_7FF7053E5E40(v9, 24LL, 8LL);
            }
            break;
          case 2uLL:
            return v6;
          case 3uLL:
            if ( HIDWORD(v6) == 35 )
              break;
            return v6;
        }
      }
      else
      {
        if ( !v6 )
          return &off_7FF705401318;
        if ( v3 < v6 )
          sub_7FF7053FE4D0(v6, v3, &off_7FF705401878);
        a2 += v6;
        v3 -= v6;
      }
    }
    while ( v3 );
  }
  return 0LL;
}
// 7FF7053EAE18: control flows out of bounds to 7FF7053EAE1A
// 7FF7053EAD75: variable 'v6' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705401318: using guessed type char *off_7FF705401318;
// 7FF705401878: using guessed type char *off_7FF705401878;

//----- (00007FF7053EAF30) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char **__fastcall sub_7FF7053EAF30(unsigned __int8 *a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  unsigned __int64 v6; // rdx
  __int64 v7; // rdx
  unsigned __int64 v9; // [rsp+38h] [rbp-18h]
  _QWORD *v10; // [rsp+40h] [rbp-10h]
  __int64 v11; // [rsp+48h] [rbp-8h]

  if ( a3 )
  {
    v3 = a3;
    do
    {
      if ( (sub_7FF7053F1350(0xFFFFFFF4, a2, v3, a1) & 1) != 0 )
      {
        switch ( v6 & 3 )
        {
          case 0uLL:
            if ( *(v6 + 16) != 35 )
              return v6;
            break;
          case 1uLL:
            if ( *(v6 + 15) != 35 )
              return v6;
            if ( (v6 & 3) == 1 )
            {
              v9 = v6 - 1;
              v11 = *(v6 - 1);
              v10 = *(v6 + 7);
              if ( *v10 )
                JUMPOUT(0x7FF7053EB01ALL);
              v7 = v10[1];
              if ( v7 )
                sub_7FF7053E5E40(v11, v7, v10[2]);
              sub_7FF7053E5E40(v9, 24LL, 8LL);
            }
            break;
          case 2uLL:
            return v6;
          case 3uLL:
            if ( HIDWORD(v6) == 35 )
              break;
            return v6;
        }
      }
      else
      {
        if ( !v6 )
          return &off_7FF705401318;
        if ( v3 < v6 )
          sub_7FF7053FE4D0(v6, v3, &off_7FF705401878);
        a2 += v6;
        v3 -= v6;
      }
    }
    while ( v3 );
  }
  return 0LL;
}
// 7FF7053EB018: control flows out of bounds to 7FF7053EB01A
// 7FF7053EAF75: variable 'v6' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705401318: using guessed type char *off_7FF705401318;
// 7FF705401878: using guessed type char *off_7FF705401878;

//----- (00007FF7053EB130) ----------------------------------------------------
char **__fastcall sub_7FF7053EB130(unsigned __int8 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v5; // rdx
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rsi
  __int64 v8; // rdx
  unsigned int *v10; // rdi
  __int64 v11; // r12
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned __int64 v17; // r8
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // r10
  unsigned __int64 v20; // r9
  bool v21; // cf
  unsigned __int64 v22; // rcx
  __int64 v23; // rdx
  char **v24; // [rsp+20h] [rbp-60h] BYREF
  __int64 v25; // [rsp+28h] [rbp-58h]
  __int64 v26; // [rsp+30h] [rbp-50h]
  __int128 v27; // [rsp+38h] [rbp-48h]
  __int64 v28; // [rsp+50h] [rbp-30h]
  __int64 v29; // [rsp+58h] [rbp-28h]
  __int64 v30; // [rsp+60h] [rbp-20h]
  __int64 v31; // [rsp+68h] [rbp-18h]
  __int64 v32; // [rsp+70h] [rbp-10h]
  __int64 v33; // [rsp+78h] [rbp-8h]

  v33 = -2LL;
  if ( !a3 )
    return 0LL;
  v5 = 0LL;
  v6 = 0LL;
  do
  {
    if ( *(a2 + v5) )
      break;
    ++v6;
    v5 += 16LL;
  }
  while ( 16 * a3 != v5 );
  if ( a3 < v6 )
    sub_7FF7053FE4D0(v6, a3, &off_7FF7054017C0);
  v7 = a3 - v6;
  if ( a3 == v6 )
    return 0LL;
  v10 = (16 * v6 + a2);
  while ( 1 )
  {
    v11 = 16 * v7;
    v12 = 0LL;
    while ( v11 != v12 )
    {
      v13 = v10[v12 / 4];
      v12 += 16LL;
      if ( v13 )
      {
        v14 = *&v10[v12 / 4 - 2];
        goto LABEL_17;
      }
    }
    v14 = 1LL;
    v13 = 0LL;
LABEL_17:
    v15 = sub_7FF7053F1350(0xFFFFFFF4, v14, v13, a1);
    v28 = v15;
    v29 = v8;
    if ( (v15 & 1) != 0 )
    {
      switch ( v8 & 3 )
      {
        case 0LL:
          v16 = 16LL;
          goto LABEL_33;
        case 1LL:
          v16 = 15LL;
LABEL_33:
          if ( *(v8 + v16) != 35 )
            return v8;
          goto LABEL_36;
        case 2LL:
          return v8;
        case 3LL:
          if ( HIDWORD(v8) == 35 )
            goto LABEL_36;
          return v8;
      }
    }
    if ( !v8 )
      return &off_7FF705401318;
    v17 = 0LL;
    v18 = 0LL;
    v19 = v8;
    while ( 1 )
    {
      v20 = v10[v17 / 4];
      v21 = v19 < v20;
      v19 -= v20;
      if ( v21 )
        break;
      ++v18;
      v17 += 16LL;
      v8 = v19;
      if ( v11 == v17 )
        goto LABEL_26;
    }
    v19 = v8;
LABEL_26:
    if ( v7 < v18 )
    {
      v32 = v15;
      sub_7FF7053FE4D0(v18, v7, &off_7FF7054017C0);
    }
    v10 += 4 * v18;
    v7 -= v18;
    if ( v7 )
    {
      v22 = *v10;
      if ( v19 > v22 )
      {
        v32 = v15;
        v24 = &off_7FF705401850;
        v25 = 1LL;
        v26 = 8LL;
        v27 = 0LL;
        sub_7FF7053FE110(&v24, &off_7FF705401860);
      }
      *v10 = v22 - v19;
      *(v10 + 1) += v19;
      LOBYTE(v15) = v28;
    }
    else
    {
      if ( v19 )
      {
        v32 = v15;
        v24 = &off_7FF705401800;
        v25 = 1LL;
        v26 = 8LL;
        v27 = 0LL;
        sub_7FF7053FE110(&v24, &off_7FF705401810);
      }
      v7 = 0LL;
    }
LABEL_36:
    if ( (v15 & 1) != 0 && (v29 & 3) == 1 )
    {
      v30 = v29 - 1;
      v32 = *(v29 - 1);
      v31 = *(v29 + 7);
      if ( *v31 )
        (*v31)(v32);
      v23 = *(v31 + 8);
      if ( v23 )
        sub_7FF7053E5E40(v32, v23, *(v31 + 16));
      sub_7FF7053E5E40(v30, 24LL, 8LL);
    }
    if ( !v7 )
      return 0LL;
  }
}
// 7FF7053EB192: variable 'v8' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705401318: using guessed type char *off_7FF705401318;
// 7FF7054017C0: using guessed type char *off_7FF7054017C0;
// 7FF705401800: using guessed type char *off_7FF705401800;
// 7FF705401810: using guessed type char *off_7FF705401810;
// 7FF705401850: using guessed type char *off_7FF705401850;
// 7FF705401860: using guessed type char *off_7FF705401860;

//----- (00007FF7053EB4A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EB4A0(__int64 a1, _QWORD *a2)
{
  char v2; // cl
  __int64 result; // rax
  __int64 v4; // rdx
  _QWORD v5[3]; // [rsp+20h] [rbp-60h] BYREF
  __int128 v6; // [rsp+38h] [rbp-48h]
  __int64 v7; // [rsp+50h] [rbp-30h] BYREF
  __int64 v8; // [rsp+58h] [rbp-28h]
  __int64 v9; // [rsp+60h] [rbp-20h]
  __int64 v10; // [rsp+68h] [rbp-18h]
  __int64 v11; // [rsp+70h] [rbp-10h]
  __int64 v12; // [rsp+78h] [rbp-8h]

  v12 = -2LL;
  v7 = a1;
  v8 = 0LL;
  v2 = sub_7FF7053F9220(&v7, &off_7FF705400EC0, a2);
  result = v8;
  if ( v2 )
  {
    if ( !v8 )
    {
      v5[0] = &off_7FF705401798;
      v5[1] = 1LL;
      v5[2] = 8LL;
      v6 = 0LL;
      sub_7FF7053FE110(v5, &off_7FF7054017A8);
    }
  }
  else if ( (v8 & 3) == 1 )
  {
    v9 = v8 - 1;
    v10 = *(v8 - 1);
    v11 = *(v8 + 7);
    if ( *v11 )
      (*v11)(v10);
    v4 = *(v11 + 8);
    if ( v4 )
      sub_7FF7053E5E40(v10, v4, *(v11 + 16));
    sub_7FF7053E5E40(v9, 24LL, 8LL);
    return 0LL;
  }
  else
  {
    return 0LL;
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705400EC0: using guessed type __int64 (__fastcall *off_7FF705400EC0)();
// 7FF705401798: using guessed type char *off_7FF705401798;
// 7FF7054017A8: using guessed type char *off_7FF7054017A8;

//----- (00007FF7053EB620) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EB620(__int64 a1, _QWORD *a2)
{
  char v2; // cl
  __int64 result; // rax
  __int64 v4; // rdx
  _QWORD v5[3]; // [rsp+20h] [rbp-60h] BYREF
  __int128 v6; // [rsp+38h] [rbp-48h]
  __int64 v7; // [rsp+50h] [rbp-30h] BYREF
  __int64 v8; // [rsp+58h] [rbp-28h]
  __int64 v9; // [rsp+60h] [rbp-20h]
  __int64 v10; // [rsp+68h] [rbp-18h]
  __int64 v11; // [rsp+70h] [rbp-10h]
  __int64 v12; // [rsp+78h] [rbp-8h]

  v12 = -2LL;
  v7 = a1;
  v8 = 0LL;
  v2 = sub_7FF7053F9220(&v7, &off_7FF705400F80, a2);
  result = v8;
  if ( v2 )
  {
    if ( !v8 )
    {
      v5[0] = &off_7FF705401798;
      v5[1] = 1LL;
      v5[2] = 8LL;
      v6 = 0LL;
      sub_7FF7053FE110(v5, &off_7FF7054017A8);
    }
  }
  else if ( (v8 & 3) == 1 )
  {
    v9 = v8 - 1;
    v10 = *(v8 - 1);
    v11 = *(v8 + 7);
    if ( *v11 )
      (*v11)(v10);
    v4 = *(v11 + 8);
    if ( v4 )
      sub_7FF7053E5E40(v10, v4, *(v11 + 16));
    sub_7FF7053E5E40(v9, 24LL, 8LL);
    return 0LL;
  }
  else
  {
    return 0LL;
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705400F80: using guessed type __int64 (__fastcall *off_7FF705400F80)();
// 7FF705401798: using guessed type char *off_7FF705401798;
// 7FF7054017A8: using guessed type char *off_7FF7054017A8;

//----- (00007FF7053EB7A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EB7A0(__int64 a1, _QWORD *a2)
{
  char v2; // cl
  __int64 result; // rax
  __int64 v4; // rdx
  _QWORD v5[3]; // [rsp+20h] [rbp-60h] BYREF
  __int128 v6; // [rsp+38h] [rbp-48h]
  __int64 v7; // [rsp+50h] [rbp-30h] BYREF
  __int64 v8; // [rsp+58h] [rbp-28h]
  __int64 v9; // [rsp+60h] [rbp-20h]
  __int64 v10; // [rsp+68h] [rbp-18h]
  __int64 v11; // [rsp+70h] [rbp-10h]
  __int64 v12; // [rsp+78h] [rbp-8h]

  v12 = -2LL;
  v7 = a1;
  v8 = 0LL;
  v2 = sub_7FF7053F9220(&v7, &off_7FF705400EF0, a2);
  result = v8;
  if ( v2 )
  {
    if ( !v8 )
    {
      v5[0] = &off_7FF705401798;
      v5[1] = 1LL;
      v5[2] = 8LL;
      v6 = 0LL;
      sub_7FF7053FE110(v5, &off_7FF7054017A8);
    }
  }
  else if ( (v8 & 3) == 1 )
  {
    v9 = v8 - 1;
    v10 = *(v8 - 1);
    v11 = *(v8 + 7);
    if ( *v11 )
      (*v11)(v10);
    v4 = *(v11 + 8);
    if ( v4 )
      sub_7FF7053E5E40(v10, v4, *(v11 + 16));
    sub_7FF7053E5E40(v9, 24LL, 8LL);
    return 0LL;
  }
  else
  {
    return 0LL;
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705400EF0: using guessed type __int64 (__fastcall *off_7FF705400EF0)();
// 7FF705401798: using guessed type char *off_7FF705401798;
// 7FF7054017A8: using guessed type char *off_7FF7054017A8;

//----- (00007FF7053EB920) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_OWORD *__fastcall sub_7FF7053EB920(_OWORD *a1, unsigned __int16 *a2, __int64 a3)
{
  unsigned __int16 v3; // r12
  __int64 v7; // r14
  __int64 v8; // rax
  unsigned __int16 *v9; // r14
  char v10; // r13
  unsigned __int16 v11; // ax
  unsigned __int16 v12; // cx
  __int128 v13; // xmm0
  __int128 v15; // [rsp+20h] [rbp-20h] BYREF
  __int128 v16; // [rsp+30h] [rbp-10h]
  __int64 v17; // [rsp+40h] [rbp+0h]

  v17 = -2LL;
  if ( a3 < 0 )
  {
    v7 = 0LL;
    goto LABEL_22;
  }
  if ( a3 )
  {
    nullsub_1();
    v7 = 1LL;
    v8 = sub_7FF7053E5E30(a3, 1LL);
    if ( !v8 )
LABEL_22:
      sub_7FF7053FDFF0(v7, a3, &off_7FF7054019C8);
  }
  else
  {
    v8 = 1LL;
  }
  *&v15 = a3;
  *(&v15 + 1) = v8;
  *&v16 = 0LL;
  BYTE8(v16) = 1;
  v9 = &a2[a3];
  v10 = 0;
  while ( 1 )
  {
    if ( (v10 & 1) != 0 )
    {
      v11 = v3;
      goto LABEL_12;
    }
    if ( a2 == v9 )
      break;
    v11 = *a2++;
LABEL_12:
    if ( (v11 & 0xF800) != 0xD800 )
      goto LABEL_7;
    if ( v11 > 0xDBFFu )
    {
      v10 = 0;
    }
    else if ( a2 == v9 )
    {
      v10 = 0;
      a2 = v9;
    }
    else
    {
      v12 = *a2++;
      if ( (v12 + 0x2000) >= 0xFC00u )
LABEL_7:
        JUMPOUT(0x7FF7053EB9D2LL);
      v10 = 1;
      v3 = v12;
    }
    BYTE8(v16) = 0;
    sub_7FF7053EDA70(&v15, v11);
  }
  v13 = v15;
  a1[1] = v16;
  *a1 = v13;
  return a1;
}
// 7FF7053EB9CF: control flows out of bounds to 7FF7053EB9D2
// 7FF7053EB9E0: variable 'v3' is possibly undefined
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 nullsub_1(void);
// 7FF7054019C8: using guessed type char *off_7FF7054019C8;

//----- (00007FF7053EBAF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EBAF0()
{
  unsigned int v0; // esi
  unsigned int v1; // r8d
  signed __int8 v2; // bl
  signed __int8 v3; // al
  __int64 v5; // [rsp+20h] [rbp-20h] BYREF
  _DWORD *v6; // [rsp+28h] [rbp-18h]
  __int64 v7; // [rsp+30h] [rbp-10h]

  v1 = byte_7FF70540B1B0;
  LOBYTE(v1) = byte_7FF70540B1B0 - 1;
  if ( (byte_7FF70540B1B0 - 1) < 3u )
    return v1;
  sub_7FF7053E8370(&v5, "RUST_BACKTRACElibrary\\std\\src\\env.rs", 14LL);
  if ( !__OFSUB__(-v5, 1LL) )
  {
    if ( v7 == 4 )
    {
      if ( *v6 == 1819047270 )
      {
        LOBYTE(v0) = 1;
        v2 = 2;
        LOBYTE(v1) = 1;
        if ( !v5 )
          goto LABEL_12;
        goto LABEL_11;
      }
    }
    else if ( v7 == 1 && *v6 == 48 )
    {
      LOBYTE(v0) = 2;
      v2 = 3;
      LOBYTE(v1) = 2;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_11;
    }
    v2 = 1;
    v0 = 0;
    v1 = 0;
    if ( !v5 )
      goto LABEL_12;
LABEL_11:
    sub_7FF7053E5E40(v6, v5, 1LL);
    v1 = v0;
    goto LABEL_12;
  }
  LOBYTE(v1) = 2;
  v2 = 3;
LABEL_12:
  v3 = _InterlockedCompareExchange8(&byte_7FF70540B1B0, v2, 0);
  if ( v3 )
  {
    LOBYTE(v1) = 3;
    if ( v3 < 4u )
      return 0x2010003u >> (8 * v3);
  }
  return v1;
}
// 7FF7053EBB84: variable 'v0' is possibly undefined
// 7FF7053EBBA8: variable 'v1' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF7053EBAF0: using guessed type __int64 __fastcall sub_7FF7053EBAF0();
// 7FF70540B1B0: using guessed type char byte_7FF70540B1B0;

//----- (00007FF7053EBBD0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053EBBD0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int8 v4; // r8
  unsigned __int8 v5; // al
  char v6; // dl
  bool v7; // r10
  unsigned __int64 v8; // rdx
  __int64 v9; // r10
  unsigned __int8 v10; // dl
  __int64 v11; // rcx
  _BYTE *v13; // r11
  bool v14; // dl
  char v15; // r9

  v4 = *(a1 + 56);
  if ( v4 > 1u )
  {
    v5 = 0;
    v10 = 0;
LABEL_10:
    v11 = 0LL;
    return v10 + v11 + v5;
  }
  v5 = *(a1 + 58);
  if ( (v5 & 1) != 0 )
    goto LABEL_9;
  v6 = *(a1 + 16);
  LOBYTE(a4) = v6 - 5;
  if ( (v6 - 5) > 1u )
    goto LABEL_9;
  v7 = v6 == 6;
  a4 = *a1;
  v8 = a1[1];
  if ( v7 || v4 != 0 )
  {
    v9 = 0LL;
  }
  else
  {
    v9 = 2LL;
    if ( v8 <= 1 )
      sub_7FF7053FE4D0(2LL, v8, &off_7FF7054018D8);
  }
  if ( v9 == v8 )
  {
LABEL_9:
    v10 = 0;
    if ( v4 )
      goto LABEL_10;
  }
  else
  {
    v13 = (a4 + v9 + 1);
    v14 = v13 == (a4 + v8);
    v15 = *(a4 + v9);
    if ( v14 || v15 != 46 )
    {
      LOBYTE(a4) = v15 == 46;
      v10 = a4 & v14;
      if ( v4 )
        goto LABEL_10;
    }
    else
    {
      LOBYTE(a4) = *v13 == 92;
      v10 = a4 | (*v13 == 47);
      if ( v4 )
        goto LABEL_10;
    }
  }
  v4 = *(a1 + 16);
  switch ( a4 )
  {
    case 0:
      v11 = 2LL;
      break;
    case 1:
      goto LABEL_10;
    default:
      goto LABEL_9;
  }
  return v10 + v11 + v5;
}
// 7FF7054018D8: using guessed type char *off_7FF7054018D8;

//----- (00007FF7053EBD30) ----------------------------------------------------
_BYTE *__fastcall sub_7FF7053EBD30(__int64 a1)
{
  _BYTE *v1; // rdi
  unsigned __int64 v2; // rsi
  unsigned int v3; // eax
  __int128 v4; // xmm0
  __int64 v5; // rdx
  unsigned __int8 v6; // r15
  __int64 v7; // r8
  _BYTE *v8; // rcx
  __int64 v9; // r9
  unsigned __int64 v10; // rcx
  int v11; // r9d
  __int64 v12; // r9
  unsigned __int64 v13; // rcx
  __int64 v14; // r9
  __int64 v15; // rcx
  __int64 v16; // rbx
  char v17; // r13
  char v18; // r12
  __int64 v19; // rcx
  char v20; // cl
  __int64 v21; // rcx
  __int64 v22; // rcx
  bool v23; // zf
  __int128 v25; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v26[23]; // [rsp+30h] [rbp-50h]
  __int64 v27; // [rsp+68h] [rbp-18h]
  __int64 v28; // [rsp+70h] [rbp-10h]
  __int64 v29; // [rsp+78h] [rbp-8h]
  __int64 v30; // [rsp+80h] [rbp+0h]
  _BYTE *v31; // [rsp+88h] [rbp+8h] BYREF
  unsigned __int64 v32; // [rsp+90h] [rbp+10h]
  char v33; // [rsp+98h] [rbp+18h]
  _BYTE v34[39]; // [rsp+99h] [rbp+19h]
  unsigned __int8 v35; // [rsp+C0h] [rbp+40h]
  char v36; // [rsp+C1h] [rbp+41h]
  char v37; // [rsp+C2h] [rbp+42h]

  v1 = *a1;
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  if ( v3 != 6 )
  {
    *&v26[15] = *(a1 + 48);
    v4 = *(a1 + 17);
    *v26 = *(a1 + 33);
    v25 = v4;
  }
  LOBYTE(v5) = *(a1 + 58);
  v6 = *(a1 + 56);
  v7 = *(a1 + 57);
  v31 = v1;
  v32 = v2;
  v33 = v3;
  *v34 = v25;
  *&v34[16] = *v26;
  *&v34[31] = *&v26[15];
  v37 = v5;
  v35 = v6;
  v36 = v7;
  if ( v6 != 2 )
    goto LABEL_27;
  if ( v2 )
  {
    if ( v3 >= 3u )
    {
LABEL_14:
      v10 = 0LL;
      while ( 1 )
      {
        v11 = v1[v10];
        if ( v11 == 47 || v11 == 92 )
          break;
        if ( v2 == ++v10 )
        {
          v12 = 0LL;
          v10 = v2;
          if ( v2 )
            goto LABEL_21;
LABEL_23:
          v13 = v12 + v10;
          if ( v2 < v13 )
            sub_7FF7053FE4D0(v13, v2, &off_7FF705401920);
          v1 += v13;
          v2 -= v13;
          if ( !v2 )
          {
LABEL_25:
            v2 = 0LL;
            goto LABEL_26;
          }
          goto LABEL_14;
        }
      }
      v12 = 1LL;
      if ( !v10 )
        goto LABEL_23;
LABEL_21:
      if ( v10 == 1 && *v1 == 46 )
        goto LABEL_23;
    }
    else
    {
      v8 = &v1[v2];
      while ( 1 )
      {
        v9 = 0LL;
        while ( v1[v9] != 92 )
        {
          if ( v2 == ++v9 )
            goto LABEL_26;
        }
        if ( v9 )
          break;
        ++v1;
        if ( !--v2 )
        {
          v1 = v8;
          goto LABEL_25;
        }
      }
    }
LABEL_26:
    v31 = v1;
    v32 = v2;
LABEL_27:
    if ( v7 != 2 )
      return v1;
    goto LABEL_28;
  }
  v2 = 0LL;
  if ( v7 != 2 )
    return v1;
LABEL_28:
  LOBYTE(v7) = v6 != 0;
  v14 = *&v34[31];
  v15 = *&v34[31] + 1LL;
  if ( !*&v34[31] )
    v15 = 0LL;
  if ( v6 > 1u )
  {
    if ( v2 )
    {
      do
      {
        sub_7FF7053EC090(&v25, &v31, v7, v14);
        if ( BYTE8(v25) != 10 )
          break;
        v22 = v2 - v25;
        v23 = v2 == v25;
        if ( v2 < v25 )
LABEL_59:
          sub_7FF7053FE4E0(v22, v2, &off_7FF705401938);
        v32 = v2 - v25;
        v2 -= v25;
      }
      while ( !v23 );
    }
  }
  else
  {
    v16 = v5;
    v17 = v5 | (v3 < 5u);
    v18 = v7 | (v3 == 6);
    LOBYTE(v5) = v34[15];
    v28 = *&v34[15] + 4LL;
    v7 = *&v34[15] + v15 + 2;
    v29 = v7;
    v30 = *&v34[15] + v15 + 8;
    v27 = v3;
    if ( !v17 )
      goto LABEL_32;
LABEL_41:
    v3 = 0;
    if ( !v6 )
    {
LABEL_48:
      switch ( v3 )
      {
        case 0:
          v21 = v28;
          goto LABEL_43;
        case 1:
          v21 = v30;
          goto LABEL_43;
        case 2:
          v21 = 6LL;
          goto LABEL_43;
        default:
          goto LABEL_14;
      }
    }
    while ( 1 )
    {
      v21 = 0LL;
LABEL_43:
      if ( v2 <= v16 + v21 + v3 )
        break;
      sub_7FF7053EC090(&v25, &v31, v7, v14);
      if ( BYTE8(v25) != 10 )
        break;
      v22 = v2 - v25;
      if ( v2 < v25 )
        goto LABEL_59;
      v32 = v2 - v25;
      v2 -= v25;
      if ( v17 )
        goto LABEL_41;
LABEL_32:
      if ( v18 )
      {
        v19 = 0LL;
      }
      else
      {
        v19 = 2LL;
        if ( v2 < 2 )
          sub_7FF7053FE4D0(2LL, v2, &off_7FF7054018D8);
      }
      if ( v19 == v2 )
        goto LABEL_41;
      v3 = v1 + v2;
      v5 = &v1[v19 + 1];
      LOBYTE(v3) = v5 == &v1[v2];
      v20 = v1[v19];
      LOBYTE(v7) = v3 | (v20 != 46);
      if ( v7 )
      {
        LOBYTE(v3) = (v20 == 46) & v3;
        if ( !v6 )
          goto LABEL_48;
      }
      else
      {
        v3 = *v5;
        LOBYTE(v3) = v3 == 92 || v3 == 47;
        if ( !v6 )
          goto LABEL_48;
      }
    }
  }
  return v1;
}
// 7FF7053EBE78: variable 'v7' is possibly undefined
// 7FF7053EBEAA: variable 'v5' is possibly undefined
// 7FF7053EBF92: variable 'v14' is possibly undefined
// 7FF7054018D8: using guessed type char *off_7FF7054018D8;
// 7FF705401920: using guessed type char *off_7FF705401920;
// 7FF705401938: using guessed type char *off_7FF705401938;

//----- (00007FF7053EC090) ----------------------------------------------------
char __fastcall sub_7FF7053EC090(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // r10
  _BYTE *v9; // rcx
  unsigned __int8 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r11
  _BYTE *v13; // rdi
  int v14; // ebx
  unsigned __int64 v15; // rdx
  char result; // al

  v6 = sub_7FF7053EBBD0(a2, a2, a3, a4);
  v7 = *(a2 + 8);
  if ( v6 > v7 )
    sub_7FF7053FE4D0(v6, v7, &off_7FF7054018F0);
  v8 = *a2;
  v9 = (*a2 + v6);
  if ( v6 == v7 )
  {
    v10 = *(a2 + 16);
    v11 = 0LL;
  }
  else
  {
    v10 = *(a2 + 16);
    v12 = v6 - v7 + 1;
    v13 = (v7 + v8 - 1);
    v11 = 0LL;
    if ( v10 >= 3u )
    {
      while ( 1 )
      {
        v14 = *v13;
        if ( v14 == 47 || v14 == 92 )
          break;
        ++v12;
        --v13;
        if ( v12 == 1 )
          goto LABEL_14;
      }
    }
    else
    {
      while ( *v13 != 92 )
      {
        ++v12;
        --v13;
        if ( v12 == 1 )
          goto LABEL_14;
      }
    }
    v6 = v6 - v12 + 1;
    if ( v6 > v7 )
      sub_7FF7053FE4D0(v6, v7, &off_7FF705401908);
    v11 = 1LL;
    v9 = (v6 + v8);
  }
LABEL_14:
  v15 = v7 - v6;
  if ( v15 )
  {
    if ( v15 == 2 )
    {
      result = ((*v9 ^ 0x2E | v9[1] ^ 0x2E) == 0) ^ 9;
    }
    else
    {
      result = 9;
      if ( v15 == 1 && *v9 == 46 )
        result = 3 * (v10 >= 3u) + 7;
    }
  }
  else
  {
    result = 10;
  }
  *a1 = v15 + v11;
  *(a1 + 8) = result;
  *(a1 + 16) = v9;
  *(a1 + 24) = v15;
  return result;
}
// 7FF7054018F0: using guessed type char *off_7FF7054018F0;
// 7FF705401908: using guessed type char *off_7FF705401908;

//----- (00007FF7053EC1D0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053EC1D0(__int64 a1, __int64 a2)
{
  unsigned __int8 v2; // bl
  unsigned __int8 v4; // r15
  unsigned int v5; // r8d
  __int64 v6; // r11
  __int64 v7; // rdx
  char v9; // r13
  __int64 v10; // rax
  unsigned __int64 v11; // rax
  _BYTE *v12; // rsi
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // r10
  _BYTE *v16; // r10
  unsigned __int64 v17; // r11
  int v18; // r9d
  __int64 v19; // r10
  char v20; // di
  char v21; // r10
  int v22; // r10d
  unsigned __int64 v23; // r10
  unsigned __int64 v24; // r10
  __int128 v25; // xmm0
  __int64 v26; // [rsp+30h] [rbp+0h]

  v2 = *(a2 + 56);
  if ( v2 == 3 )
    goto LABEL_5;
  v4 = *(a2 + 57);
  v5 = *(a2 + 16);
  v6 = *(a2 + 48);
  v7 = v6 + 1;
  if ( !v6 )
    v7 = 0LL;
  if ( v4 == 3 || v2 > v4 )
  {
LABEL_5:
    *a1 = 10;
    return a1;
  }
  v9 = *(a2 + 58);
  v10 = *(a2 + 32);
  v26 = v10 + v7 + 8;
  v11 = v10 + 4;
  v12 = *a2;
  v13 = *(a2 + 8);
  v14 = v13;
  while ( 1 )
  {
    if ( !v2 )
    {
      v15 = v11;
      switch ( v5 )
      {
        case 0u:
          goto LABEL_9;
        case 1u:
          v15 = v26;
LABEL_9:
          if ( v15 )
            goto LABEL_49;
          *(a2 + 56) = 1;
          v2 = 1;
          goto LABEL_11;
        case 2u:
LABEL_49:
          *(a2 + 56) = 1;
          switch ( v5 )
          {
            case 0u:
              v24 = v11;
              goto LABEL_56;
            case 1u:
              v24 = v26;
              goto LABEL_56;
            case 2u:
              v24 = 6LL;
LABEL_56:
              if ( v24 <= v14 )
              {
                switch ( v5 )
                {
                  case 0u:
                    goto LABEL_60;
                  case 1u:
                    v11 = v26;
                    goto LABEL_60;
                  case 2u:
                    v11 = 6LL;
LABEL_60:
                    if ( v14 < v11 )
                      sub_7FF7053FE4D0(v11, v14, &off_7FF705401968);
                    *a2 = &v12[v11];
                    *(a2 + 8) = v14 - v11;
                    *(a1 + 32) = *(a2 + 48);
                    v25 = *(a2 + 17);
                    *(a1 + 17) = *(a2 + 33);
                    *(a1 + 1) = v25;
                    *a1 = v5;
                    *(a1 + 40) = v12;
                    *(a1 + 48) = v24;
                    return a1;
                  default:
                    goto LABEL_27;
                }
              }
              sub_7FF7053FE4E0(v24, v14, &off_7FF705401950);
            default:
              goto LABEL_27;
          }
          goto LABEL_27;
        default:
          goto LABEL_27;
      }
    }
    if ( v2 != 1 )
    {
      if ( !v13 )
      {
        *(a2 + 56) = 3;
        goto LABEL_5;
      }
      v17 = 0LL;
      if ( v5 >= 3u )
      {
        while ( 1 )
        {
          v18 = v12[v17];
          if ( v18 == 47 || v18 == 92 )
            break;
          if ( v13 == ++v17 )
          {
LABEL_23:
            v19 = 0LL;
            v17 = v13;
            goto LABEL_37;
          }
        }
      }
      else
      {
        while ( v12[v17] != 92 )
        {
          if ( v13 == ++v17 )
            goto LABEL_23;
        }
      }
      v19 = 1LL;
      if ( v17 )
      {
LABEL_37:
        if ( v17 == 2 )
        {
          v20 = ((*v12 ^ 0x2E | v12[1] ^ 0x2E) == 0) ^ 9;
        }
        else
        {
          v20 = 9;
          if ( v17 == 1 )
          {
            v20 = 3 * (v5 >= 3) + 7;
            if ( *v12 != 46 )
              v20 = 9;
          }
        }
      }
      else
      {
        v20 = 10;
      }
      v23 = v17 + v19;
      v14 = v13 - v23;
      if ( v13 < v23 )
        sub_7FF7053FE4D0(v23, v13, &off_7FF7054019B0);
      v16 = &v12[v23];
      *a2 = v16;
      *(a2 + 8) = v14;
      v2 = 2;
      v13 = v14;
      if ( v20 != 10 )
      {
        *a1 = v20;
        *(a1 + 8) = v12;
        *(a1 + 16) = v17;
        return a1;
      }
      goto LABEL_12;
    }
    *(a2 + 56) = 2;
    if ( (v9 & 1) != 0 )
      break;
    v2 = 2;
    if ( v5 >= 3 )
    {
LABEL_27:
      if ( v5 != 5 )
      {
        if ( v5 != 6 )
        {
          *a1 = 6;
          return a1;
        }
        if ( v13 )
        {
          v21 = *v12;
          if ( v13 == 1 || v21 != 46 )
          {
            if ( v21 == 46 && v13 == 1 )
              goto LABEL_47;
          }
          else
          {
            v22 = v12[1];
            if ( v22 == 47 || v22 == 92 )
            {
LABEL_47:
              if ( !v14 )
                sub_7FF7053FE4D0(1LL, 0LL, &off_7FF705401980);
              *a2 = v12 + 1;
              *(a2 + 8) = v14 - 1;
              *a1 = 7;
              return a1;
            }
          }
        }
        else
        {
          v13 = 0LL;
        }
      }
    }
LABEL_11:
    v16 = v12;
LABEL_12:
    v12 = v16;
    if ( v2 > v4 )
      goto LABEL_5;
  }
  if ( !v14 )
    sub_7FF7053FE4D0(1LL, 0LL, &off_7FF705401998);
  *a2 = v12 + 1;
  *(a2 + 8) = v14 - 1;
  *a1 = 6;
  return a1;
}
// 7FF7053EC31A: conditional instruction was optimized away because rdx.8!=0
// 7FF705401950: using guessed type char *off_7FF705401950;
// 7FF705401968: using guessed type char *off_7FF705401968;
// 7FF705401980: using guessed type char *off_7FF705401980;
// 7FF705401998: using guessed type char *off_7FF705401998;
// 7FF7054019B0: using guessed type char *off_7FF7054019B0;

//----- (00007FF7053EC5C0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053EC5C0(__int64 a1, __int64 *a2)
{
  return sub_7FF7053EDB70(*(a1 + 8), *(a1 + 16), a2);
}

//----- (00007FF7053EC5E0) ----------------------------------------------------
#error "7FF7053EC6BE: switch analysis failed: switch information is incomplete or incorrect (funcsize=75)"

//----- (00007FF7053EC720) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_7FF7053EC720(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r8
  _BYTE v10[536]; // [rsp-C8h] [rbp-148h] BYREF
  _BYTE v11[23]; // [rsp+150h] [rbp+D0h]
  char v12; // [rsp+170h] [rbp+F0h] BYREF
  _BYTE v13[39]; // [rsp+171h] [rbp+F1h]

  sub_7FF7053F0E90(v10, a1, a2);
  switch ( v12 )
  {
    case 0:
    case 3:
      v7 = *&v13[15] + 4LL;
      goto LABEL_11;
    case 1:
      v8 = *&v13[31] + 1LL;
      if ( !*&v13[31] )
        v8 = 0LL;
      v7 = v8 + *&v13[15] + 8;
      goto LABEL_11;
    case 2:
      v7 = 6LL;
      goto LABEL_11;
    case 4:
      v9 = *&v13[31] + 1LL;
      if ( !*&v13[31] )
        v9 = 0LL;
      v7 = v9 + *&v13[15] + 2;
      goto LABEL_11;
    case 5:
      v7 = 2LL;
LABEL_11:
      if ( a2 < v7 )
        sub_7FF7053FE4D0(v7, a2, &off_7FF7054018B8);
      return;
    case 6:
      break;
  }
  *&v11[15] = *&v13[31];
  *v11 = *&v13[16];
  *&v10[520] = *v13;
  sub_7FF7053F0E90(&v12, a3, a4);
  JUMPOUT(0x7FF7053EC85ELL);
}
// 7FF7053ECB6F: positive sp value 238 has been found
// 7FF7053EC85A: control flows out of bounds to 7FF7053EC85E
// 7FF7054018B8: using guessed type char *off_7FF7054018B8;

//----- (00007FF7053ECB90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053ECB90(UINT a1)
{
  sub_7FF7053E7D30();
  sub_7FF7053F08F0(a1);
}

//----- (00007FF7053ECBB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053ECBB0(char **a1)
{
  char *v1; // rax
  char v2; // cl
  __int64 v3; // rax
  __int64 v4; // rcx
  int v5; // eax
  __int64 *v6; // rdx
  signed __int64 v7; // rax
  signed __int64 v8; // rtt
  char v9; // al
  __int64 result; // rax
  __int128 v11; // [rsp+20h] [rbp-30h]
  __int128 v12; // [rsp+30h] [rbp-20h]
  char v13; // [rsp+47h] [rbp-9h] BYREF
  __int64 v14; // [rsp+48h] [rbp-8h]

  v14 = -2LL;
  v1 = *a1;
  v2 = **a1;
  *v1 = 0;
  if ( v2 != 1 )
    sub_7FF7053FE090(&off_7FF705401A30);
  v13 = 0;
  if ( dword_7FF70540B188 == 3 || (sub_7FF7053FD75B(&v13), !v13) )
  {
    v3 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
    v4 = *(v3 + 8);
    if ( v4 )
    {
      if ( v4 == qword_7FF70540B150 )
      {
LABEL_5:
        if ( dword_7FF70540B158 == -1 )
          goto LABEL_17;
        v5 = dword_7FF70540B158 + 1;
LABEL_13:
        dword_7FF70540B158 = v5;
        *&v11 = 0LL;
        *(&v11 + 1) = 1LL;
        *&v12 = 0LL;
        BYTE8(v12) = 0;
        BYTE13(v12) = 0;
        *(&v12 + 9) = 0;
        if ( qword_7FF70540B160 )
          sub_7FF7053FE030(&off_7FF705401680);
        qword_7FF70540B160 = -1LL;
        sub_7FF7053E6CA0(&xmmword_7FF70540B168);
        xmmword_7FF70540B178 = v12;
        xmmword_7FF70540B168 = v11;
        ++qword_7FF70540B160;
        if ( !--dword_7FF70540B158 )
        {
          qword_7FF70540B150 = 0LL;
          v9 = byte_7FF70540B15C;
          byte_7FF70540B15C = 0;
          if ( v9 == 2 )
            WakeByAddressSingle(&byte_7FF70540B15C);
        }
        goto LABEL_17;
      }
    }
    else
    {
      v6 = (v3 + 8);
      v7 = qword_7FF70540B1F8;
      do
      {
        if ( v7 == -1 )
          sub_7FF7053FD680();
        v4 = v7 + 1;
        v8 = v7;
        v7 = _InterlockedCompareExchange64(&qword_7FF70540B1F8, v7 + 1, v7);
      }
      while ( v8 != v7 );
      *v6 = v4;
      if ( v4 == qword_7FF70540B150 )
        goto LABEL_5;
    }
    if ( _InterlockedCompareExchange8(&byte_7FF70540B15C, 1, 0) )
      goto LABEL_17;
    qword_7FF70540B150 = v4;
    v5 = 1;
    goto LABEL_13;
  }
LABEL_17:
  result = dword_7FF70540B210;
  if ( dword_7FF70540B210 == 3 )
    return qword_7FF70540B208();
  return result;
}
// 7FF7053ECBEB: conditional instruction was optimized away because %var_9.1==0
// 7FF7053ECCE0: variable 'v12' is possibly undefined
// 7FF705401680: using guessed type char *off_7FF705401680;
// 7FF705401A30: using guessed type char *off_7FF705401A30;
// 7FF70540B150: using guessed type __int64 qword_7FF70540B150;
// 7FF70540B158: using guessed type int dword_7FF70540B158;
// 7FF70540B15C: using guessed type char byte_7FF70540B15C;
// 7FF70540B160: using guessed type __int64 qword_7FF70540B160;
// 7FF70540B168: using guessed type __int128 xmmword_7FF70540B168;
// 7FF70540B178: using guessed type __int128 xmmword_7FF70540B178;
// 7FF70540B188: using guessed type int dword_7FF70540B188;
// 7FF70540B1F8: using guessed type __int64 qword_7FF70540B1F8;
// 7FF70540B208: using guessed type __int64 (*qword_7FF70540B208)(void);
// 7FF70540B210: using guessed type int dword_7FF70540B210;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053ECE00) ----------------------------------------------------
__int64 __fastcall sub_7FF7053ECE00(_QWORD **a1)
{
  _QWORD *v1; // rdx
  _BYTE *v2; // rcx
  __int64 result; // rax
  _BYTE v4[19]; // [rsp+2Dh] [rbp-13h]

  v1 = *a1;
  v2 = **a1;
  result = v1[1];
  *v1 = 0LL;
  if ( !v2 )
    sub_7FF7053FE090(&off_7FF705401AB0);
  *v2 = 1;
  *&v4[3] = 0LL;
  *result = 0LL;
  *(result + 8) = 0;
  *(result + 12) = 0;
  *(result + 13) = *v4;
  *(result + 28) = 0;
  *(result + 32) = 1LL;
  *(result + 40) = 0LL;
  *(result + 48) = 0;
  *(result + 53) = 0;
  *(result + 49) = 0;
  return result;
}
// 7FF7053ECE40: variable 'v4' is possibly undefined
// 7FF705401AB0: using guessed type char *off_7FF705401AB0;

//----- (00007FF7053ECE80) ----------------------------------------------------
__int64 __fastcall sub_7FF7053ECE80(__int64 **a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 result; // rax

  v3 = **a1;
  **a1 = 0LL;
  if ( !v3 )
    sub_7FF7053FE090(&off_7FF705401AB0);
  nullsub_1(a1, a2, a3);
  result = sub_7FF7053E5E30(1024LL, 1LL);
  if ( !result )
    sub_7FF7053FDFF0(1LL, 1024LL, &off_7FF705401218);
  *v3 = 0LL;
  *(v3 + 8) = 0;
  *(v3 + 12) = 0;
  *(v3 + 16) = 0LL;
  *(v3 + 24) = 1024LL;
  *(v3 + 32) = result;
  *(v3 + 40) = 0LL;
  *(v3 + 48) = 0;
  *(v3 + 53) = 0;
  *(v3 + 49) = 0;
  return result;
}
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD);
// 7FF705401218: using guessed type char *off_7FF705401218;
// 7FF705401AB0: using guessed type char *off_7FF705401AB0;

//----- (00007FF7053ECF20) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char *sub_7FF7053ECF20()
{
  if ( _InterlockedCompareExchange8(&byte_7FF70540B1B1, 1, 0) )
  {
    sub_7FF7053FD890(&byte_7FF70540B1B1);
    if ( !(2 * qword_7FF70540B1E0) )
      return &byte_7FF70540B1B1;
LABEL_5:
    sub_7FF7053FD820();
    return &byte_7FF70540B1B1;
  }
  if ( 2 * qword_7FF70540B1E0 )
    goto LABEL_5;
  return &byte_7FF70540B1B1;
}
// 7FF70540B1B1: using guessed type char byte_7FF70540B1B1;
// 7FF70540B1E0: using guessed type __int64 qword_7FF70540B1E0;

//----- (00007FF7053ECF90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053ECF90(__int64 a1, __int64 (__fastcall *a2)(__int64, _QWORD *), char a3)
{
  _QWORD v4[6]; // [rsp+28h] [rbp-48h] BYREF
  _QWORD v5[2]; // [rsp+58h] [rbp-18h] BYREF
  char v6; // [rsp+6Fh] [rbp-1h] BYREF

  v6 = a3;
  v5[0] = &v6;
  v5[1] = sub_7FF7053ECFF0;
  v4[0] = &unk_7FF705401270;
  v4[1] = 1LL;
  v4[4] = 0LL;
  v4[2] = v5;
  v4[3] = 1LL;
  return a2(a1, v4);
}

//----- (00007FF7053ECFF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053ECFF0(char *a1, _QWORD *a2)
{
  char v3; // bl
  DWORD64 P1Home; // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  unsigned __int64 v7; // rsi
  ULONG64 i; // r15
  PRUNTIME_FUNCTION v9; // rax
  struct _RUNTIME_FUNCTION *v10; // rbx
  DWORD64 v11; // r12
  char v12; // si
  char result; // al
  int HandlerData; // [rsp+28h] [rbp-58h]
  int ContextPointers; // [rsp+38h] [rbp-48h]
  CONTEXT ContextRecord; // [rsp+40h] [rbp-40h] BYREF
  PVOID v17[3]; // [rsp+518h] [rbp+498h] BYREF
  unsigned __int64 EstablisherFrame[10]; // [rsp+530h] [rbp+4B0h] BYREF
  __int128 v19; // [rsp+580h] [rbp+500h]
  DWORD64 P4Home; // [rsp+590h] [rbp+510h]
  _QWORD v21[4]; // [rsp+5A0h] [rbp+520h] BYREF
  char v22; // [rsp+5C0h] [rbp+540h]
  int v23; // [rsp+5C8h] [rbp+548h] BYREF
  unsigned __int64 v24; // [rsp+5D0h] [rbp+550h]
  ULONG64 v25; // [rsp+5D8h] [rbp+558h]
  DWORD64 Rsp; // [rsp+5E0h] [rbp+560h]
  __int64 v27; // [rsp+5E8h] [rbp+568h] BYREF
  DWORD64 v28; // [rsp+5F0h] [rbp+570h] BYREF
  __int128 v29; // [rsp+5F8h] [rbp+578h]
  DWORD64 v30; // [rsp+608h] [rbp+588h]
  char v31; // [rsp+610h] [rbp+590h]
  _QWORD v32[2]; // [rsp+618h] [rbp+598h] BYREF
  DWORD64 v33; // [rsp+628h] [rbp+5A8h]
  unsigned __int64 ImageBase; // [rsp+630h] [rbp+5B0h] BYREF
  __int64 v35; // [rsp+638h] [rbp+5B8h]
  _QWORD *v36; // [rsp+640h] [rbp+5C0h]
  char v37; // [rsp+64Bh] [rbp+5CBh] BYREF
  char v38; // [rsp+64Ch] [rbp+5CCh] BYREF
  char v39; // [rsp+64Dh] [rbp+5CDh] BYREF
  char v40; // [rsp+64Eh] [rbp+5CEh] BYREF
  char v41; // [rsp+64Fh] [rbp+5CFh] BYREF
  __int64 v42; // [rsp+650h] [rbp+5D0h]

  v42 = -2LL;
  v3 = *a1;
  v40 = *a1;
  sub_7FF7053E80C0(&ContextRecord);
  P1Home = ContextRecord.P1Home;
  if ( __OFSUB__(-ContextRecord.P1Home, 1LL) )
  {
    if ( (ContextRecord.P2Home & 3) == 1 )
    {
      v33 = ContextRecord.P2Home - 1;
      v35 = *(ContextRecord.P2Home - 1);
      v36 = *(ContextRecord.P2Home + 7);
      if ( *v36 )
        (*v36)(v35);
      v5 = v36[1];
      if ( v5 )
        sub_7FF7053E5E40(v35, v5, v36[2]);
      sub_7FF7053E5E40(v33, 24LL, 8LL);
    }
  }
  else
  {
    P4Home = ContextRecord.P4Home;
    v19 = *&ContextRecord.P2Home;
  }
  LOBYTE(v35) = v3;
  v31 = v3;
  v28 = P1Home;
  v29 = v19;
  v30 = P4Home;
  v6 = *a2;
  v36 = a2;
  if ( (*(a2[1] + 24LL))(v6, aStackBacktrace, 17LL) )
  {
LABEL_23:
    v12 = 1;
    result = 1;
    if ( !(2 * P1Home) )
      return result;
    goto LABEL_24;
  }
  v21[0] = v36;
  v21[3] = 0LL;
  v22 = v35;
  v21[1] = &v28;
  v21[2] = &off_7FF705401B48;
  v41 = 0;
  v27 = 0LL;
  v37 = 1;
  v39 = v35;
  v7 = 0LL;
  memset(&ContextRecord, 0, sizeof(ContextRecord));
  RtlCaptureContext(&ContextRecord);
  for ( i = ContextRecord.Rip; ; i = ContextRecord.Rip )
  {
    ImageBase = 0LL;
    v9 = RtlLookupFunctionEntry(i, &ImageBase, 0LL);
    if ( !v9 )
      break;
    v10 = v9;
    v23 = 0;
    v24 = ImageBase;
    v25 = i;
    Rsp = ContextRecord.Rsp;
    if ( v7 >= 0x65 && v40 == 0 )
      break;
    v38 = 0;
    EstablisherFrame[0] = &v38;
    EstablisherFrame[1] = &v40;
    EstablisherFrame[2] = &v39;
    EstablisherFrame[3] = &v27;
    EstablisherFrame[4] = &v37;
    EstablisherFrame[5] = v21;
    EstablisherFrame[6] = &v41;
    EstablisherFrame[7] = &v23;
    sub_7FF7053F1C00(1, &v23, EstablisherFrame, &unk_7FF7054021E0);
    if ( !v38 && v39 == 1 )
    {
      v32[0] = v21;
      v32[1] = 0LL;
      EstablisherFrame[0] = 3LL;
      v17[0] = 2;
      v41 = sub_7FF7053EF930(v32, v25, EstablisherFrame, v17, 0, HandlerData, 0, ContextPointers);
      ++*(v32[0] + 24LL);
    }
    if ( v41 )
      break;
    v11 = ContextRecord.Rsp;
    v17[0] = 0LL;
    EstablisherFrame[0] = 0LL;
    RtlVirtualUnwind(0, ImageBase, i, v10, &ContextRecord, v17, EstablisherFrame, 0LL);
    if ( !ContextRecord.Rip || ContextRecord.Rip == i && ContextRecord.Rsp == v11 )
      break;
    ++v7;
  }
  if ( v41 || !v35 && (*(v36[1] + 24LL))(*v36, aNoteSomeDetail, 88LL) )
  {
    P1Home = v28;
    goto LABEL_23;
  }
  P1Home = v28;
  v12 = 0;
  result = 0;
  if ( 2 * v28 )
  {
LABEL_24:
    sub_7FF7053E5E40(v29, P1Home, 1LL);
    return v12;
  }
  return result;
}
// 7FF7053ED31F: variable 'HandlerData' is possibly undefined
// 7FF7053ED31F: variable 'ContextPointers' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705401B48: using guessed type __int64 (__fastcall *off_7FF705401B48)();

//----- (00007FF7053ED550) ----------------------------------------------------
char __fastcall sub_7FF7053ED550(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // r9

  v3 = 0LL;
  if ( !__OFSUB__(0LL, *a1) )
    v3 = a1;
  return sub_7FF7053ED890(a2, a3, *(a1 + 32), v3);
}

//----- (00007FF7053ED570) ----------------------------------------------------
_BYTE *__fastcall sub_7FF7053ED570(__int64 a1, __int64 a2)
{
  _BYTE *result; // rax
  __int64 *v5; // rbx
  __int64 v6; // rax
  _BYTE *v7; // r14
  __int64 *v8; // rdx
  __int64 v9; // r8
  __int64 v10; // rbx
  __int64 v11; // r14
  unsigned __int64 v12; // r15
  __int64 v13; // r12
  __int64 v14; // rax
  __int64 v15; // rbx
  unsigned __int64 v16; // r14
  char *v17; // rbx
  size_t v18; // r14
  char *v19; // r15
  char v20; // al
  int v21; // [rsp+38h] [rbp-48h]
  __m256i v22; // [rsp+40h] [rbp-40h] BYREF
  __int128 v23; // [rsp+60h] [rbp-20h]
  __int64 v24; // [rsp+70h] [rbp-10h]
  char **v25; // [rsp+78h] [rbp-8h] BYREF
  __m256i Buf2; // [rsp+80h] [rbp+0h]
  __int128 v27; // [rsp+A0h] [rbp+20h]
  __int64 v28; // [rsp+B0h] [rbp+30h]
  __int64 v29; // [rsp+B8h] [rbp+38h]
  unsigned __int64 v30; // [rsp+C0h] [rbp+40h]
  __int64 v31; // [rsp+C8h] [rbp+48h] BYREF
  _BOOL8 v32; // [rsp+D0h] [rbp+50h]
  __int64 v33; // [rsp+D8h] [rbp+58h]

  v33 = -2LL;
  **a1 = 1;
  if ( !**(a1 + 8) )
  {
    v15 = *(a2 + 32);
    v16 = *(a2 + 40);
    sub_7FF7053FA930(&v25, v15, v16);
    if ( (v25 & 1) != 0 || (sub_7FF7053F7DD9(&v25, Buf2.m256i_i64[0], Buf2.m256i_i64[1]), v25 == 2) )
    {
      sub_7FF7053FA930(&v25, v15, v16);
      if ( (v25 & 1) != 0 )
        goto LABEL_2;
      v18 = Buf2.m256i_u64[1];
      v17 = Buf2.m256i_i64[0];
    }
    else
    {
      v17 = Buf2.m256i_i64[3];
      if ( !Buf2.m256i_i64[3] )
        goto LABEL_2;
      v18 = v27;
    }
    result = sub_7FF7053E6E30(aRustEndShortBa, 0x1AuLL, v17, v18);
    v19 = *(a1 + 16);
    if ( result )
    {
      *v19 = 1;
      return result;
    }
    v20 = *v19;
    if ( *v19 )
    {
      result = sub_7FF7053E6E30(aRustBeginShort, 0x1CuLL, v17, v18);
      if ( result )
      {
        *v19 = 0;
        return result;
      }
      v20 = *v19;
    }
    if ( (v20 & 1) == 0 )
      ++**(a1 + 24);
  }
LABEL_2:
  result = *(a1 + 16);
  if ( *result )
  {
    v5 = *(a1 + 24);
    v6 = *v5;
    if ( *v5 )
    {
      v7 = *(a1 + 32);
      if ( !*v7 )
      {
        v8 = **(a1 + 40);
        v9 = aS;
        if ( v6 == 1 )
          v9 = 1LL;
        v31 = v9;
        v32 = v6 != 1;
        v22.m256i_i64[0] = v5;
        v22.m256i_i64[1] = sub_7FF7053FC390;
        v22.m256i_i64[2] = &v31;
        v22.m256i_i64[3] = sub_7FF7053E5F90;
        v25 = &off_7FF705401C20;
        Buf2.m256i_i64[0] = 3LL;
        Buf2.m256i_i64[1] = &v22;
        *&Buf2.m256i_u64[2] = 2uLL;
        sub_7FF7053F9220(*v8, v8[1], &v25);
      }
      *v7 = 0;
      *v5 = 0LL;
    }
    v31 = *(a1 + 40);
    v32 = 0LL;
    v10 = *(*(a1 + 56) + 16LL);
    v11 = *(a2 + 32);
    v12 = *(a2 + 40);
    sub_7FF7053FA930(&v25, v11, v12);
    v13 = 2LL;
    v14 = 2LL;
    if ( (v25 & 1) == 0 )
    {
      sub_7FF7053F7DD9(&v25, Buf2.m256i_i64[0], Buf2.m256i_i64[1]);
      v14 = v25;
      if ( v25 != 2 )
      {
        v24 = v28;
        v23 = v27;
        v22 = Buf2;
      }
    }
    v25 = v14;
    Buf2 = v22;
    v27 = v23;
    v28 = v24;
    v29 = v11;
    v30 = v12;
    if ( (*a2 & 1) != 0 )
    {
      *&v22.m256i_u64[1] = *(a2 + 8);
      v13 = 1LL;
    }
    v22.m256i_i64[0] = v13;
    **(a1 + 48) = sub_7FF7053EF930(&v31, v10, &v25, v22.m256i_i8, *(a2 + 24), *(a2 + 28), 0, v21);
    result = v31;
    ++*(v31 + 24);
  }
  return result;
}
// 7FF7053ED743: variable 'v21' is possibly undefined
// 7FF705401BFE: using guessed type char aS;
// 7FF705401C20: using guessed type char *off_7FF705401C20;

//----- (00007FF7053ED880) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053ED880(__int64 *a1)
{
  sub_7FF7053EF390(a1);
}

//----- (00007FF7053ED890) ----------------------------------------------------
char __fastcall sub_7FF7053ED890(__int64 *a1, __int64 a2, char a3, __int64 a4)
{
  unsigned __int16 *v8; // rdx
  unsigned __int64 v9; // r8
  unsigned __int8 *v10; // rcx
  unsigned __int64 v11; // rdi
  unsigned __int8 v12; // al
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  char result; // al
  char v16; // bl
  __int128 v17; // [rsp+28h] [rbp-58h] BYREF
  _QWORD v18[4]; // [rsp+38h] [rbp-48h] BYREF
  _UNKNOWN **v19; // [rsp+58h] [rbp-28h] BYREF
  __int128 v20; // [rsp+60h] [rbp-20h]
  __int64 v21; // [rsp+70h] [rbp-10h]
  __int64 v22; // [rsp+78h] [rbp-8h]
  unsigned __int64 v23; // [rsp+88h] [rbp+8h]
  unsigned __int8 *v24; // [rsp+90h] [rbp+10h]
  __int64 v25; // [rsp+98h] [rbp+18h]

  v25 = -2LL;
  v8 = *(a2 + 8);
  v9 = *(a2 + 16);
  if ( *a2 == 1 )
  {
    sub_7FF7053EB920(&v19, v8, v9);
    v23 = v19;
    v11 = *(&v20 + 1);
    v10 = v20;
    v24 = v20;
    if ( a3 )
      goto LABEL_13;
  }
  else
  {
    sub_7FF7053FA930(&v19, v8, v9);
    v11 = 9LL;
    if ( !v19 )
      v11 = *(&v20 + 1);
    v10 = aUnknown;
    if ( !v19 )
      v10 = v20;
    v23 = 0x8000000000000000uLL;
    v24 = v10;
    if ( a3 )
      goto LABEL_13;
  }
  v12 = sub_7FF7053EC5E0(v10, v11);
  v10 = v24;
  if ( (v12 & (a4 != 0)) == 0 )
    goto LABEL_13;
  sub_7FF7053EC720(v24, v11, *(a4 + 8), *(a4 + 16));
  v10 = v24;
  if ( !v13 )
    goto LABEL_13;
  sub_7FF7053FA930(&v19, v13, v14);
  if ( v19 == 1 )
  {
    v10 = v24;
LABEL_13:
    result = sub_7FF7053EE060(v10, v11, a1);
    goto LABEL_14;
  }
  v17 = v20;
  v18[0] = "\\";
  v18[1] = sub_7FF7053FA580;
  v18[2] = &v17;
  v18[3] = sub_7FF7053E5F90;
  v19 = &off_7FF705401C60;
  *&v20 = 2LL;
  v22 = 0LL;
  *(&v20 + 1) = v18;
  v21 = 2LL;
  result = sub_7FF7053F9220(*a1, a1[1], &v19);
LABEL_14:
  if ( 2 * v23 )
  {
    v16 = result;
    sub_7FF7053E5E40(v24, v23, 1LL);
    return v16;
  }
  return result;
}
// 7FF7053ED954: variable 'v13' is possibly undefined
// 7FF7053ED960: variable 'v14' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF7053EC5E0: using guessed type __int64 __fastcall sub_7FF7053EC5E0(_QWORD, _QWORD);
// 7FF705401C60: using guessed type _UNKNOWN *off_7FF705401C60;

//----- (00007FF7053EDA70) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void *__fastcall sub_7FF7053EDA70(unsigned __int64 *a1, unsigned int a2)
{
  size_t v3; // rdi
  __int64 v4; // rbx
  void *result; // rax
  int Src; // [rsp+34h] [rbp+4h] BYREF

  Src = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(Src) = (a2 >> 18) & 7 | 0xF0;
        BYTE1(Src) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(Src) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(Src) = a2 & 0x3F | 0x80;
        v3 = 4LL;
      }
      else
      {
        LOBYTE(Src) = (a2 >> 12) | 0xE0;
        BYTE1(Src) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(Src) = a2 & 0x3F | 0x80;
        v3 = 3LL;
      }
    }
    else
    {
      LOBYTE(Src) = (a2 >> 6) | 0xC0;
      BYTE1(Src) = a2 & 0x3F | 0x80;
      v3 = 2LL;
    }
  }
  else
  {
    LOBYTE(Src) = a2;
    v3 = 1LL;
  }
  v4 = a1[2];
  if ( v3 > *a1 - v4 )
  {
    sub_7FF7053FD5A0(a1, v4, v3, 1LL, 1LL);
    v4 = a1[2];
  }
  result = memcpy((v4 + a1[1]), &Src, v3);
  a1[2] = v3 + v4;
  return result;
}

//----- (00007FF7053EDB70) ----------------------------------------------------
__int64 __fastcall sub_7FF7053EDB70(__int64 a1, unsigned __int64 a2, __int64 *a3)
{
  unsigned int v3; // ebx
  char *v7; // r13
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r15
  char *v10; // r8
  char *v11; // r8
  char *v12; // rax
  __int64 v13; // r9
  char v14; // r10
  unsigned int v15; // eax
  char *v16; // r8
  unsigned __int64 v17; // r15
  _QWORD v19[6]; // [rsp+20h] [rbp-40h] BYREF
  _QWORD v20[2]; // [rsp+50h] [rbp-10h] BYREF
  __int16 v21; // [rsp+66h] [rbp+6h] BYREF

  LOBYTE(v3) = 1;
  if ( sub_7FF7053F9DC0(a3) )
    return v3;
  v7 = (a1 + a2);
  v8 = 0LL;
LABEL_3:
  if ( v8 != a2 )
  {
    v9 = v8;
    v10 = (a1 + v8);
    while ( 1 )
    {
      v12 = v10 + 1;
      v14 = *v10;
      v13 = 1LL;
      if ( *v10 < 0 )
      {
        if ( v14 < 0xE0u )
        {
          v11 = v10 + 2;
          if ( v12 != v7 )
            v12 = v11;
          v13 = 2LL;
        }
        else if ( v14 == -19 )
        {
          if ( v12 == v7 || v10 + 2 == v7 )
            goto LABEL_27;
          v15 = v10[1];
          if ( v15 > 0x9F )
          {
            v21 = (v10[2] & 0x3F) + ((v15 & 0x1F) << 6) - 10240;
            if ( v9 < v8 )
              sub_7FF7053FE4F0(v8, v9, &off_7FF705401C80);
            if ( v9 > a2 )
              sub_7FF7053FE4E0(v9, a2, &off_7FF705401C80);
            if ( sub_7FF7053EDDA0(a3, (a1 + v8), v9 - v8) )
              return v3;
            v20[0] = &v21;
            v20[1] = sub_7FF7053FBED0;
            v19[0] = &off_7FF705401CA0;
            v19[1] = 2LL;
            v19[4] = 0LL;
            v19[2] = v20;
            v19[3] = 1LL;
            if ( sub_7FF7053F9220(*a3, a3[1], v19) )
              return v3;
            v17 = v9 + 3;
            v8 = v17;
            if ( v17 > a2 )
              sub_7FF7053FE4D0(v17, a2, &off_7FF705401CE0);
            goto LABEL_3;
          }
          v13 = 3LL;
          v12 = v10 + 3;
        }
        else
        {
          v16 = v10 + 2;
          if ( v12 == v7 )
            v16 = v12;
          v12 = &v16[v16 != v7];
          v13 = 3LL;
          if ( v14 >= 0xF0u )
          {
            v12 += v12 != v7;
            v13 = 4LL;
          }
        }
      }
      v9 += v13;
      v10 = v12;
      if ( v12 == v7 )
        goto LABEL_27;
    }
  }
  v8 = a2;
LABEL_27:
  if ( !sub_7FF7053EDDA0(a3, (v8 + a1), a2 - v8) )
    return sub_7FF7053F9DC0(a3);
  return v3;
}
// 7FF7053EDD61: variable 'v3' is possibly undefined
// 7FF705401C80: using guessed type char *off_7FF705401C80;
// 7FF705401CA0: using guessed type char *off_7FF705401CA0;
// 7FF705401CE0: using guessed type char *off_7FF705401CE0;

//----- (00007FF7053EDDA0) ----------------------------------------------------
char __fastcall sub_7FF7053EDDA0(_QWORD *a1, char *a2, __int64 a3)
{
  char *v3; // rdi
  unsigned __int8 *v4; // rsi
  unsigned __int8 v5; // bl
  unsigned __int8 v6; // r14
  char v7; // r12
  unsigned int v8; // r14d
  int v9; // r8d
  int v10; // ecx
  unsigned int v11; // eax
  __int64 v12; // rax
  unsigned __int8 v14; // [rsp+48h] [rbp-28h]
  unsigned __int8 v15; // [rsp+49h] [rbp-27h]
  _BYTE v18[60]; // [rsp+6Ch] [rbp-4h]

  v3 = a2;
  v4 = &a2[a3];
  v5 = v14;
  v6 = v15;
  v7 = 0;
  while ( (v7 & 1) != 0 && v5 < v6 )
  {
LABEL_2:
    ++v5;
    if ( sub_7FF7053FA100(a1) )
      return 1;
  }
  while ( v3 != v4 )
  {
    v8 = *v3;
    if ( *v3 < 0 )
    {
      v9 = v3[1] & 0x3F;
      if ( v8 <= 0xDFu )
      {
        v3 += 2;
        v8 = v9 | ((v8 & 0x1F) << 6);
LABEL_19:
        switch ( v8 )
        {
          case 0u:
            *v18 = 12380;
            goto LABEL_7;
          case 1u:
          case 2u:
          case 3u:
          case 4u:
          case 5u:
          case 6u:
          case 7u:
          case 8u:
          case 0xBu:
          case 0xCu:
          case 0xEu:
          case 0xFu:
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
          case 0x14u:
          case 0x15u:
          case 0x16u:
          case 0x17u:
          case 0x18u:
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
          case 0x1Fu:
          case 0x20u:
          case 0x21u:
          case 0x23u:
          case 0x24u:
          case 0x25u:
          case 0x26u:
            goto LABEL_28;
          case 9u:
            *v18 = 29788;
            goto LABEL_7;
          case 0xAu:
            *v18 = 28252;
            goto LABEL_7;
          case 0xDu:
            *v18 = 29276;
            goto LABEL_7;
          case 0x22u:
            *v18 = 8796;
            goto LABEL_7;
          case 0x27u:
            *v18 = 10076;
            goto LABEL_7;
          default:
            goto LABEL_26;
        }
      }
      v10 = ((v3[1] & 0x3F) << 6) | v3[2] & 0x3F;
      if ( *v3 < 0xF0u )
      {
        v3 += 3;
        v8 = ((v8 & 0x1F) << 12) | v10;
        if ( v8 <= 0x27 )
          goto LABEL_19;
      }
      else
      {
        v8 = ((v8 & 7) << 18) | (((v9 << 6) | v3[2] & 0x3F) << 6) | v3[3] & 0x3F;
        if ( v8 == 1114112 )
          return 0;
        v3 += 4;
        if ( v8 <= 0x27 )
          goto LABEL_19;
      }
    }
    else
    {
      ++v3;
      if ( v8 <= 0x27 )
        goto LABEL_19;
    }
LABEL_26:
    if ( v8 == 92 )
    {
      *v18 = 23644;
LABEL_7:
      *&v18[2] = 0LL;
      v6 = 2;
      v5 = 0;
    }
    else
    {
LABEL_28:
      if ( v8 > 0x2FF && sub_7FF7053FC600(v8) || !sub_7FF7053FBC50(v8) )
      {
        _BitScanReverse(&v11, v8 | 1);
        v12 = (v11 ^ 0x1C) >> 2;
        v5 = v12 - 2;
        v18[2] = 0;
        *v18 = 0;
        v18[3] = a0123456789abcd[v8 >> 20];
        v18[4] = a0123456789abcd[HIWORD(v8) & 0xF];
        v18[5] = a0123456789abcd[v8 >> 12];
        v18[6] = a0123456789abcd[(v8 >> 8) & 0xF];
        v18[7] = a0123456789abcd[v8 >> 4];
        v18[8] = a0123456789abcd[v8 & 0xF];
        v18[9] = 125;
        *&v18[v12 - 2] = 30044;
        v18[v12] = 123;
        v6 = 10;
      }
      else
      {
        *v18 = v8;
        v6 = -127;
        v5 = 0x80;
      }
    }
    if ( v5 < v6 )
    {
      v7 = 1;
      goto LABEL_2;
    }
  }
  return 0;
}
// 7FF7053EDDDC: variable 'v14' is possibly undefined
// 7FF7053EDDE0: variable 'v15' is possibly undefined

//----- (00007FF7053EE060) ----------------------------------------------------
char __fastcall sub_7FF7053EE060(__int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  char *v5; // r12
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  char *v8; // r9
  char *v9; // r9
  char *v10; // rax
  __int64 v11; // r10
  char v12; // r11
  char *v13; // r9
  _QWORD *v14; // r15
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rsi
  unsigned __int16 *v17; // rdi

  v5 = (a1 + a2);
  v6 = 0LL;
  while ( v6 != a2 )
  {
    v7 = v6;
    v8 = (a1 + v6);
    while ( 1 )
    {
      v10 = v8 + 1;
      v12 = *v8;
      v11 = 1LL;
      if ( *v8 < 0 )
        break;
LABEL_7:
      v7 += v11;
      v8 = v10;
      if ( v10 == v5 )
        goto LABEL_26;
    }
    if ( v12 < 0xE0u )
    {
      v9 = v8 + 2;
      if ( v10 != v5 )
        v10 = v9;
      v11 = 2LL;
      goto LABEL_7;
    }
    if ( v12 != -19 )
    {
      v13 = v8 + 2;
      if ( v10 == v5 )
        v13 = v10;
      v10 = &v13[v13 != v5];
      v11 = 3LL;
      if ( v12 >= 0xF0u )
      {
        v10 += v10 != v5;
        v11 = 4LL;
      }
      goto LABEL_7;
    }
    if ( v10 == v5 || v8 + 2 == v5 )
      goto LABEL_26;
    if ( v8[1] <= 0x9Fu )
    {
      v11 = 3LL;
      v10 = v8 + 3;
      goto LABEL_7;
    }
    if ( v7 < v6 )
      sub_7FF7053FE4F0(v6, v7, &off_7FF705401CC0);
    if ( v7 > a2 )
      sub_7FF7053FE4E0(v7, a2, &off_7FF705401CC0);
    v14 = a3;
    if ( sub_7FF7053F9DC0(a3) || sub_7FF7053F9DC0(v14) )
      return 1;
    v15 = v7 + 3;
    v6 = v15;
    a3 = v14;
    if ( v15 > a2 )
      sub_7FF7053FE4D0(v15, a2, &off_7FF705401CE0);
  }
  v6 = a2;
LABEL_26:
  v16 = a2 - v6;
  v17 = (v6 + a1);
  if ( v6 )
    return sub_7FF7053F9DC0(a3);
  else
    return sub_7FF7053FA4C0(v17, v16, a3);
}
// 7FF705401CC0: using guessed type char *off_7FF705401CC0;
// 7FF705401CE0: using guessed type char *off_7FF705401CE0;

//----- (00007FF7053EE220) ----------------------------------------------------
__int64 __fastcall sub_7FF7053EE220(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  char **v4; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+28h] [rbp-58h]
  __int64 **v6; // [rsp+30h] [rbp-50h]
  __int64 v7; // [rsp+38h] [rbp-48h]
  __int64 v8; // [rsp+40h] [rbp-40h]
  __int64 *v9; // [rsp+50h] [rbp-30h] BYREF
  __int64 (__fastcall *v10)(unsigned __int64 *, __int64); // [rsp+58h] [rbp-28h]
  __int64 v11; // [rsp+60h] [rbp-20h]
  __int64 v12; // [rsp+68h] [rbp-18h] BYREF
  __int64 v13; // [rsp+70h] [rbp-10h]
  __int64 v14; // [rsp+78h] [rbp-8h]
  int v15; // [rsp+80h] [rbp+0h] BYREF
  char v16; // [rsp+84h] [rbp+4h]
  __int64 v17; // [rsp+88h] [rbp+8h]

  v17 = -2LL;
  if ( byte_7FF70540B140 )
  {
    v12 = a2;
    v9 = &v12;
    v10 = sub_7FF7053FC390;
    v4 = &off_7FF705401D50;
    v5 = 2LL;
    v8 = 0LL;
    v6 = &v9;
    v7 = 1LL;
    sub_7FF7053FE110(&v4, &off_7FF705401D90);
  }
  v15 = 0;
  v16 = 0;
  v12 = a2;
  v9 = &v12;
  v10 = sub_7FF7053FC390;
  v4 = &off_7FF705401D20;
  v5 = 2LL;
  v8 = 0LL;
  v6 = &v9;
  v7 = 1LL;
  result = sub_7FF7053EB620(&v15, &v4);
  if ( (result & 3) == 1 )
  {
    v11 = result - 1;
    v13 = *(result - 1);
    v14 = *(result + 7);
    if ( *v14 )
      (*v14)(v13);
    v3 = *(v14 + 8);
    if ( v3 )
      sub_7FF7053E5E40(v13, v3, *(v14 + 16));
    return sub_7FF7053E5E40(v11, 24LL, 8LL);
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705401D20: using guessed type char *off_7FF705401D20;
// 7FF705401D50: using guessed type char *off_7FF705401D50;
// 7FF705401D90: using guessed type char *off_7FF705401D90;
// 7FF70540B140: using guessed type char byte_7FF70540B140;

//----- (00007FF7053EE3C0) ----------------------------------------------------
char *__fastcall sub_7FF7053EE3C0(SIZE_T a1, unsigned __int64 a2)
{
  char *v4; // rdi
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rsi

  if ( a2 < 0x11 )
    return sub_7FF7053F0E50(a1, 0, a1);
  v4 = 0LL;
  v5 = sub_7FF7053F0E50(a2 + a1, 0, a2 + a1);
  if ( v5 )
  {
    v6 = a2 - (v5 & (a2 - 1));
    v4 = (v6 + v5);
    *(v5 + v6 - 8) = v5;
  }
  return v4;
}

//----- (00007FF7053EE420) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
BOOL __fastcall sub_7FF7053EE420(void *a1, __int64 a2, unsigned __int64 a3)
{
  void *v3; // rsi
  HANDLE ProcessHeap; // rax

  v3 = a1;
  if ( a3 >= 0x11 )
    v3 = *(a1 - 1);
  ProcessHeap = GetProcessHeap();
  return HeapFree(ProcessHeap, 0, v3);
}

//----- (00007FF7053EE460) ----------------------------------------------------
char *__fastcall sub_7FF7053EE460(void *Src, size_t a2, unsigned __int64 a3, SIZE_T a4)
{
  HANDLE v6; // rax
  char *v10; // rdi
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r15
  void *v13; // rsi
  HANDLE ProcessHeap; // rax

  if ( a3 >= 0x11 )
  {
    v10 = 0LL;
    v11 = sub_7FF7053F0E50(Src, 0, a4 + a3);
    if ( v11 )
    {
      v12 = a3 - (v11 & (a3 - 1));
      v10 = (v12 + v11);
      *(v11 + v12 - 8) = v11;
      if ( a4 < a2 )
        a2 = a4;
      memcpy((v12 + v11), Src, a2);
      v13 = *(Src - 1);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v13);
    }
    return v10;
  }
  else
  {
    v6 = GetProcessHeap();
    return HeapReAlloc(v6, 0, Src, a4);
  }
}

//----- (00007FF7053EE510) ----------------------------------------------------
char *__fastcall sub_7FF7053EE510(SIZE_T a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rsi
  char *v6; // rcx

  if ( a2 < 0x11 )
    return sub_7FF7053F0E50(a1, 8u, a1);
  v4 = sub_7FF7053F0E50(a2 + a1, 8u, a2 + a1);
  if ( !v4 )
    return 0LL;
  v5 = a2 - (v4 & (a2 - 1));
  v6 = (v5 + v4);
  *(v4 + v5 - 8) = v4;
  return v6;
}

//----- (00007FF7053EE570) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __noreturn sub_7FF7053EE570()
{
  __int64 v0; // rax
  __int64 v1; // rdx
  _QWORD v2[3]; // [rsp+28h] [rbp-58h] BYREF
  __int128 v3; // [rsp+40h] [rbp-40h]
  __int64 v4; // [rsp+58h] [rbp-28h]
  __int64 v5; // [rsp+60h] [rbp-20h]
  __int64 v6; // [rsp+68h] [rbp-18h]
  int v7; // [rsp+70h] [rbp-10h] BYREF
  char v8; // [rsp+74h] [rbp-Ch]
  __int64 v9; // [rsp+78h] [rbp-8h]

  v9 = -2LL;
  v7 = 0;
  v8 = 0;
  v2[0] = &off_7FF705401DE8;
  v2[1] = 1LL;
  v2[2] = 8LL;
  v3 = 0LL;
  v0 = sub_7FF7053EB620(&v7, v2);
  if ( (v0 & 3) == 1 )
  {
    v4 = v0 - 1;
    v5 = *(v0 - 1);
    v6 = *(v0 + 7);
    if ( *v6 )
      (*v6)(v5);
    v1 = *(v6 + 8);
    if ( v1 )
      sub_7FF7053E5E40(v5, v1, *(v6 + 16));
    sub_7FF7053E5E40(v4, 24LL, 8LL);
  }
  __fastfail(7u);
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705401DE8: using guessed type char *off_7FF705401DE8;

//----- (00007FF7053EE6A0) ----------------------------------------------------
void __noreturn sub_7FF7053EE6A0()
{
  __int64 v0; // rax
  __int64 v1; // rdx
  _QWORD v2[3]; // [rsp+28h] [rbp-58h] BYREF
  __int128 v3; // [rsp+40h] [rbp-40h]
  __int64 v4; // [rsp+58h] [rbp-28h]
  __int64 v5; // [rsp+60h] [rbp-20h]
  __int64 v6; // [rsp+68h] [rbp-18h]
  int v7; // [rsp+70h] [rbp-10h] BYREF
  char v8; // [rsp+74h] [rbp-Ch]
  __int64 v9; // [rsp+78h] [rbp-8h]

  v9 = -2LL;
  v7 = 0;
  v8 = 0;
  v2[0] = &off_7FF705401E40;
  v2[1] = 1LL;
  v2[2] = 8LL;
  v3 = 0LL;
  v0 = sub_7FF7053EB620(&v7, v2);
  if ( (v0 & 3) == 1 )
  {
    v4 = v0 - 1;
    v5 = *(v0 - 1);
    v6 = *(v0 + 7);
    if ( *v6 )
      (*v6)(v5);
    v1 = *(v6 + 8);
    if ( v1 )
      sub_7FF7053E5E40(v5, v1, *(v6 + 16));
    sub_7FF7053E5E40(v4, 24LL, 8LL);
  }
  __fastfail(7u);
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705401E40: using guessed type char *off_7FF705401E40;

//----- (00007FF7053EE7C7) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053EE7C7(__int64 a1)
{
  char v2; // al
  __int64 v3; // rdx
  __int64 v4; // rdx
  volatile signed __int64 *v5; // rsi
  _BYTE *v6; // rdi
  volatile signed __int64 *v7; // rdx
  int v8; // eax
  _QWORD v9[2]; // [rsp+28h] [rbp-58h] BYREF
  _QWORD v10[2]; // [rsp+38h] [rbp-48h] BYREF
  volatile signed __int64 *v11; // [rsp+48h] [rbp-38h] BYREF
  _QWORD v12[2]; // [rsp+50h] [rbp-30h] BYREF
  __int128 v13; // [rsp+60h] [rbp-20h] BYREF
  char *v14; // [rsp+70h] [rbp-10h]
  _QWORD v15[3]; // [rsp+78h] [rbp-8h] BYREF
  volatile signed __int64 *v16; // [rsp+90h] [rbp+10h]
  _BYTE *v17; // [rsp+98h] [rbp+18h]
  char v18; // [rsp+A7h] [rbp+27h] BYREF
  int v19; // [rsp+A8h] [rbp+28h]
  char v20; // [rsp+AFh] [rbp+2Fh]
  __int64 v21; // [rsp+B0h] [rbp+30h]

  v21 = -2LL;
  v2 = 3;
  if ( !*(a1 + 25) )
  {
    v2 = 1;
    if ( *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 48LL) <= 1uLL )
      v2 = sub_7FF7053EBAF0();
  }
  v18 = v2;
  v10[0] = *(a1 + 16);
  v9[0] = sub_7FF7053EF480(*a1, *(a1 + 8));
  v9[1] = v3;
  *&v13 = v10;
  *(&v13 + 1) = v9;
  v14 = &v18;
  v12[0] = sub_7FF7053EA3E0(0LL);
  v12[1] = v4;
  if ( v12[0] & 1 | (v4 == 0) )
  {
    sub_7FF7053E69A0(v12);
    LODWORD(v15[0]) = 0;
    BYTE4(v15[0]) = 0;
    sub_7FF7053EE9BD(&v13, v15, &unk_7FF705401EA0);
  }
  else
  {
    v5 = v4;
    v15[2] = v4;
    v6 = (v4 + 16);
    if ( _InterlockedCompareExchange8((v4 + 16), 1, 0) )
      sub_7FF7053FD890((v4 + 16));
    v17 = v6;
    if ( 2 * qword_7FF70540B1E0 )
    {
      LOBYTE(v8) = !sub_7FF7053FD820();
      v19 = v8;
    }
    else
    {
      v19 = 0;
    }
    v16 = v5;
    sub_7FF7053EE9BD(&v13, (v5 + 3), &off_7FF705401E50);
    sub_7FF7053E6AD0(v17, v19);
    v20 = 0;
    v15[0] = sub_7FF7053EA3E0(v16);
    v15[1] = v7;
    if ( (v15[0] & 1) != 0 )
    {
      sub_7FF7053E69A0(v15);
    }
    else
    {
      v11 = v7;
      v10[1] = 1LL;
      if ( v7 )
      {
        if ( !_InterlockedDecrement64(v7) )
          sub_7FF7053E7980(&v11);
      }
    }
  }
}
// 7FF7053EE835: variable 'v3' is possibly undefined
// 7FF7053EE850: variable 'v4' is possibly undefined
// 7FF7053EE8FD: variable 'v7' is possibly undefined
// 7FF7053EE951: variable 'v8' is possibly undefined
// 7FF7053EBAF0: using guessed type __int64 sub_7FF7053EBAF0(void);
// 7FF705401E50: using guessed type __int64 (__fastcall *off_7FF705401E50)();
// 7FF70540B1E0: using guessed type __int64 qword_7FF70540B1E0;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053EE9BD) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053EE9BD(__int128 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // r8
  char v7; // dl
  _QWORD *v8; // rax
  const char *v9; // rdx
  char v10; // al
  __int64 v11; // [rsp+28h] [rbp-48h] BYREF
  __int128 v12; // [rsp+30h] [rbp-40h] BYREF
  __int64 v13; // [rsp+40h] [rbp-30h]
  __int128 v14; // [rsp+48h] [rbp-28h]
  char *v15; // [rsp+60h] [rbp-10h]
  char v16; // [rsp+6Fh] [rbp-1h]
  __int64 v17; // [rsp+70h] [rbp+0h]

  v17 = -2LL;
  v15 = sub_7FF7053ECF20();
  v16 = v7 & 1;
  v12 = *a1;
  v13 = a2;
  *&v14 = a3;
  v8 = *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 80LL);
  if ( v8 > 2 )
  {
    v9 = v8[1];
    if ( v9 )
    {
      sub_7FF7053EEB80(&v12, v9, v8[2] - 1LL);
      goto LABEL_9;
    }
    if ( *v8 != qword_7FF70540B200 )
      goto LABEL_8;
LABEL_6:
    sub_7FF7053EEB80(&v12, "main\"", 4LL);
    goto LABEL_9;
  }
  if ( qword_7FF70540B200 && *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 8LL) == qword_7FF70540B200 )
    goto LABEL_6;
LABEL_8:
  sub_7FF7053EEB80(&v12, 0LL, v6);
LABEL_9:
  switch ( **(a1 + 2) )
  {
    case 0:
      *&v12 = sub_7FF7053ECF90(a2, *(a3 + 72), 0);
      sub_7FF7053E6BF0(&v12);
      break;
    case 1:
      *&v12 = sub_7FF7053ECF90(a2, *(a3 + 72), 1);
      sub_7FF7053E6BF0(&v12);
      break;
    case 2:
      v10 = byte_7FF70540B020;
      byte_7FF70540B020 = 0;
      if ( v10 )
      {
        *&v12 = &off_7FF705401F40;
        *(&v12 + 1) = 1LL;
        v13 = 8LL;
        v14 = 0LL;
        v11 = (*(a3 + 72))(a2);
        sub_7FF7053E6BF0(&v11);
      }
      break;
    case 3:
      break;
  }
  sub_7FF7053E6AD0(v15, v16);
}
// 7FF7053EE9E7: variable 'v7' is possibly undefined
// 7FF7053EEAA7: variable 'v6' is possibly undefined
// 7FF705401F40: using guessed type char *off_7FF705401F40;
// 7FF70540B020: using guessed type char byte_7FF70540B020;
// 7FF70540B200: using guessed type __int64 qword_7FF70540B200;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053EEB80) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EEB80(__int64 *a1, const char *a2, __int64 a3)
{
  const char *v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 (__fastcall *v11)(__int64, char ***); // rax
  __int64 result; // rax
  void (__fastcall *v13)(__int64); // rdx
  _BYTE v14[512]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v15[2]; // [rsp+220h] [rbp+1A0h] BYREF
  unsigned __int64 v16; // [rsp+230h] [rbp+1B0h]
  char **v17; // [rsp+238h] [rbp+1B8h] BYREF
  __int64 v18; // [rsp+240h] [rbp+1C0h]
  _QWORD **v19; // [rsp+248h] [rbp+1C8h]
  __int64 v20; // [rsp+250h] [rbp+1D0h]
  __int64 v21; // [rsp+258h] [rbp+1D8h]
  _QWORD v22[2]; // [rsp+268h] [rbp+1E8h] BYREF
  _QWORD *v23; // [rsp+278h] [rbp+1F8h] BYREF
  char (__fastcall *v24)(__int64, __int64 *); // [rsp+280h] [rbp+200h]
  __int64 v25; // [rsp+288h] [rbp+208h]
  char (__fastcall *v26)(_QWORD **, __int64 *); // [rsp+290h] [rbp+210h]
  __int64 v27; // [rsp+298h] [rbp+218h]
  char (__fastcall *v28)(__int64, __int64 *); // [rsp+2A0h] [rbp+220h]
  void (__fastcall **v29)(__int64); // [rsp+2A8h] [rbp+228h]
  __int64 v30; // [rsp+2B0h] [rbp+230h]
  __int64 v31; // [rsp+2B8h] [rbp+238h]
  __int64 v32; // [rsp+2C0h] [rbp+240h]

  v32 = -2LL;
  v4 = "<unnamed>";
  if ( a2 )
    v4 = a2;
  v5 = 9LL;
  if ( a2 )
    v5 = a3;
  v22[0] = v4;
  v22[1] = v5;
  memset(v14, 0, sizeof(v14));
  v15[0] = v14;
  v15[1] = 512LL;
  v16 = 0LL;
  v6 = *a1;
  v7 = a1[1];
  v23 = v22;
  v24 = sub_7FF7053E5F90;
  v25 = v6;
  v26 = sub_7FF7053E5FB0;
  v27 = v7;
  v28 = sub_7FF7053E5F90;
  v17 = &off_7FF705401F90;
  v18 = 4LL;
  v21 = 0LL;
  v19 = &v23;
  v20 = 3LL;
  v8 = sub_7FF7053EB7A0(v15, &v17);
  if ( v8 )
  {
    if ( (v8 & 3) == 1 )
    {
      v29 = (v8 - 1);
      v30 = *(v8 - 1);
      v31 = *(v8 + 7);
      if ( *v31 )
        (*v31)(v30);
      v9 = *(v31 + 8);
      if ( v9 )
        sub_7FF7053E5E40(v30, v9, *(v31 + 16));
      sub_7FF7053E5E40(v29, 24LL, 8LL);
    }
    v10 = a1[2];
    v11 = *(a1[3] + 72);
    v23 = v22;
    v24 = sub_7FF7053E5F90;
    v25 = v6;
    v26 = sub_7FF7053E5FB0;
    v27 = v7;
    v28 = sub_7FF7053E5F90;
    v17 = &off_7FF705401F90;
    v18 = 4LL;
    v21 = 0LL;
    v19 = &v23;
    v20 = 3LL;
    result = v11(v10, &v17);
    if ( (result & 3) == 1 )
    {
      v30 = result - 1;
      v31 = *(result - 1);
      v29 = *(result + 7);
      if ( *v29 )
        goto LABEL_18;
      goto LABEL_19;
    }
  }
  else
  {
    if ( v16 >= 0x201 )
      sub_7FF7053FE4E0(v16, 512LL, &off_7FF705401F60);
    result = (*(a1[3] + 56))(a1[2], v14);
    if ( (result & 3) == 1 )
    {
      v30 = result - 1;
      v31 = *(result - 1);
      v29 = *(result + 7);
      if ( *v29 )
LABEL_18:
        (*v29)(v31);
LABEL_19:
      v13 = v29[1];
      if ( v13 )
        sub_7FF7053E5E40(v31, v13, v29[2]);
      return sub_7FF7053E5E40(v30, 24LL, 8LL);
    }
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705401F60: using guessed type char *off_7FF705401F60;
// 7FF705401F90: using guessed type char *off_7FF705401F90;

//----- (00007FF7053EEFF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053EEFF0(char a1)
{
  char v1; // of
  __int64 v2; // rt0
  __int64 v3; // rdx
  char result; // al

  v2 = _InterlockedIncrement64(&qword_7FF70540B1E0);
  if ( (v2 < 0) ^ v1 | (v2 == 0) )
    return 0;
  v3 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  result = 1;
  if ( !*(v3 + 56) )
  {
    ++*(v3 + 48);
    *(v3 + 56) = a1;
    return 2;
  }
  return result;
}
// 7FF7053EEFF8: variable 'v1' is possibly undefined
// 7FF70540B1E0: using guessed type __int64 qword_7FF70540B1E0;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053EF030) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053EF030(_OWORD *a1)
{
  __int128 v1; // [rsp+28h] [rbp-18h] BYREF
  _OWORD *v2; // [rsp+38h] [rbp-8h]

  v1 = *a1;
  v2 = a1;
  sub_7FF7053ED880(&v1);
}

//----- (00007FF7053EF050) ----------------------------------------------------
_QWORD *__fastcall sub_7FF7053EF050(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbx
  __int128 **v5; // rax
  __int128 *v6; // rax
  __int128 v7; // xmm0
  __int128 v8; // xmm1
  __int128 v9; // xmm0
  __int64 v10; // r14
  __int64 v11; // rdi
  _QWORD *result; // rax
  __int128 v13; // [rsp+20h] [rbp-60h] BYREF
  __int128 v14; // [rsp+30h] [rbp-50h]
  __int128 v15; // [rsp+40h] [rbp-40h]
  __int64 v16; // [rsp+50h] [rbp-30h]
  __int64 v17; // [rsp+58h] [rbp-28h]
  __int128 v18; // [rsp+60h] [rbp-20h] BYREF
  __int64 v19; // [rsp+70h] [rbp-10h]
  __int64 v20; // [rsp+78h] [rbp-8h]

  v20 = -2LL;
  v4 = *a1;
  if ( __OFSUB__(-*a1, 1LL) )
  {
    v5 = a1[3];
    *&v18 = 0LL;
    *(&v18 + 1) = 1LL;
    v19 = 0LL;
    v6 = *v5;
    v7 = *v6;
    v8 = v6[1];
    v15 = v6[2];
    v14 = v8;
    v13 = v7;
    sub_7FF7053F9220(&v18, &off_7FF705400F20, &v13);
    v9 = v18;
    v13 = v18;
    *&v14 = v19;
    a1[2] = v19;
    *a1 = v9;
    v4 = *a1;
  }
  v10 = a1[1];
  v11 = a1[2];
  *a1 = 0LL;
  a1[1] = 1LL;
  a1[2] = 0LL;
  nullsub_1(a1, a2, a3);
  result = sub_7FF7053E5E30(24LL, 8LL);
  if ( !result )
  {
    v17 = v10;
    v16 = v4;
    sub_7FF7053FE00D(8LL, 24LL);
  }
  *result = v4;
  result[1] = v10;
  result[2] = v11;
  return result;
}
// 7FF7053EF0FE: variable 'a1' is possibly undefined
// 7FF7053EF0FE: variable 'a2' is possibly undefined
// 7FF7053EF0FE: variable 'a3' is possibly undefined
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD);
// 7FF705400F20: using guessed type __int64 (__fastcall *off_7FF705400F20)();

//----- (00007FF7053EF1D0) ----------------------------------------------------
_QWORD *__fastcall sub_7FF7053EF1D0(_QWORD *a1)
{
  __int128 **v2; // rax
  __int128 *v3; // rax
  __int128 v4; // xmm0
  __int128 v5; // xmm1
  __int128 v6; // xmm0
  __int128 v8; // [rsp+20h] [rbp-50h] BYREF
  __int128 v9; // [rsp+30h] [rbp-40h]
  __int128 v10; // [rsp+40h] [rbp-30h]
  __int128 v11; // [rsp+58h] [rbp-18h] BYREF
  __int64 v12; // [rsp+68h] [rbp-8h]
  __int64 v13; // [rsp+70h] [rbp+0h]

  v13 = -2LL;
  if ( __OFSUB__(0LL, *a1) )
  {
    v2 = a1[3];
    *&v11 = 0LL;
    *(&v11 + 1) = 1LL;
    v12 = 0LL;
    v3 = *v2;
    v4 = *v3;
    v5 = v3[1];
    v10 = v3[2];
    v9 = v5;
    v8 = v4;
    sub_7FF7053F9220(&v11, &off_7FF705400F20, &v8);
    v6 = v11;
    v8 = v11;
    *&v9 = v12;
    a1[2] = v12;
    *a1 = v6;
  }
  return a1;
}
// 7FF705400F20: using guessed type __int64 (__fastcall *off_7FF705400F20)();

//----- (00007FF7053EF290) ----------------------------------------------------
char __fastcall sub_7FF7053EF290(__int64 a1, __int64 *a2)
{
  __int128 *v2; // rax
  __int128 v3; // xmm0
  __int128 v4; // xmm1
  _OWORD v6[3]; // [rsp+20h] [rbp-30h] BYREF

  if ( !__OFSUB__(0LL, *a1) )
    return sub_7FF7053F9DC0(a2);
  v2 = **(a1 + 24);
  v3 = *v2;
  v4 = v2[1];
  v6[2] = v2[2];
  v6[1] = v4;
  v6[0] = v3;
  return sub_7FF7053F9220(*a2, a2[1], v6);
}

//----- (00007FF7053EF2F0) ----------------------------------------------------
_QWORD *__fastcall sub_7FF7053EF2F0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  _QWORD *result; // rax

  v3 = *a1;
  v4 = a1[1];
  nullsub_1(a1, a2, a3);
  result = sub_7FF7053E5E30(16LL, 8LL);
  if ( !result )
    sub_7FF7053FE00D(8LL, 16LL);
  *result = v3;
  result[1] = v4;
  return result;
}
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053EF350) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EF350(__int64 a1)
{
  return a1;
}

//----- (00007FF7053EF360) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EF360(__int64 a1)
{
  return *a1;
}

//----- (00007FF7053EF370) ----------------------------------------------------
__int64 __fastcall sub_7FF7053EF370(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9DC0(a2);
}

//----- (00007FF7053EF390) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053EF390(__int64 *a1)
{
  __int64 **v1; // rax
  __int64 v2; // r8
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 *v6; // rdx
  _QWORD v7[5]; // [rsp+28h] [rbp-28h] BYREF

  v7[4] = -2LL;
  v1 = *a1;
  v2 = *(*a1 + 8);
  v3 = *(*a1 + 24);
  if ( v2 == 1 )
  {
    if ( !v3 )
    {
      v6 = *v1;
      v4 = **v1;
      v5 = v6[1];
LABEL_7:
      v7[0] = v4;
      v7[1] = v5;
      sub_7FF7053EF506(v7, &unk_7FF705402010, a1[1], *(a1[2] + 16), *(a1[2] + 17));
    }
  }
  else if ( !v2 && !v3 )
  {
    v4 = 1LL;
    v5 = 0LL;
    goto LABEL_7;
  }
  v7[3] = a1;
  v7[0] = 0x8000000000000000uLL;
  sub_7FF7053EF506(v7, &off_7FF705402048, a1[1], *(a1[2] + 16), *(a1[2] + 17));
}
// 7FF705402048: using guessed type __int64 (__fastcall *off_7FF705402048)();

//----- (00007FF7053EF480) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
const char *__fastcall sub_7FF7053EF480(__int64 a1, __int64 a2)
{
  __int64 (*v3)(void); // rdi
  unsigned __int64 v4; // r8
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rdx

  v3 = *(a2 + 24);
  v4 = v3() ^ 0xB98B1B7157A64178uLL;
  v6 = a1;
  if ( !(v4 | v5 ^ 0x63EB502CD6CB5D6DLL) )
    return *v6;
  v7 = (v3)(a1);
  if ( !(v7 ^ 0x6723D68C895B2603LL | v8 ^ 0xB6E02746A204CEDDuLL) )
  {
    v6 = a1 + 8;
    return *v6;
  }
  return aBoxDynAny;
}
// 7FF7053EF4AC: variable 'v5' is possibly undefined
// 7FF7053EF4D8: variable 'v8' is possibly undefined

//----- (00007FF7053EF506) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053EF506(__int64 a1, __int64 a2, __int64 a3, char a4, char a5)
{
  char v8; // al
  int v9; // eax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // r8
  __int64 v17; // rax
  __int64 *v18; // rcx
  _QWORD *v19; // [rsp+20h] [rbp-60h] BYREF
  char (__fastcall *v20)(_QWORD **, __int64 *); // [rsp+28h] [rbp-58h]
  __int64 *v21; // [rsp+30h] [rbp-50h]
  void *v22; // [rsp+38h] [rbp-48h]
  char **v23; // [rsp+40h] [rbp-40h] BYREF
  __int64 v24; // [rsp+48h] [rbp-38h]
  __int64 v25; // [rsp+50h] [rbp-30h]
  __int128 v26; // [rsp+58h] [rbp-28h]
  _QWORD v27[2]; // [rsp+70h] [rbp-10h] BYREF
  int v28; // [rsp+80h] [rbp+0h] BYREF
  char v29; // [rsp+84h] [rbp+4h]
  int v30; // [rsp+88h] [rbp+8h] BYREF
  char v31; // [rsp+8Ch] [rbp+Ch]
  __int64 v32; // [rsp+90h] [rbp+10h] BYREF
  __int64 v33; // [rsp+98h] [rbp+18h]
  _QWORD v34[6]; // [rsp+A0h] [rbp+20h] BYREF

  v34[1] = -2LL;
  v32 = a1;
  v33 = a2;
  v34[0] = a3;
  v8 = sub_7FF7053EEFF0(1);
  if ( v8 == 2 )
  {
    v9 = dword_7FF70540B1C0;
    if ( dword_7FF70540B1C0 > 0x3FFFFFFD
      || v9 != _InterlockedCompareExchange(&dword_7FF70540B1C0, dword_7FF70540B1C0 + 1, dword_7FF70540B1C0) )
    {
      sub_7FF7053FDB60(&dword_7FF70540B1C0);
    }
    v10 = v32;
    v11 = v33;
    if ( qword_7FF70540B1D0 )
    {
      v23 = (*(v33 + 40))(v32);
      v24 = v13;
      v25 = v34[0];
      LOBYTE(v26) = a4;
      BYTE1(v26) = a5;
      (*(qword_7FF70540B1D8 + 40))(qword_7FF70540B1D0, &v23);
    }
    else
    {
      v23 = (*(v33 + 40))(v32);
      v24 = v12;
      v25 = v34[0];
      LOBYTE(v26) = a4;
      BYTE1(v26) = a5;
      sub_7FF7053EE7C7(&v23);
    }
    sub_7FF7053E6C80(&dword_7FF70540B1C0);
    *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 56LL) = 0;
    if ( a4 )
      sub_7FF7053EF7B0(v10, v11);
    LODWORD(v27[0]) = 0;
    BYTE4(v27[0]) = 0;
    v23 = &off_7FF705402170;
    v24 = 1LL;
    v25 = 8LL;
    v26 = 0LL;
    v19 = sub_7FF7053EB620(v27, &v23);
    sub_7FF7053E6BF0(&v19);
    __fastfail(7u);
  }
  if ( (v8 & 1) != 0 )
  {
    v14 = (*(a2 + 48))(a1);
    v16 = 1LL;
    if ( v14 )
      v16 = v14;
    else
      v15 = 0LL;
    v28 = 0;
    v27[0] = v16;
    v27[1] = v15;
    v29 = 0;
    v19 = v34;
    v20 = sub_7FF7053E5FB0;
    v21 = v27;
    v23 = &off_7FF705402110;
    v24 = 3LL;
    v22 = sub_7FF7053E5F90;
    v25 = &v19;
    v26 = 2uLL;
    v17 = sub_7FF7053EB620(&v28, &v23);
    v18 = &v30;
  }
  else
  {
    v30 = 0;
    v31 = 0;
    v19 = v34;
    v20 = sub_7FF7053E5FB0;
    v21 = &v32;
    v23 = &off_7FF7054020A8;
    v24 = 3LL;
    v22 = sub_7FF7053E6E10;
    v25 = &v19;
    v26 = 2uLL;
    v17 = sub_7FF7053EB620(&v30, &v23);
    v18 = v27;
  }
  *v18 = v17;
  sub_7FF7053E6BF0(v18);
  __fastfail(7u);
}
// 7FF7053EF595: variable 'v12' is possibly undefined
// 7FF7053EF5C4: variable 'v13' is possibly undefined
// 7FF7053EF660: variable 'v15' is possibly undefined
// 7FF7054020A8: using guessed type char *off_7FF7054020A8;
// 7FF705402110: using guessed type char *off_7FF705402110;
// 7FF705402170: using guessed type char *off_7FF705402170;
// 7FF70540B1C0: using guessed type int dword_7FF70540B1C0;
// 7FF70540B1D0: using guessed type __int64 qword_7FF70540B1D0;
// 7FF70540B1D8: using guessed type __int64 qword_7FF70540B1D8;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053EF7B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053EF7B0(__int64 a1, __int64 a2)
{
  sub_7FF7053F2770(a1, a2);
}

//----- (00007FF7053EF840) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053EF840(__int64 a1, __int64 *a2)
{
  unsigned __int64 v3; // rdi
  __int64 v4; // rbx
  unsigned __int16 *v5; // r12
  char v6; // r15
  __int64 v7; // r13
  unsigned __int64 v8; // r12
  int v10; // [rsp+20h] [rbp-10h] BYREF
  unsigned __int16 *v11; // [rsp+28h] [rbp-8h]
  unsigned __int64 v12; // [rsp+30h] [rbp+0h]

  if ( *a1 != 2 )
    return sub_7FF7053F7E9A(a1, a2);
  v3 = *(a1 + 72);
  if ( !v3 )
    return 0;
  v4 = *(a1 + 64);
  while ( 1 )
  {
    sub_7FF7053FA930(&v10, v4, v3);
    if ( v10 != 1 )
      break;
    v5 = v11;
    v6 = v12;
    v7 = BYTE1(v12);
    if ( sub_7FF7053FA4C0(word_7FF705401CD8, 3uLL, a2) )
      return 1;
    if ( (v6 & 1) != 0 )
    {
      v8 = v5 + v7;
      if ( v3 < v8 )
        sub_7FF7053FE4D0(v8, v3, &off_7FF705402240);
      v4 += v8;
      v3 -= v8;
      if ( v3 )
        continue;
    }
    return 0;
  }
  return sub_7FF7053FA4C0(v11, v12, a2) != 0;
}
// 7FF705401CD8: using guessed type unsigned __int16 word_7FF705401CD8[4];
// 7FF705402240: using guessed type char *off_7FF705402240;

//----- (00007FF7053EF930) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053EF930(__int64 a1, __int64 a2, __int128 *a3, __int128 *a4, char a5, int a6, char a7, int a8)
{
  __int64 *v8; // rsi
  __int64 v9; // rdi
  char result; // al
  __int64 v13; // rbx
  __int64 *v14; // rax
  __int64 *v15; // rax
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  __int128 v18; // xmm2
  __int64 *v19; // rax
  __int128 v20; // xmm0
  __int128 v21; // xmm1
  __int128 v22; // xmm2
  char v23; // al
  char v24; // dl
  __int64 v25; // [rsp+28h] [rbp-58h] BYREF
  __int128 *v26; // [rsp+30h] [rbp-50h] BYREF
  char (__fastcall *v27)(__int64, __int64 *); // [rsp+38h] [rbp-48h]
  __int128 v28; // [rsp+40h] [rbp-40h] BYREF
  __int128 v29; // [rsp+50h] [rbp-30h]
  __int128 v30; // [rsp+60h] [rbp-20h]
  __int128 v31; // [rsp+70h] [rbp-10h]
  __int128 v32; // [rsp+80h] [rbp+0h]
  __int64 *v33; // [rsp+90h] [rbp+10h] BYREF
  __int64 v34; // [rsp+98h] [rbp+18h]
  __int128 **v35; // [rsp+A0h] [rbp+20h]
  __int64 v36; // [rsp+A8h] [rbp+28h]
  void *v37; // [rsp+B0h] [rbp+30h]
  __int64 v38; // [rsp+B8h] [rbp+38h]

  v8 = *a1;
  v9 = *(a1 + 8);
  v25 = a2;
  if ( !a2 && !*(v8 + 32) )
    goto LABEL_3;
  v13 = a1;
  v14 = *v8;
  if ( v9 )
  {
    if ( (*(v14[1] + 24))(*v14, asc_7FF705402300, 6LL) )
      return 1;
    if ( *(v8 + 32) != 1 )
      goto LABEL_12;
    v15 = *v8;
    v33 = &unk_7FF705401270;
    v34 = sub_7FF7053E5F90;
    v35 = 0LL;
    LOWORD(v36) = 21;
    *&v28 = &unk_7FF705401270;
    *(&v28 + 1) = 1LL;
    *&v30 = &unk_7FF7054022D0;
    *(&v30 + 1) = 1LL;
    *&v29 = &v33;
    goto LABEL_11;
  }
  v33 = v8 + 3;
  v34 = sub_7FF7053FC390;
  *&v28 = &unk_7FF705402258;
  *(&v28 + 1) = 2LL;
  *&v30 = &unk_7FF705402278;
  *(&v30 + 1) = 1LL;
  *&v29 = &v33;
  *(&v29 + 1) = 1LL;
  if ( sub_7FF7053F9220(*v14, v14[1], &v28) )
    return 1;
  if ( *(v8 + 32) == 1 )
  {
    v15 = *v8;
    v33 = &v25;
    v34 = sub_7FF7053E6E00;
    v35 = 0LL;
    LOWORD(v36) = 18;
    *&v28 = &unk_7FF7054022B0;
    *(&v28 + 1) = 2LL;
    *&v30 = &unk_7FF7054022D0;
    *(&v30 + 1) = 1LL;
    *&v29 = &v33;
LABEL_11:
    *(&v29 + 1) = 2LL;
    if ( sub_7FF7053F9220(*v15, v15[1], &v28) )
      return 1;
  }
LABEL_12:
  if ( *a3 == 3 )
  {
    if ( (*(*(*v8 + 8) + 24LL))(**v8, aUnknown, 9LL) )
      return 1;
  }
  else
  {
    if ( *(v8 + 32) )
    {
      v32 = a3[4];
      v16 = *a3;
      v17 = a3[1];
      v18 = a3[2];
      v31 = a3[3];
      v30 = v18;
      v29 = v17;
      v28 = v16;
      v19 = *v8;
      v26 = &v28;
      v27 = sub_7FF7053EF840;
      v33 = &unk_7FF705401270;
      v34 = 1LL;
      v37 = 0LL;
    }
    else
    {
      v32 = a3[4];
      v20 = *a3;
      v21 = a3[1];
      v22 = a3[2];
      v31 = a3[3];
      v30 = v22;
      v29 = v21;
      v28 = v20;
      v19 = *v8;
      v26 = &v28;
      v27 = sub_7FF7053EF840;
      v33 = &unk_7FF705401270;
      v34 = 1LL;
      v37 = &unk_7FF705401158;
      v38 = 1LL;
    }
    v35 = &v26;
    v36 = 1LL;
    if ( sub_7FF7053F9220(*v19, v19[1], &v33) )
      return 1;
  }
  if ( sub_7FF7053F9DC0(*v8) )
    return 1;
  a1 = v13;
  if ( *a4 == 2 || (a5 & 1) == 0 || (v23 = sub_7FF7053EFC70(v8, a4, a6, a7, a8), a1 = v13, v24 = v23, result = 1, !v24) )
  {
LABEL_3:
    *(a1 + 8) = v9 + 1;
    return 0;
  }
  return result;
}

//----- (00007FF7053EFC70) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EFC70(_QWORD **a1, __int128 *a2, int a3, char a4, int a5)
{
  unsigned int v5; // ebx
  __int64 *v9; // rax
  _QWORD *v10; // rcx
  _QWORD *v11; // rax
  __int64 *v12; // rax
  __int64 *v13; // rax
  int *v15; // [rsp+28h] [rbp-58h] BYREF
  void *v16; // [rsp+30h] [rbp-50h]
  __int64 v17; // [rsp+38h] [rbp-48h]
  __int16 v18; // [rsp+40h] [rbp-40h]
  void *v19; // [rsp+48h] [rbp-38h] BYREF
  __int128 v20; // [rsp+50h] [rbp-30h] BYREF
  __int64 v21; // [rsp+60h] [rbp-20h]
  void *v22; // [rsp+68h] [rbp-18h]
  __int64 v23; // [rsp+70h] [rbp-10h]
  int v24; // [rsp+78h] [rbp-8h] BYREF
  int v25; // [rsp+7Ch] [rbp-4h] BYREF

  v25 = a3;
  if ( *(a1 + 32) != 1 )
    goto LABEL_3;
  v9 = *a1;
  v15 = &unk_7FF705401270;
  v16 = sub_7FF7053E5F90;
  v17 = 0LL;
  v18 = 18;
  v19 = &unk_7FF705401270;
  *&v20 = 1LL;
  v22 = &unk_7FF7054022D0;
  v23 = 1LL;
  *(&v20 + 1) = &v15;
  v21 = 2LL;
  LOBYTE(v5) = 1;
  if ( !sub_7FF7053F9220(*v9, v9[1], &v19) )
  {
LABEL_3:
    LOBYTE(v5) = 1;
    if ( !(*((*a1)[1] + 24LL))(**a1, aAt, 16LL) )
    {
      v10 = a1[1];
      v11 = a1[2];
      v19 = *a1;
      v20 = *a2;
      v21 = *(a2 + 2);
      if ( !(v11[4])(v10, v19, &v20) )
      {
        v12 = *a1;
        v15 = &v25;
        v16 = sub_7FF7053FC130;
        v19 = &off_7FF705402318;
        *&v20 = 1LL;
        v22 = 0LL;
        *(&v20 + 1) = &v15;
        v21 = 1LL;
        if ( !sub_7FF7053F9220(*v12, v12[1], &v19) )
        {
          if ( (a4 & 1) == 0 )
            return (*((*a1)[1] + 24LL))(**a1, "\n", 1LL);
          v24 = a5;
          v13 = *a1;
          v15 = &v24;
          v16 = sub_7FF7053FC130;
          v19 = &off_7FF705402318;
          *&v20 = 1LL;
          v22 = 0LL;
          *(&v20 + 1) = &v15;
          v21 = 1LL;
          if ( !sub_7FF7053F9220(*v13, v13[1], &v19) )
            return (*((*a1)[1] + 24LL))(**a1, "\n", 1LL);
        }
      }
    }
  }
  return v5;
}
// 7FF7053EFE1E: variable 'v5' is possibly undefined
// 7FF705401F8F: using guessed type char asc_7FF705401F8F;

//----- (00007FF7053EFE40) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053EFE40(const WCHAR *Buf2, __int64 a2, __int64 a3, __int64 *a4)
{
  int v6; // eax
  unsigned __int64 v7; // rbx
  __int64 v8; // r14
  int v9; // eax
  char *v10; // rcx
  __int64 v11; // r15
  size_t v12; // r14
  __int64 v13; // r13
  char v14; // r12
  __int64 v15; // rdx
  __int64 v16; // rax
  __int64 v17; // r9
  char *v18; // rsi
  __int64 v19; // r8
  char *v20; // rax
  bool v21; // zf
  char *v22; // rax
  unsigned __int64 *v23; // rsi
  char *v25; // [rsp+28h] [rbp-18h]
  __int64 *v26; // [rsp+30h] [rbp-10h]
  char v27; // [rsp+3Fh] [rbp-1h] BYREF
  __int64 v28; // [rsp+40h] [rbp+0h]

  v28 = -2LL;
  v6 = lstrlenW(Buf2);
  if ( v6 < 0 )
    sub_7FF7053FE440(aCalledResultUn, 43LL, &v27, "", &off_7FF705402428);
  v26 = a4;
  if ( v6 )
  {
    v7 = v6;
    v8 = -2LL * v6;
    do
    {
      if ( !v8 )
        return 1LL;
      v9 = Buf2[--v7];
      v8 += 2LL;
    }
    while ( v9 != 92 && v9 != 47 );
    v10 = v26[1];
    v11 = v26[2];
    v12 = -v8;
    v13 = v11;
    v25 = v10;
    while ( 1 )
    {
      v14 = 1;
      if ( v13 )
        break;
      v13 = 0LL;
      v18 = v10;
      if ( !v7 )
        goto LABEL_18;
LABEL_8:
      v10 = v18;
      if ( v14 )
      {
        v19 = v25;
        v20 = &v25[2 * v11];
        v21 = v20 == 2;
        v22 = v20 - 2;
        if ( v11 == 0 || v21 || *v22 != 59 )
        {
          v23 = v26;
          if ( v11 == *v26 )
          {
            sub_7FF7053E7B40(v26, &off_7FF7054023F8);
            v19 = v26[1];
          }
          *(v19 + 2 * v11++) = 59;
          v23[2] = v11;
        }
        else
        {
          v23 = v26;
        }
        if ( v7 > *v23 - v11 )
        {
          sub_7FF7053FD5A0(v23, v11, v7, 2LL, 2LL);
          v19 = v23[1];
          v11 = v23[2];
        }
        memcpy((v19 + 2 * v11), Buf2, v12);
        v23[2] = v11 + v7;
        return 1LL;
      }
    }
    v15 = -2LL;
    v16 = 0LL;
    while ( *&v10[2 * v16] != 59 )
    {
      ++v16;
      v17 = 2 * v13 + v15 - 2;
      v15 -= 2LL;
      if ( v17 == -2 )
      {
        v18 = v10;
        if ( v13 != v7 )
          goto LABEL_8;
        goto LABEL_18;
      }
    }
    v13 += ~v16;
    v18 = &v10[-v15];
    v14 = 0;
    if ( v16 != v7 )
      goto LABEL_8;
LABEL_18:
    if ( !memcmp(v10, Buf2, v12) )
      return 1LL;
    goto LABEL_8;
  }
  return 1LL;
}
// 7FF7053FE29A: using guessed type void __noreturn sub_7FF7053FE29A(void);
// 7FF7054023F8: using guessed type char *off_7FF7054023F8;
// 7FF705402428: using guessed type char *off_7FF705402428;

//----- (00007FF7053F0070) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F0070(unsigned __int8 *a1, unsigned __int8 *a2)
{
  __int64 v2; // r8
  __int64 v3; // r10
  char result; // al
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // r11
  size_t v7; // r8
  const void *v8; // rdx
  const void *v9; // rcx
  size_t v10; // r8

  v2 = *a1;
  v3 = v2 - 5;
  result = 0;
  if ( (v2 - 6) >= 4u )
    v3 = 0LL;
  v5 = *a2;
  v6 = v5 - 5;
  if ( v5 < 6 )
    v6 = 0LL;
  if ( v3 == v6 )
  {
    result = 1;
    if ( v3 )
    {
      if ( v3 != 4 )
        return result;
LABEL_8:
      v7 = *(a1 + 2);
      if ( v7 == *(a2 + 2) )
      {
        v8 = *(a2 + 1);
        v9 = *(a1 + 1);
        return memcmp(v9, v8, v7) == 0;
      }
    }
    else
    {
      if ( v5 > 5u )
        return result;
      if ( v2 == v5 )
      {
        switch ( *a1 )
        {
          case 0u:
          case 3u:
            goto LABEL_8;
          case 1u:
          case 4u:
            v10 = *(a1 + 2);
            if ( v10 != *(a2 + 2) )
              return 0;
            if ( memcmp(*(a1 + 1), *(a2 + 1), v10) )
              return 0;
            v7 = *(a1 + 4);
            if ( v7 != *(a2 + 4) )
              return 0;
            v8 = *(a2 + 3);
            v9 = *(a1 + 3);
            return memcmp(v9, v8, v7) == 0;
          case 2u:
          case 5u:
            return a1[1] == a2[1];
        }
      }
    }
    return 0;
  }
  return result;
}

//----- (00007FF7053F0140) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F0140(void **a1, void *Buffer, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  union _LARGE_INTEGER *ByteOffset; // r10
  ULONG Length; // eax
  void *v7; // rsi
  int Status; // eax
  _QWORD v10[3]; // [rsp+48h] [rbp-38h] BYREF
  __int128 v11; // [rsp+60h] [rbp-20h]
  __int64 v12; // [rsp+78h] [rbp-8h]
  __int64 v13; // [rsp+80h] [rbp+0h] BYREF
  __int64 v14; // [rsp+88h] [rbp+8h] BYREF
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+90h] [rbp+10h] BYREF
  int v16; // [rsp+A0h] [rbp+20h] BYREF
  char v17; // [rsp+A4h] [rbp+24h]

  v12 = a4;
  ByteOffset = &v13;
  v13 = a5;
  IoStatusBlock = xmmword_7FF705402440;
  Length = -1;
  if ( a3 < 0xFFFFFFFF )
    Length = a3;
  v7 = *a1;
  if ( (a4 & 1) == 0 )
    ByteOffset = 0LL;
  Status = NtWriteFile(v7, 0LL, 0LL, 0LL, &IoStatusBlock, Buffer, Length, ByteOffset, 0LL);
  if ( Status == 259 )
  {
    WaitForSingleObject(v7, 0xFFFFFFFF);
    Status = IoStatusBlock.Status;
    if ( IoStatusBlock.Status == 259 )
    {
      v16 = 0;
      v17 = 0;
      v10[0] = &off_7FF7054024A8;
      v10[1] = 1LL;
      v10[2] = 8LL;
      v11 = 0LL;
      v14 = sub_7FF7053EB620(&v16, v10);
      sub_7FF7053E6BF0(&v14);
      __fastfail(7u);
    }
  }
  if ( Status >= 0 )
    return 0LL;
  RtlNtStatusToDosError(Status);
  return 1LL;
}
// 7FF705402440: using guessed type __int128 xmmword_7FF705402440;
// 7FF7054024A8: using guessed type char *off_7FF7054024A8;

//----- (00007FF7053F0260) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053F0260(__int64 *a1, DWORD a2)
{
  DWORD v2; // edi
  HMODULE v4; // r14
  DWORD v5; // ecx
  HMODULE ModuleHandleW; // rax
  DWORD v7; // eax
  __int64 v8; // r8
  unsigned __int64 result; // rax
  __int64 (__fastcall *v10)(int *, __int64); // r14
  __int64 (__fastcall *v11)(int *, __int64); // r8
  char v12; // r9
  __int64 (__fastcall *v13)(int *, __int64); // rax
  unsigned int v14; // r9d
  char v15; // r10
  char v16; // r11
  int v17; // r11d
  int v18; // r10d
  unsigned int v19; // r10d
  WCHAR Buffer[2048]; // [rsp+40h] [rbp-40h] BYREF
  char **v21; // [rsp+1040h] [rbp+FC0h] BYREF
  __int64 v22; // [rsp+1048h] [rbp+FC8h]
  __int64 *v23; // [rsp+1050h] [rbp+FD0h]
  __int64 v24; // [rsp+1058h] [rbp+FD8h]
  __int64 v25; // [rsp+1060h] [rbp+FE0h]
  __int64 (__fastcall *v26)(int *, __int64); // [rsp+1070h] [rbp+FF0h]
  __int64 v27; // [rsp+1078h] [rbp+FF8h] BYREF
  __int64 (__fastcall *v28)(int *, __int64); // [rsp+1080h] [rbp+1000h]
  _QWORD *v29; // [rsp+1088h] [rbp+1008h]
  __int64 (__fastcall *v30)(int *, __int64); // [rsp+1090h] [rbp+1010h]
  _QWORD v31[3]; // [rsp+1098h] [rbp+1018h] BYREF
  DWORD v32; // [rsp+10B4h] [rbp+1034h] BYREF
  __int64 v33; // [rsp+10B8h] [rbp+1038h]

  v33 = -2LL;
  v2 = a2;
  v32 = a2;
  v4 = 0LL;
  memset(Buffer, 0, sizeof(Buffer));
  v5 = 4608;
  if ( (v2 & 0x10000000) != 0 )
  {
    ModuleHandleW = GetModuleHandleW(L"NTDLL.DLL");
    if ( ModuleHandleW )
    {
      v4 = ModuleHandleW;
      v2 &= ~0x10000000u;
      v32 = v2;
      v5 = 6656;
    }
    else
    {
      v4 = 0LL;
      v5 = 4608;
    }
  }
  v7 = FormatMessageW(v5, v4, v2, 0, Buffer, 0x800u, 0LL);
  if ( !v7 )
  {
    LODWORD(v31[0]) = GetLastError();
    v27 = &v32;
    v28 = sub_7FF7053FC250;
    v29 = v31;
    v30 = sub_7FF7053FC250;
    v21 = &off_7FF7054024F8;
    v22 = 3LL;
    v25 = 0LL;
    v23 = &v27;
    v24 = 2LL;
    return sub_7FF7053F80F0(a1, &v21, v8);
  }
  if ( v7 >= 0x801 )
    sub_7FF7053FE4E0(v7, 2048LL, &off_7FF705402550);
  sub_7FF7053F82C0(&v27, Buffer, v7);
  if ( __OFSUB__(-v27, 1LL) )
  {
    v31[0] = &v32;
    v31[1] = sub_7FF7053FC250;
    v21 = &off_7FF7054025B0;
    v22 = 2LL;
    v25 = 0LL;
    v23 = v31;
    v24 = 1LL;
    return sub_7FF7053F80F0(a1, &v21, v8);
  }
  v10 = v28;
  if ( !v29 )
  {
LABEL_36:
    result = 0LL;
    goto LABEL_37;
  }
  v11 = (v29 + v28);
  while ( 1 )
  {
    v13 = v11;
    v14 = *(v11 - 1);
    if ( (v14 & 0x80000000) != 0 )
    {
      v15 = *(v11 - 2);
      if ( v15 >= -64 )
      {
        v11 = (v11 - 2);
        v18 = v15 & 0x1F;
      }
      else
      {
        v16 = *(v11 - 3);
        if ( v16 >= -64 )
        {
          v11 = (v11 - 3);
          v17 = v16 & 0xF;
        }
        else
        {
          v11 = (v11 - 4);
          v17 = ((*(v13 - 4) & 7) << 6) | v16 & 0x3F;
        }
        v18 = (v17 << 6) | v15 & 0x3F;
      }
      v14 = (v18 << 6) | v14 & 0x3F;
      if ( v14 - 9 < 5 )
        goto LABEL_15;
    }
    else
    {
      v11 = (v11 - 1);
      if ( v14 - 9 < 5 )
        goto LABEL_15;
    }
    if ( v14 == 32 )
      goto LABEL_15;
    if ( v14 < 0x80 )
      break;
    v19 = v14 >> 8;
    if ( v14 >> 8 <= 0x1F )
    {
      if ( v19 )
      {
        if ( v19 != 22 )
          break;
        v12 = v14 == 5760;
      }
      else
      {
        v12 = *(off_7FF70540B078 + v14);
      }
      goto LABEL_14;
    }
    if ( v19 == 32 )
    {
      v12 = *(off_7FF70540B078 + v14) >> 1;
      goto LABEL_14;
    }
    if ( v19 != 48 )
      break;
    v12 = v14 == 12288;
LABEL_14:
    if ( (v12 & 1) == 0 )
      break;
LABEL_15:
    if ( v28 == v11 )
      goto LABEL_36;
  }
  result = v13 - v28;
  if ( result <= v29 )
  {
    if ( result != 0 && result < v29 && *(v28 + result) <= -65 )
    {
      v26 = v28;
      v31[2] = v27;
      sub_7FF7053FE1B0(
        "assertion failed: self.is_char_boundary(new_len)/rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\\library\\alloc\\"
        "src\\raw_vec\\mod.rs",
        48LL,
        &off_7FF705402568);
    }
  }
  else
  {
    result = v29;
  }
LABEL_37:
  *a1 = v27;
  a1[1] = v10;
  a1[2] = result;
  return result;
}
// 7FF7053F0422: variable 'v8' is possibly undefined
// 7FF7054024F8: using guessed type char *off_7FF7054024F8;
// 7FF705402550: using guessed type char *off_7FF705402550;
// 7FF705402568: using guessed type char *off_7FF705402568;
// 7FF7054025B0: using guessed type char *off_7FF7054025B0;
// 7FF70540B078: using guessed type _UNKNOWN *off_7FF70540B078;

//----- (00007FF7053F0650) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_OWORD *__fastcall sub_7FF7053F0650(__int64 a1)
{
  unsigned __int64 v1; // r8
  unsigned __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rbx
  unsigned __int64 v5; // r14
  WCHAR *p_Filename; // r15
  unsigned __int64 i; // r12
  unsigned __int64 v8; // r8
  DWORD ModuleFileNameW; // eax
  bool v10; // cc
  unsigned __int64 v11; // r12
  __int128 v12; // xmm0
  _OWORD *result; // rax
  unsigned __int64 v14; // rdx
  __int64 v15; // rax
  _QWORD *v16; // rcx
  WCHAR Filename; // [rsp+28h] [rbp-58h] BYREF
  _OWORD v18[2]; // [rsp+428h] [rbp+3A8h] BYREF
  __int64 v19; // [rsp+448h] [rbp+3C8h]
  __int64 v20; // [rsp+450h] [rbp+3D0h]
  unsigned __int64 v21; // [rsp+458h] [rbp+3D8h] BYREF
  __int64 v22; // [rsp+460h] [rbp+3E0h]
  __int64 v23; // [rsp+468h] [rbp+3E8h]
  __int64 v24; // [rsp+470h] [rbp+3F0h]

  v24 = -2LL;
  v20 = a1;
  v21 = 0LL;
  v22 = 2LL;
  v23 = 0LL;
  v1 = 512LL;
  v19 = 2LL;
  v2 = 0LL;
  v3 = 0LL;
  v4 = 0LL;
LABEL_4:
  while ( 2 )
  {
    v5 = 512LL;
    p_Filename = &Filename;
    for ( i = v1; ; i = v4 )
    {
      SetLastError(0);
      ModuleFileNameW = GetModuleFileNameW(0LL, p_Filename, i);
      if ( !ModuleFileNameW )
        break;
      v1 = ModuleFileNameW;
      v10 = ModuleFileNameW <= i;
      if ( ModuleFileNameW != i )
        goto LABEL_2;
LABEL_15:
      if ( GetLastError() != 122 )
        sub_7FF7053FE1B0(
          "internal error: entered unreachable code/rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\\library\\alloc\\src\\vec\\mod.rs",
          40LL,
          &off_7FF705402698);
      v11 = 2 * i;
      if ( v11 >= 0xFFFFFFFF )
        v11 = 0xFFFFFFFFLL;
      v1 = v11;
      if ( v11 < 0x201 )
        goto LABEL_4;
LABEL_5:
      v8 = v1 - v4;
      if ( v8 > v3 - v4 )
      {
        sub_7FF7053FD5A0(&v21, v4, v8, 2LL, 2LL);
        v2 = v21;
        v19 = v22;
      }
      v4 = 0xFFFFFFFFLL;
      if ( v2 < 0xFFFFFFFF )
        v4 = v2;
      v23 = v4;
      v3 = v2;
      v5 = v4;
      p_Filename = v19;
    }
    if ( GetLastError() )
    {
      LODWORD(v15) = GetLastError();
      v16 = v20;
      *(v20 + 8) = (v15 << 32) | 2;
      result = 0x8000000000000000LL;
      *v16 = 0x8000000000000000uLL;
      v14 = v21;
      if ( !v21 )
        return result;
      return sub_7FF7053E5E40(v22, 2 * v14, 2LL);
    }
    v1 = 0LL;
    v10 = 1;
    if ( !i )
      goto LABEL_15;
LABEL_2:
    if ( !v10 )
    {
      if ( v1 < 0x201 )
        continue;
      goto LABEL_5;
    }
    break;
  }
  if ( v1 > v5 )
    sub_7FF7053FE4E0(v1, v5, &off_7FF705402680);
  sub_7FF7053EB920(v18, p_Filename, v1);
  v12 = v18[0];
  result = v20;
  *(v20 + 16) = v18[1];
  *result = v12;
  v14 = v21;
  if ( v21 )
    return sub_7FF7053E5E40(v22, 2 * v14, 2LL);
  return result;
}
// 7FF7053F0840: variable 'v15' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705402680: using guessed type char *off_7FF705402680;
// 7FF705402698: using guessed type char *off_7FF705402698;

//----- (00007FF7053F08F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053F08F0(UINT a1)
{
  ExitProcess(a1);
}

//----- (00007FF7053F0910) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F0910(__int64 a1, char *a2, __int64 a3)
{
  __int64 v3; // r15
  __int64 v4; // r12
  unsigned __int64 v5; // r14
  __int64 v9; // rax
  __int64 v10; // rcx
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rax
  _WORD *v13; // rdx
  char *v15[2]; // [rsp+28h] [rbp-38h] BYREF
  __int16 v16; // [rsp+38h] [rbp-28h]
  __int128 v17; // [rsp+40h] [rbp-20h] BYREF
  unsigned __int64 v18; // [rsp+50h] [rbp-10h]
  __int64 v19; // [rsp+58h] [rbp-8h]

  v19 = -2LL;
  v3 = 0LL;
  v4 = a3 + 1;
  v5 = 2 * a3 + 2;
  if ( a3 + 1 < 0 || v5 > 0x7FFFFFFFFFFFFFFELL )
LABEL_5:
    sub_7FF7053FDFF0(v3, v5, &off_7FF705402608);
  if ( 2 * a3 == -2 )
  {
    v9 = 2LL;
    v4 = 0LL;
  }
  else
  {
    nullsub_1();
    v3 = 2LL;
    v9 = sub_7FF7053E5E30(v5, 2LL);
    if ( !v9 )
      goto LABEL_5;
  }
  *&v17 = v4;
  *(&v17 + 1) = v9;
  v18 = 0LL;
  v15[0] = a2;
  v15[1] = &a2[a3];
  v16 = 0;
  sub_7FF7053E7780(&v17, v15);
  v10 = *(&v17 + 1);
  v11 = v18;
  v12 = v18;
  v13 = *(&v17 + 1);
  if ( v18 < 8 )
  {
LABEL_18:
    if ( !v12
      || *v13
      && (v12 == 1
       || v13[1]
       && (v12 == 2
        || v13[2]
        && (v12 == 3
         || v13[3]
         && (v12 == 4
          || v13[4] && (v12 == 5 || v13[5] && (v12 == 6 || (LOBYTE(v12) = v12 == 7, (v12 & (v13[6] != 0)) != 0))))))) )
    {
      if ( v18 == v17 )
      {
        LOBYTE(v12) = sub_7FF7053E7B40(&v17, &off_7FF705402668);
        v10 = *(&v17 + 1);
      }
      *(v10 + 2 * v11) = 0;
      v18 = v11 + 1;
      *(a1 + 16) = v11 + 1;
      *a1 = v17;
      return v12;
    }
  }
  else
  {
    v13 = *(&v17 + 1);
    v12 = v18;
    while ( *v13 && v13[1] && v13[2] && v13[3] && v13[4] && v13[5] && v13[6] && v13[7] )
    {
      v12 -= 8LL;
      v13 += 8;
      if ( v12 <= 7 )
        goto LABEL_18;
    }
  }
  *(a1 + 8) = &off_7FF705402650;
  LOBYTE(v12) = 0;
  *a1 = 0x8000000000000000uLL;
  if ( v17 )
    LOBYTE(v12) = sub_7FF7053E5E40(v10, 2 * v17, 2LL);
  return v12;
}
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 nullsub_1(void);
// 7FF705402608: using guessed type char *off_7FF705402608;
// 7FF705402650: using guessed type char *off_7FF705402650;
// 7FF705402668: using guessed type char *off_7FF705402668;

//----- (00007FF7053F0B80) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F0B80(__int64 a1, __int64 a2)
{
  HMODULE ModuleHandleA; // rax
  HRESULT (__stdcall *SetThreadDescription)(HANDLE, PCWSTR); // rax
  void *v6; // r8

  ModuleHandleA = GetModuleHandleA("kernel32");
  if ( ModuleHandleA )
  {
    SetThreadDescription = GetProcAddress(ModuleHandleA, "SetThreadDescription");
    v6 = sub_7FF7053F0BF0;
    if ( SetThreadDescription )
      v6 = SetThreadDescription;
  }
  else
  {
    v6 = sub_7FF7053F0BF0;
  }
  off_7FF70540B028 = v6;
  return (v6)(a1, a2);
}
// 7FF70540B028: using guessed type _UNKNOWN *off_7FF70540B028;

//----- (00007FF7053F0BF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053F0BF0()
{
  SetLastError(0x78u);
  return 2147500033LL;
}

//----- (00007FF7053F0C10) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo, _QWORD *ThreadLocalStoragePointer)
{
  _QWORD *v2; // rax
  const char *v3; // rcx

  if ( ExceptionInfo->ExceptionRecord->ExceptionCode != -1073741571 )
    return 0LL;
  try
  {
    v2 = *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 80LL);
    if ( v2 <= 2 )
    {
      if ( !qword_7FF70540B200
        || (ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer,
            *(ThreadLocalStoragePointer[TlsIndex] + 8LL) != qword_7FF70540B200) )
      {
LABEL_10:
        sub_7FF7053F0D00(0LL, ThreadLocalStoragePointer);
        return 0LL;
      }
    }
    else
    {
      v3 = v2[1];
      if ( v3 )
      {
        sub_7FF7053F0D00(v3, v2[2] - 1LL);
        return 0LL;
      }
      if ( *v2 != qword_7FF70540B200 )
        goto LABEL_10;
    }
    sub_7FF7053F0D00("main\"", 4LL);
  }
  catch ( ... )
  {
    sub_7FF7053FE29A();
  }
  return 0LL;
}
// 7FF7053FE29A: using guessed type void __noreturn sub_7FF7053FE29A(void);
// 7FF70540B200: using guessed type __int64 qword_7FF70540B200;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053F0D00) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F0D00(const char *a1, __int64 a2)
{
  bool v2; // zf
  const char *v3; // rax
  __int64 v4; // rcx
  __int64 result; // rax
  __int64 v6; // rdx
  _QWORD v7[6]; // [rsp+28h] [rbp-58h] BYREF
  _QWORD v8[2]; // [rsp+58h] [rbp-28h] BYREF
  _QWORD v9[2]; // [rsp+68h] [rbp-18h] BYREF
  __int64 v10; // [rsp+78h] [rbp-8h]
  __int64 v11; // [rsp+80h] [rbp+0h]
  __int64 v12; // [rsp+88h] [rbp+8h]
  int v13; // [rsp+90h] [rbp+10h] BYREF
  char v14; // [rsp+94h] [rbp+14h]
  __int64 v15; // [rsp+98h] [rbp+18h]

  v15 = -2LL;
  v2 = a1 == 0LL;
  v3 = aUnknown;
  if ( a1 )
    v3 = a1;
  v4 = 9LL;
  if ( !v2 )
    v4 = a2;
  v9[0] = v3;
  v9[1] = v4;
  v13 = 0;
  v14 = 0;
  v8[0] = v9;
  v8[1] = sub_7FF7053E5F90;
  v7[0] = &off_7FF7054026F0;
  v7[1] = 2LL;
  v7[4] = 0LL;
  v7[2] = v8;
  v7[3] = 1LL;
  result = sub_7FF7053EB620(&v13, v7);
  if ( (result & 3) == 1 )
  {
    v10 = result - 1;
    v11 = *(result - 1);
    v12 = *(result + 7);
    if ( *v12 )
      (*v12)(v11);
    v6 = *(v12 + 8);
    if ( v6 )
      sub_7FF7053E5E40(v11, v6, *(v12 + 16));
    return sub_7FF7053E5E40(v10, 24LL, 8LL);
  }
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF7054026F0: using guessed type char *off_7FF7054026F0;

//----- (00007FF7053F0E50) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
LPVOID __fastcall sub_7FF7053F0E50(__int64 a1, DWORD a2, SIZE_T a3)
{
  HANDLE ProcessHeap; // rax

  ProcessHeap = GetProcessHeap();
  if ( ProcessHeap )
    return HeapAlloc(ProcessHeap, a2, a3);
  else
    return 0LL;
}

//----- (00007FF7053F0E90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F0E90(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int8 v3; // r10
  unsigned __int8 v4; // si
  __int64 v5; // r9
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // r11
  unsigned __int8 v8; // al
  unsigned __int8 v9; // r14
  unsigned __int8 v10; // di
  __int64 v11; // r9
  char v12; // r15
  int v13; // r10d
  __int64 v14; // r9
  unsigned __int64 v15; // r11
  unsigned __int64 v16; // r10
  unsigned __int64 v17; // rsi
  __int64 v18; // rbx
  unsigned __int8 v19; // al
  __int64 v20; // r9
  int v21; // r11d
  __int64 v22; // r11
  __int64 v23; // r11
  __int64 v24; // rsi
  __int64 v25; // r8
  int v26; // edi
  __int64 v27; // rdi
  _BYTE *v29; // rdx
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // r8
  int v32; // r9d
  unsigned __int8 *v33; // rax
  unsigned __int64 v34; // r9
  int v35; // r10d
  unsigned __int8 v36; // dl
  unsigned __int64 v37; // r8
  unsigned __int64 v38; // rdx
  unsigned __int64 v39; // rdi
  unsigned __int64 v40; // r11
  unsigned __int64 v41; // r8

  if ( a3 )
  {
    v3 = *a2;
    v4 = 92;
    if ( *a2 == 47 )
      v3 = 92;
    if ( a3 == 1 )
    {
      v5 = 0LL;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v4 = 0;
    }
    else
    {
      if ( a2[1] != 47 )
        v4 = a2[1];
      if ( a3 == 2 )
      {
        v5 = 0LL;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        v9 = 0;
        v10 = 0;
      }
      else
      {
        v10 = a2[2];
        v9 = 92;
        if ( v10 == 47 )
          v10 = 92;
        if ( a3 == 3 )
        {
          v5 = 0LL;
          v6 = 0;
          v7 = 0;
          v8 = 0;
          v9 = 0;
        }
        else
        {
          if ( a2[3] != 47 )
            v9 = a2[3];
          if ( a3 == 4 )
          {
            v5 = 0LL;
            v6 = 0;
            v7 = 0;
            v8 = 0;
          }
          else
          {
            v8 = a2[4];
            v7 = 92;
            if ( v8 == 47 )
              v8 = 92;
            if ( a3 == 5 )
            {
              v5 = 0LL;
              v6 = 0;
              v7 = 0;
            }
            else
            {
              if ( a2[5] != 47 )
                v7 = a2[5];
              if ( a3 == 6 )
              {
                v5 = 0LL;
                v6 = 0;
              }
              else
              {
                v6 = a2[6];
                v11 = 92LL;
                if ( v6 == 47 )
                  v6 = 92;
                if ( a3 == 7 )
                {
                  v5 = 0LL;
                }
                else
                {
                  if ( a2[7] != 47 )
                    v11 = a2[7];
                  v5 = v11 << 56;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    v5 = 0LL;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v4 = 0;
    v3 = 0;
  }
  v12 = 8;
  if ( a3 < 8 )
    v12 = a3;
  if ( a3 < 2 || ((v4 << 8) | v3) != 0x5C5C )
  {
    if ( a3 >= 2 && a2[1] == 58 )
    {
      v19 = *a2;
      if ( ((*a2 & 0xDF) - 65) < 0x1Au )
      {
        *a1 = 5;
        *(a1 + 1) = v19 ^ (32 * (v19 >= 0x61u));
        return a1;
      }
    }
    goto LABEL_71;
  }
  if ( (v12 & 0xE) == 2 )
  {
LABEL_58:
    if ( a3 != 2 )
    {
LABEL_59:
      v20 = 0LL;
      while ( 1 )
      {
        v21 = a2[v20 + 2];
        if ( v21 == 47 || v21 == 92 )
          break;
        v22 = v20 - a3 + 1;
        ++v20;
        if ( v22 == -2 )
          goto LABEL_71;
      }
      v23 = a3 - 3 - v20;
      if ( a3 - 3 != v20 )
      {
        v24 = v20 - a3;
        v25 = 0LL;
        while ( 1 )
        {
          v26 = a2[v25 + 3 + v20];
          if ( v26 == 47 || v26 == 92 )
            break;
          v27 = v24 + v25++;
          if ( v27 == -4 )
          {
            v25 = v23;
            break;
          }
        }
        if ( v25 != 0 && v20 != 0 )
        {
          *a1 = 4;
          *(a1 + 8) = a2 + 2;
          *(a1 + 16) = v20;
          *(a1 + 24) = &a2[v20 + 3];
          *(a1 + 32) = v25;
          return a1;
        }
      }
    }
LABEL_71:
    *a1 = 6;
    return a1;
  }
  v13 = ((v9 << 8) | v10);
  if ( v13 != 23598 )
  {
    if ( v13 == 23615 )
    {
      if ( a3 <= 3 )
        sub_7FF7053FE4E0(4LL, a3, &off_7FF705402828);
      if ( *a2 != 47 && a2[1] != 47 && a2[2] != 47 && a2[3] != 47 )
      {
        if ( (v12 & 0xC) != 4 && (v5 | (v6 << 48) | (v7 << 40) | (v8 << 32)) == 0x5C434E5500000000LL )
        {
          if ( a3 <= 7 )
            sub_7FF7053FE4D0(8LL, a3, &off_7FF705402840);
          v14 = 1LL;
          v15 = a3 - 8;
          if ( a3 == 8 )
          {
            v15 = 0LL;
            v16 = 0LL;
          }
          else
          {
            v16 = 0LL;
            v17 = 0LL;
            while ( a2[v17 + 8] != 92 )
            {
              v18 = v17 - a3 + 1;
              ++v17;
              if ( v18 == -8 )
                goto LABEL_104;
            }
            v14 = &a2[v17 + 9];
            v39 = a3 - 9 - v17;
            if ( a3 - 9 == v17 )
            {
              v16 = 0LL;
            }
            else
            {
              v40 = v17 - a3;
              v16 = 0LL;
              while ( a2[v16 + 9 + v17] != 92 )
              {
                v41 = v40 + v16++;
                if ( v41 == -10LL )
                {
                  v15 = v17;
                  v16 = v39;
                  goto LABEL_104;
                }
              }
            }
            v15 = v17;
          }
LABEL_104:
          *a1 = 1;
          *(a1 + 8) = a2 + 8;
          *(a1 + 16) = v15;
          *(a1 + 24) = v14;
          *(a1 + 32) = v16;
          return a1;
        }
        v33 = a2 + 4;
        v34 = a3 - 4;
        if ( a3 - 4 < 3 )
        {
          if ( a3 == 4 )
          {
LABEL_96:
            *a1 = 0;
            *(a1 + 8) = v33;
            *(a1 + 16) = v34;
            return a1;
          }
          if ( a3 != 6 )
          {
LABEL_90:
            v37 = a3 - 4;
            v38 = 0LL;
            while ( v33[v38] != 92 )
            {
              if ( v37 == ++v38 )
                goto LABEL_96;
            }
            v34 = v38;
            goto LABEL_96;
          }
        }
        else
        {
          v35 = a2[6];
          if ( v35 != 47 && v35 != 92 )
            goto LABEL_90;
        }
        if ( a2[5] == 58 )
        {
          v36 = *v33;
          if ( ((*v33 & 0xDF) - 65) <= 0x19u )
          {
            *a1 = 2;
            *(a1 + 1) = v36 ^ (32 * (v36 >= 0x61u));
            return a1;
          }
        }
        goto LABEL_90;
      }
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  if ( a3 <= 3 )
    sub_7FF7053FE4D0(4LL, a3, &off_7FF705402840);
  v29 = a2 + 4;
  v30 = 0LL;
  v31 = a3 - 4;
  if ( v31 )
  {
    while ( 1 )
    {
      v32 = v29[v30];
      if ( v32 == 47 || v32 == 92 )
        break;
      if ( v31 == ++v30 )
      {
        v30 = v31;
        break;
      }
    }
  }
  *a1 = 3;
  *(a1 + 8) = v29;
  *(a1 + 16) = v30;
  return a1;
}
// 7FF705402828: using guessed type char *off_7FF705402828;
// 7FF705402840: using guessed type char *off_7FF705402840;

//----- (00007FF7053F1350) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F1350(DWORD a1, char *a2, unsigned __int64 a3, unsigned __int8 *a4)
{
  HANDLE StdHandle; // r14
  __int64 result; // rax
  __int64 v9; // rax
  unsigned __int8 v10; // al
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // r8
  __int128 v13; // kr00_16
  __int64 v14; // rdx
  char v15; // cl
  __int64 v16; // rax
  __int64 v17; // [rsp+20h] [rbp-60h]
  __int64 v18; // [rsp+30h] [rbp-50h] BYREF
  __int64 v19; // [rsp+38h] [rbp-48h] BYREF
  _QWORD v20[2]; // [rsp+40h] [rbp-40h] BYREF
  __int128 v21; // [rsp+50h] [rbp-30h] BYREF
  _BYTE v22[8]; // [rsp+60h] [rbp-20h] BYREF
  __int128 v23; // [rsp+68h] [rbp-18h]
  DWORD Mode[2]; // [rsp+78h] [rbp-8h] BYREF
  __int128 v25; // [rsp+80h] [rbp+0h]
  __int128 v26; // [rsp+90h] [rbp+10h]
  __int64 v27; // [rsp+A8h] [rbp+28h]

  v27 = -2LL;
  if ( !a3 )
    return 0LL;
  StdHandle = GetStdHandle(a1);
  result = 1LL;
  if ( !StdHandle )
    return result;
  if ( StdHandle == -1LL )
  {
    GetLastError();
    return 1LL;
  }
  Mode[0] = 0;
  if ( !GetConsoleMode(StdHandle, Mode) || GetConsoleOutputCP() == 65001 )
  {
    *Mode = StdHandle;
    v20[1] = StdHandle;
    return sub_7FF7053F0140(Mode, a2, a3, 0LL, v17);
  }
  v9 = a4[4];
  if ( !a4[4] )
  {
    v12 = 4096LL;
    if ( a3 < 0x1000 )
      v12 = a3;
    sub_7FF7053FA930(v22, a2, v12);
    if ( (v22[0] & 1) != 0 )
    {
      if ( !v23 )
      {
        v16 = *a2;
        if ( a3 < byte_7FF70540287D[v16] )
        {
          *a4 = v16;
          a4[4] = 1;
          return 0LL;
        }
        return 1LL;
      }
      if ( v23 > a3 )
        sub_7FF7053FE4E0(v23, a3, &off_7FF7054029E8);
      sub_7FF7053FA930(Mode, a2, v23);
      if ( Mode[0] == 1 )
      {
        v21 = v25;
        sub_7FF7053FE440(aCalledResultUn, 43LL, &v21, &unk_7FF705400CA8, &off_7FF705402A00);
      }
      v13 = v25;
    }
    else
    {
      v13 = v23;
    }
    return sub_7FF7053F1680(StdHandle, v13, *(&v13 + 1));
  }
  if ( v9 >= 4u )
  {
    *Mode = &off_7FF705402A58;
    *&v25 = 1LL;
    *(&v25 + 1) = 8LL;
    v26 = 0LL;
    sub_7FF7053FE110(Mode, &off_7FF705402A68);
  }
  if ( *a2 >= -64 )
  {
    a4[4] = 0;
    return 1LL;
  }
  a4[v9] = *a2;
  v10 = a4[4] + 1;
  a4[4] = v10;
  v11 = byte_7FF70540287D[*a4];
  v20[0] = v11;
  if ( v10 < v11 )
    return 0LL;
  if ( v10 >= 5u )
    sub_7FF7053FE4E0(v10, 4LL, &off_7FF705402A80);
  sub_7FF7053FA930(v22, a4, v10);
  a4[4] = 0;
  if ( (v22[0] & 1) != 0 )
    return 1LL;
  v19 = *(&v23 + 1);
  if ( *(&v23 + 1) != v11 )
  {
    *Mode = 0LL;
    sub_7FF7053FE2B6(0, v20, &v19, Mode, &off_7FF705402A98);
  }
  v15 = sub_7FF7053F1680(StdHandle, v23, v11);
  result = 1LL;
  if ( (v15 & 1) == 0 )
  {
    v18 = v14;
    *&v21 = v11;
    if ( v11 != v14 )
    {
      *Mode = 0LL;
      sub_7FF7053FE2B6(0, &v18, &v21, Mode, &off_7FF705402AB0);
    }
    return 0LL;
  }
  return result;
}
// 7FF7053F13F7: variable 'v17' is possibly undefined
// 7FF7053F1532: variable 'v14' is possibly undefined
// 7FF70540287D: using guessed type unsigned __int8 byte_7FF70540287D[256];
// 7FF7054029E8: using guessed type char *off_7FF7054029E8;
// 7FF705402A00: using guessed type char *off_7FF705402A00;
// 7FF705402A58: using guessed type char *off_7FF705402A58;
// 7FF705402A68: using guessed type char *off_7FF705402A68;
// 7FF705402A80: using guessed type char *off_7FF705402A80;
// 7FF705402A98: using guessed type char *off_7FF705402A98;
// 7FF705402AB0: using guessed type char *off_7FF705402AB0;

//----- (00007FF7053F1680) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F1680(void *a1, CHAR *a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rsi
  _BOOL8 v5; // rcx
  signed int v6; // eax
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rdi
  WCHAR *v9; // rdx
  __int64 v10; // rdi
  unsigned __int64 v11; // rax
  __int64 v12; // rsi
  unsigned int v13; // ecx
  __int64 v14; // rdx
  WCHAR WideCharStr[4096]; // [rsp+30h] [rbp-50h] BYREF
  DWORD NumberOfCharsWritten[2]; // [rsp+2030h] [rbp+1FB0h] BYREF
  __int64 v18; // [rsp+2038h] [rbp+1FB8h]
  __int64 v19; // [rsp+2040h] [rbp+1FC0h]
  __int128 v20; // [rsp+2048h] [rbp+1FC8h]

  if ( a3 >= 0x1001 )
  {
    LODWORD(v4) = 4096;
    if ( a2[4096] <= -65 )
    {
      LODWORD(v4) = 4095;
      if ( a2[4095] <= -65 )
      {
        v5 = a2[4094] >= -64;
        v4 = v5 + 4093;
        if ( a2[v5 + 4093] < -64 )
          sub_7FF7053FE500(a2, a3, 0LL, v4, &off_7FF705402AC8);
      }
    }
  }
  else
  {
    LODWORD(v4) = a3;
  }
  v6 = MultiByteToWideChar(0xFDE9u, 8u, a2, v4, WideCharStr, 4096);
  if ( !v6 )
  {
    *NumberOfCharsWritten = &off_7FF705402B08;
    v18 = 1LL;
    v19 = 8LL;
    v20 = 0LL;
    sub_7FF7053FE110(NumberOfCharsWritten, &off_7FF705402B18);
  }
  v7 = v6;
  if ( v6 >= 0x1001 )
    sub_7FF7053FE4E0(v6, 4096LL, &off_7FF705402B30);
  NumberOfCharsWritten[0] = 0;
  if ( WriteConsoleW(a1, WideCharStr, v6, NumberOfCharsWritten, 0LL) )
  {
    v8 = NumberOfCharsWritten[0];
    if ( v7 != NumberOfCharsWritten[0] )
    {
      if ( v7 <= NumberOfCharsWritten[0] )
        sub_7FF7053FE234(NumberOfCharsWritten[0], v7, &off_7FF705402B48);
      if ( (WideCharStr[NumberOfCharsWritten[0]] + 8978) < 0x312u )
      {
        v9 = &WideCharStr[NumberOfCharsWritten[0]];
        NumberOfCharsWritten[0] = 0;
        if ( !WriteConsoleW(a1, v9, 1u, NumberOfCharsWritten, 0LL) )
          GetLastError();
        ++v8;
      }
      if ( v8 > v7 )
        sub_7FF7053FE4E0(v8, v7, &off_7FF705402B60);
      if ( v8 )
      {
        v10 = 2 * v8;
        v11 = 0LL;
        v12 = 0LL;
        do
        {
          v13 = WideCharStr[v11 / 2];
          v14 = 1LL;
          if ( v13 >= 0x80 )
          {
            v14 = 2LL;
            if ( v13 >= 0x800u )
              v14 = 2LL * ((v13 + 8978) >= 0x312u) + 1;
          }
          v12 += v14;
          v11 += 2LL;
        }
        while ( v10 != v11 );
      }
    }
    return 0LL;
  }
  else
  {
    GetLastError();
    return 1LL;
  }
}
// 7FF705402AC8: using guessed type char *off_7FF705402AC8;
// 7FF705402B08: using guessed type char *off_7FF705402B08;
// 7FF705402B18: using guessed type char *off_7FF705402B18;
// 7FF705402B30: using guessed type char *off_7FF705402B30;
// 7FF705402B48: using guessed type char *off_7FF705402B48;
// 7FF705402B60: using guessed type char *off_7FF705402B60;

//----- (00007FF7053F1900) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F1900(unsigned __int8 *a1, char *a2, unsigned __int64 a3)
{
  return sub_7FF7053F1350(0xFFFFFFF4, a2, a3, a1);
}

//----- (00007FF7053F1910) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053F1910()
{
  return 0LL;
}

//----- (00007FF7053F1920) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
volatile signed __int64 *__fastcall sub_7FF7053F1920(__int64 *a1)
{
  volatile signed __int64 *result; // rax

  *(a1 + 8) = 2;
  result = *a1;
  if ( *a1 )
  {
    if ( !_InterlockedDecrement64(result) )
      return sub_7FF7053E7980(a1);
  }
  return result;
}

//----- (00007FF7053F1940) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F1940(__int64 a1, __int64 a2)
{
  _QWORD *v3; // rax
  __int64 v5; // rbx
  _QWORD *v6; // rdx
  __int64 result; // rax
  __int64 v8; // rcx
  _QWORD v9[3]; // [rsp+28h] [rbp-48h] BYREF
  __int128 v10; // [rsp+40h] [rbp-30h]
  __int64 v11; // [rsp+58h] [rbp-18h] BYREF
  _QWORD *v12; // [rsp+60h] [rbp-10h]
  int v13; // [rsp+68h] [rbp-8h] BYREF
  char v14; // [rsp+6Ch] [rbp-4h]
  __int64 v15; // [rsp+70h] [rbp+0h]

  v15 = -2LL;
  v3 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  if ( v3[2] )
  {
    v13 = 0;
    v14 = 0;
    v9[0] = &off_7FF705402D20;
    v9[1] = 1LL;
    v9[2] = 8LL;
    v10 = 0LL;
    v11 = sub_7FF7053EB620(&v13, v9);
    sub_7FF7053E6BF0(&v11);
    __fastfail(7u);
  }
  v3[2] = -1LL;
  v5 = v3[5];
  v12 = v3 + 2;
  if ( v5 == v3[3] )
    sub_7FF7053E7A90(v12 + 1, &off_7FF705402CB0);
  v6 = v12;
  result = v12[2];
  v8 = 16 * v5;
  *(result + v8) = a1;
  *(result + v8 + 8) = a2;
  v6[3] = v5 + 1;
  ++*v6;
  return result;
}
// 7FF705402CB0: using guessed type char *off_7FF705402CB0;
// 7FF705402D20: using guessed type char *off_7FF705402D20;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053F1A60) ----------------------------------------------------
void __fastcall TlsCallback_0(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 *v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  void (__fastcall *v8)(__int64); // rax
  __int64 v9; // rdx
  __int64 v10; // rax
  __int64 v11; // rcx
  unsigned __int64 v12; // rax
  __int64 v13[3]; // [rsp+28h] [rbp-8h] BYREF

  v13[1] = -2LL;
  if ( a2 == 3 || !a2 )
  {
    v2 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
    if ( *(v2 + 16) )
    {
LABEL_18:
      try
      {
        sub_7FF7053FE030(&off_7FF705402D30);
      }
      catch ( ... )
      {
        sub_7FF7053FE29A();
      }
    }
    v3 = (v2 + 16);
    while ( 1 )
    {
      *v3 = -1LL;
      v4 = v3[3];
      if ( !v4 )
        break;
      v5 = v4 - 1;
      v3[3] = v5;
      v6 = v3[2];
      v5 *= 16LL;
      v7 = *(v6 + v5);
      v8 = *(v6 + v5 + 8);
      *v3 = 0LL;
      v8(v7);
      if ( *v3 )
        goto LABEL_18;
    }
    v9 = v3[1];
    if ( v9 )
    {
      sub_7FF7053E5E40(v3[2], 16 * v9, 8LL);
      v10 = *v3 + 1;
    }
    else
    {
      v10 = 0LL;
    }
    v3[1] = 0LL;
    v3[2] = 8LL;
    v3[3] = 0LL;
    *v3 = v10;
    v11 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
    v12 = *(v11 + 80);
    if ( v12 >= 3 )
    {
      *(v11 + 80) = 2LL;
      v13[0] = v12 - 16;
      if ( !_InterlockedDecrement64((v12 - 16)) )
        sub_7FF7053E7920(v13);
    }
  }
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF7053FE29A: using guessed type void __noreturn sub_7FF7053FE29A(void);
// 7FF705402D30: using guessed type char *off_7FF705402D30;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053F1BB0) ----------------------------------------------------
void __noreturn sub_7FF7053F1BB0()
{
  void (*v0)(void); // r8

  v0 = sub_7FF7053EE220;
  if ( qword_7FF70540B1B8 )
    v0 = qword_7FF70540B1B8;
  v0();
  __fastfail(7u);
}
// 7FF70540B1B8: using guessed type __int64 qword_7FF70540B1B8;

//----- (00007FF7053F1BE0) ----------------------------------------------------
void __noreturn sub_7FF7053F1BE0()
{
  sub_7FF7053F1BB0();
}

//----- (00007FF7053F1C00) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
int __fastcall sub_7FF7053F1C00(char a1, __int64 a2, __int64 a3, __int64 a4)
{
  HANDLE v8; // rcx
  unsigned int v9; // r8d
  HMODULE LibraryA; // rax
  __int64 (*v11)(void); // rcx
  DWORD (__stdcall *SymGetOptions)(); // rax
  int v13; // ecx
  DWORD (__stdcall *SymSetOptions)(DWORD); // rax
  int v15; // r15d
  BOOL (__stdcall *v16)(HANDLE, PCWSTR, BOOL); // r15
  BOOL (__stdcall *SymInitializeW)(HANDLE, PCWSTR, BOOL); // rax
  HANDLE CurrentProcess; // rax
  WCHAR *v19; // r15
  __int64 v20; // r12
  unsigned __int64 v21; // r12
  BOOL (__stdcall *v22)(HANDLE, PWSTR, DWORD); // r13
  BOOL (__stdcall *SymGetSearchPathW)(HANDLE, PWSTR, DWORD); // rax
  HANDLE v24; // rax
  __int64 v25; // rax
  DWORD CurrentProcessId; // eax
  unsigned __int64 v27; // rcx
  char v28; // r8
  unsigned __int8 v29; // dl
  char v30; // r9
  bool v31; // cf
  char v32; // dl
  char v33; // r8
  HANDLE MutexA; // rax
  signed __int64 v35; // rax
  void *v36; // r15
  LPCWSTR v37; // rax
  LPCWSTR v38; // rax
  BOOL (__stdcall *v39)(HANDLE, PENUMLOADED_MODULES_CALLBACKW64, PVOID); // r15
  BOOL (__stdcall *EnumerateLoadedModulesW64)(HANDLE, PENUMLOADED_MODULES_CALLBACKW64, PVOID); // rax
  HANDLE v41; // rax
  __int64 v42; // r13
  __int64 v43; // r15
  WCHAR *v44; // r12
  BOOL (__stdcall *v45)(HANDLE, PCWSTR); // r13
  BOOL (__stdcall *SymSetSearchPathW)(HANDLE, PCWSTR); // rax
  HANDLE v47; // rax
  WCHAR *v48; // rcx
  __int64 v49; // rdx
  __int64 v50; // rcx
  CHAR Name[16]; // [rsp+30h] [rbp-50h] BYREF
  __int128 v53; // [rsp+40h] [rbp-40h]
  char v54; // [rsp+50h] [rbp-30h]
  _BYTE v56[40]; // [rsp+60h] [rbp-20h] BYREF
  HANDLE hMutex; // [rsp+88h] [rbp+8h]
  LPCWSTR lpString[2]; // [rsp+90h] [rbp+10h] BYREF
  __int64 v59; // [rsp+A0h] [rbp+20h]
  char v60; // [rsp+AFh] [rbp+2Fh]
  __int64 v61; // [rsp+B0h] [rbp+30h]

  v61 = -2LL;
  v8 = hHandle;
  if ( hHandle )
    goto LABEL_2;
  strcpy(v56, "Local\\RustBacktraceMutex00000000");
  CurrentProcessId = GetCurrentProcessId();
  if ( CurrentProcessId )
  {
    v27 = 31LL;
    do
    {
      if ( v27 > 0x20 )
        sub_7FF7053FE234(-1LL, 33LL, &off_7FF705402378);
      v28 = (CurrentProcessId & 0xF) + 55;
      if ( (CurrentProcessId & 0xF) < 0xA )
        v28 = (CurrentProcessId & 0xF) + 48;
      v56[v27] = v28;
      if ( CurrentProcessId < 0x10 )
        break;
      v29 = (CurrentProcessId >> 4) & 0xF;
      v30 = v29 + 55;
      v31 = v29 < 0xAu;
      v32 = v29 + 48;
      v33 = v30;
      if ( v31 )
        v33 = v32;
      v56[v27 - 1] = v33;
      v27 -= 2LL;
      v31 = CurrentProcessId < 0x100;
      CurrentProcessId >>= 8;
    }
    while ( !v31 );
  }
  v54 = v56[32];
  v53 = *&v56[16];
  *Name = *v56;
  MutexA = CreateMutexA(0LL, 0, Name);
  if ( MutexA )
  {
    v8 = MutexA;
    v35 = _InterlockedCompareExchange64(&hHandle, MutexA, 0LL);
    if ( v35 )
    {
      v36 = v35;
      CloseHandle(v8);
      v8 = v36;
    }
LABEL_2:
    hMutex = v8;
    WaitForSingleObjectEx(v8, 0xFFFFFFFF, 0);
    LibraryA = hModule;
    if ( !hModule )
    {
      LibraryA = LoadLibraryA("dbghelp.dll");
      hModule = LibraryA;
      if ( !LibraryA )
      {
LABEL_58:
        LODWORD(MutexA) = ReleaseMutex(hMutex);
        return MutexA;
      }
    }
    if ( byte_7FF70540B1F0 )
    {
LABEL_53:
      if ( (a1 & 1) != 0 )
      {
        sub_7FF7053F2220(*(a2 + 16), *a2, *(a2 + 4), a3, *(a4 + 32));
      }
      else
      {
        v50 = a2 - 1;
        if ( !a2 )
          v50 = 0LL;
        sub_7FF7053F2220(v50, 0, v9, a3, *(a4 + 32));
      }
      goto LABEL_58;
    }
    v11 = qword_7FF70540B220;
    if ( !qword_7FF70540B220 )
    {
      SymGetOptions = GetProcAddress(LibraryA, "SymGetOptions");
      if ( !SymGetOptions )
        goto LABEL_52;
      v11 = SymGetOptions;
      qword_7FF70540B220 = SymGetOptions;
    }
    v13 = v11();
    SymSetOptions = qword_7FF70540B228;
    if ( !qword_7FF70540B228 )
    {
      v15 = v13;
      SymSetOptions = GetProcAddress(hModule, "SymSetOptions");
      if ( !SymSetOptions )
        goto LABEL_52;
      qword_7FF70540B228 = SymSetOptions;
      v13 = v15;
    }
    (SymSetOptions)(v13 | 4u);
    v16 = qword_7FF70540B230;
    if ( !qword_7FF70540B230 )
    {
      SymInitializeW = GetProcAddress(hModule, "SymInitializeW");
      if ( !SymInitializeW )
        goto LABEL_52;
      v16 = SymInitializeW;
      qword_7FF70540B230 = SymInitializeW;
    }
    CurrentProcess = GetCurrentProcess();
    (v16)(CurrentProcess, 0LL, 1LL);
    lpString[0] = 0LL;
    lpString[1] = 2;
    v59 = 0LL;
    v60 = 1;
    sub_7FF7053FD5A0(lpString, 0LL, 1024LL, 2LL, 2LL);
    v19 = lpString[1];
    v20 = v59;
    memset(&lpString[1][v59], 0, 0x7FEuLL);
    v19[v20 + 1023] = 0;
    v21 = v20 + 1024;
    v59 = v21;
    v22 = qword_7FF70540B238;
    if ( !qword_7FF70540B238 )
    {
      SymGetSearchPathW = GetProcAddress(hModule, "SymGetSearchPathW");
      if ( !SymGetSearchPathW )
      {
        if ( !lpString[0] )
          goto LABEL_52;
        v49 = 2 * lpString[0];
        v48 = v19;
        goto LABEL_51;
      }
      v22 = SymGetSearchPathW;
      qword_7FF70540B238 = SymGetSearchPathW;
    }
    v24 = GetCurrentProcess();
    if ( (v22)(v24, v19, v21) == 1 )
    {
      LODWORD(v25) = lstrlenW(v19);
      if ( v25 < 0 )
      {
        v60 = 1;
        sub_7FF7053FE1B0(aAssertionFaile_0, 26LL, &off_7FF7054023E0);
      }
      v25 = v25;
      if ( v21 < v25 )
      {
LABEL_40:
        *&v53 = v59;
        *Name = *lpString;
        v39 = qword_7FF70540B248;
        if ( !qword_7FF70540B248 )
        {
          EnumerateLoadedModulesW64 = GetProcAddress(hModule, "EnumerateLoadedModulesW64");
          if ( !EnumerateLoadedModulesW64 )
          {
            v43 = *Name;
            if ( !*Name )
              goto LABEL_52;
            v44 = *&Name[8];
            goto LABEL_50;
          }
          v39 = EnumerateLoadedModulesW64;
          qword_7FF70540B248 = EnumerateLoadedModulesW64;
        }
        v41 = GetCurrentProcess();
        (v39)(v41, sub_7FF7053EFE40, Name);
        *v56 = *Name;
        v42 = v53;
        *&v56[16] = v53;
        v43 = *Name;
        if ( v53 == *Name )
        {
          sub_7FF7053E7B40(v56, &off_7FF705402410);
          v43 = *v56;
        }
        v44 = *&v56[8];
        *(*&v56[8] + 2 * v42) = 0;
        v45 = qword_7FF70540B240;
        if ( !qword_7FF70540B240 )
        {
          SymSetSearchPathW = GetProcAddress(hModule, "SymSetSearchPathW");
          if ( !SymSetSearchPathW )
            goto LABEL_49;
          v45 = SymSetSearchPathW;
          qword_7FF70540B240 = SymSetSearchPathW;
        }
        v47 = GetCurrentProcess();
        (v45)(v47, v44);
LABEL_49:
        if ( v43 )
        {
LABEL_50:
          v48 = v44;
          v49 = 2 * v43;
LABEL_51:
          sub_7FF7053E5E40(v48, v49, 2LL);
        }
LABEL_52:
        byte_7FF70540B1F0 = 1;
        goto LABEL_53;
      }
LABEL_39:
      v59 = v25;
      goto LABEL_40;
    }
    v59 = 0LL;
    v37 = lpString[0];
    if ( lpString[0] )
    {
      *v19 = 46;
      v59 = 1LL;
      if ( v37 != 1 )
        goto LABEL_38;
    }
    else
    {
      v60 = 1;
      sub_7FF7053E7B40(lpString, &off_7FF705402390);
      v38 = lpString[0];
      v19 = lpString[1];
      *lpString[1] = 46;
      v59 = 1LL;
      if ( v38 != 1 )
      {
LABEL_38:
        v19[1] = 59;
        v25 = 2LL;
        goto LABEL_39;
      }
    }
    v60 = 1;
    sub_7FF7053E7B40(lpString, &off_7FF7054023A8);
    v19 = lpString[1];
    goto LABEL_38;
  }
  return MutexA;
}
// 7FF7053F20A4: variable 'v9' is possibly undefined
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF705402378: using guessed type char *off_7FF705402378;
// 7FF705402390: using guessed type char *off_7FF705402390;
// 7FF7054023A8: using guessed type char *off_7FF7054023A8;
// 7FF7054023E0: using guessed type char *off_7FF7054023E0;
// 7FF705402410: using guessed type char *off_7FF705402410;
// 7FF70540B1F0: using guessed type char byte_7FF70540B1F0;
// 7FF70540B220: using guessed type __int64 qword_7FF70540B220;
// 7FF70540B228: using guessed type __int64 qword_7FF70540B228;
// 7FF70540B230: using guessed type __int64 qword_7FF70540B230;
// 7FF70540B238: using guessed type __int64 qword_7FF70540B238;
// 7FF70540B240: using guessed type __int64 qword_7FF70540B240;
// 7FF70540B248: using guessed type __int64 qword_7FF70540B248;

//----- (00007FF7053F2220) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F2220(
        __int64 a1,
        char a2,
        unsigned int a3,
        __int64 a4,
        void (__fastcall *a5)(__int64, _QWORD *))
{
  HANDLE CurrentProcess; // rdi
  unsigned int (__fastcall *v9)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // rbx
  __int64 result; // rax
  __int64 v11; // r15
  int v12; // esi
  __int64 (__fastcall *v13)(HANDLE, __int64); // rsi
  __int64 (__fastcall *v14)(HANDLE, __int64, _QWORD, __int64, __int64, CHAR *, _QWORD *); // r14
  int v15; // eax
  int v16; // r13d
  unsigned int v17; // esi
  unsigned int v18; // r13d
  unsigned __int64 v19; // r9
  unsigned int v20; // eax
  __int64 v21; // rbx
  int v22; // edi
  int v23; // eax
  __int64 v24; // rdx
  int v25; // ecx
  __int64 v26; // r8
  __int64 v27; // r9
  _QWORD v29[511]; // [rsp+48h] [rbp-38h] BYREF
  CHAR MultiByteStr[16]; // [rsp+1040h] [rbp+FC0h] BYREF
  __int128 v31; // [rsp+1050h] [rbp+FD0h]
  __int128 v32; // [rsp+1060h] [rbp+FE0h]
  __int128 v33; // [rsp+1070h] [rbp+FF0h]
  __int128 v34; // [rsp+1080h] [rbp+1000h]
  __int128 v35; // [rsp+1090h] [rbp+1010h]
  __int128 v36; // [rsp+10A0h] [rbp+1020h]
  __int128 v37; // [rsp+10B0h] [rbp+1030h]
  __int128 v38; // [rsp+10C0h] [rbp+1040h]
  __int128 v39; // [rsp+10D0h] [rbp+1050h]
  __int128 v40; // [rsp+10E0h] [rbp+1060h]
  __int128 v41; // [rsp+10F0h] [rbp+1070h]
  __int128 v42; // [rsp+1100h] [rbp+1080h]
  __int128 v43; // [rsp+1110h] [rbp+1090h]
  __int128 v44; // [rsp+1120h] [rbp+10A0h]
  __int128 v45; // [rsp+1130h] [rbp+10B0h]
  int v46; // [rsp+1140h] [rbp+10C0h] BYREF
  __int64 v47; // [rsp+1148h] [rbp+10C8h]
  int v48; // [rsp+1150h] [rbp+10D0h]
  __int128 v49; // [rsp+1158h] [rbp+10D8h]
  _QWORD v50[3]; // [rsp+1168h] [rbp+10E8h] BYREF
  int v51; // [rsp+1180h] [rbp+1100h]
  int v52; // [rsp+1184h] [rbp+1104h]
  CHAR *v53; // [rsp+1188h] [rbp+1108h]
  __int64 v54; // [rsp+1190h] [rbp+1110h]
  __int64 v55; // [rsp+1198h] [rbp+1118h]
  __int64 v56; // [rsp+11A0h] [rbp+1120h]
  unsigned int (__fastcall *v57)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+11A8h] [rbp+1128h]
  HANDLE v58; // [rsp+11B0h] [rbp+1130h]
  __int64 (__fastcall *v59)(HANDLE, __int64, _QWORD, _QWORD, _QWORD *, int *); // [rsp+11B8h] [rbp+1138h]

  v56 = a4;
  CurrentProcess = GetCurrentProcess();
  v9 = qword_7FF70540B250;
  if ( qword_7FF70540B250 )
  {
    result = qword_7FF70540B258;
    v59 = qword_7FF70540B258;
    if ( qword_7FF70540B258 )
      goto LABEL_8;
  }
  else
  {
    result = GetProcAddress(hModule, "SymFromInlineContextW");
    if ( !result )
      return result;
    v9 = result;
    qword_7FF70540B250 = result;
    result = qword_7FF70540B258;
    v59 = qword_7FF70540B258;
    if ( qword_7FF70540B258 )
      goto LABEL_8;
  }
  result = GetProcAddress(hModule, "SymGetLineFromInlineContextW");
  v59 = result;
  if ( !result )
    return result;
  result = v59;
  qword_7FF70540B258 = v59;
LABEL_8:
  v11 = a1 - 1;
  if ( !a1 )
    v11 = 0LL;
  v12 = 1;
  if ( (a2 & 1) == 0 )
  {
    v13 = qword_7FF70540B260;
    if ( qword_7FF70540B260 )
    {
      v14 = qword_7FF70540B268;
      if ( !qword_7FF70540B268 )
      {
LABEL_16:
        result = GetProcAddress(hModule, "SymQueryInlineTrace");
        if ( !result )
          return result;
        v14 = result;
        qword_7FF70540B268 = result;
      }
    }
    else
    {
      result = GetProcAddress(hModule, "SymAddrIncludeInlineTrace");
      if ( !result )
        return result;
      v13 = result;
      qword_7FF70540B260 = result;
      v14 = qword_7FF70540B268;
      if ( !qword_7FF70540B268 )
        goto LABEL_16;
    }
    v15 = v13(CurrentProcess, v11);
    *MultiByteStr = 0;
    v12 = 1;
    if ( !v15 )
    {
      a3 = 0;
      v17 = 1;
      goto LABEL_22;
    }
    v16 = v15;
    LODWORD(v29[0]) = 0;
    a3 = 0;
    result = v14(CurrentProcess, v11, 0LL, v11, v11, MultiByteStr, v29);
    if ( result == 1 )
    {
      a3 = *MultiByteStr;
      v12 = v16 + 1;
    }
  }
  v17 = a3 + v12;
  if ( a3 < v17 )
  {
LABEL_22:
    LODWORD(result) = a3 + 1;
    v58 = CurrentProcess;
    v57 = v9;
    do
    {
      v18 = result;
      memset(v29 + 4, 0, 0xFF4uLL);
      LODWORD(v29[10]) = 2000;
      LODWORD(v29[0]) = 88;
      *MultiByteStr = 0LL;
      if ( v9(CurrentProcess, v11, a3, MultiByteStr, v29) == 1 )
      {
        v19 = LODWORD(v29[10]) - 1LL;
        if ( v19 >= HIDWORD(v29[9]) )
          LODWORD(v19) = HIDWORD(v29[9]);
        v45 = 0LL;
        v44 = 0LL;
        v43 = 0LL;
        v42 = 0LL;
        v41 = 0LL;
        v40 = 0LL;
        v39 = 0LL;
        v38 = 0LL;
        v37 = 0LL;
        v36 = 0LL;
        v35 = 0LL;
        v34 = 0LL;
        v33 = 0LL;
        v32 = 0LL;
        v31 = 0LL;
        *MultiByteStr = 0LL;
        v20 = WideCharToMultiByte(0xFDE9u, 0, &v29[10] + 2, v19, MultiByteStr, 256, 0LL, 0LL);
        if ( !v20 )
        {
          v21 = 256LL;
          goto LABEL_32;
        }
        if ( v20 <= 0x100 )
        {
          v21 = v20;
LABEL_32:
          v47 = 0LL;
          v48 = 0;
          v49 = 0LL;
          v46 = 40;
          LODWORD(v50[0]) = 0;
          v22 = 0;
          v23 = v59(v58, v11, a3, 0LL, v50, &v46);
          v27 = 0LL;
          if ( v23 == 1 )
          {
            v25 = v48;
            v26 = -1LL;
            v24 = v49;
            while ( *(v49 + 2 * v26++ + 2) != 0 )
              ;
            v27 = 1LL;
            v22 = 1;
          }
          v50[0] = v27;
          v50[1] = v24;
          v50[2] = v26;
          v51 = v22;
          v52 = v25;
          v53 = MultiByteStr;
          v54 = v21;
          v55 = v29[7];
          a5(v56, v50);
          CurrentProcess = v58;
          v9 = v57;
        }
      }
      result = (v18 < v17) + v18;
      a3 = v18;
    }
    while ( v18 < v17 );
  }
  return result;
}
// 22: found interdependent unknown calls
// 7FF7053F241B: variable 'v24' is possibly undefined
// 7FF7053F2422: variable 'v26' is possibly undefined
// 7FF7053F242F: variable 'v25' is possibly undefined
// 7FF70540B250: using guessed type __int64 qword_7FF70540B250;
// 7FF70540B258: using guessed type __int64 qword_7FF70540B258;
// 7FF70540B260: using guessed type __int64 qword_7FF70540B260;
// 7FF70540B268: using guessed type __int64 qword_7FF70540B268;

//----- (00007FF7053F2660) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F2660(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx

  if ( *a2 )
    (*a2)(a1);
  result = a2;
  v3 = *(a2 + 8);
  if ( v3 )
    return sub_7FF7053E5E40(a1, v3, *(a2 + 16));
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053F26F0) ----------------------------------------------------
_QWORD *__fastcall sub_7FF7053F26F0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // r8

  if ( !a2 || *a2 != &off_7FF70540B058 )
    sub_7FF7053EE6A0();
  v2 = *(a2 + 8);
  v3 = *(a2 + 16);
  *(a2 + 8) = 0LL;
  if ( !v2 )
  {
    try
    {
      sub_7FF7053FE090(&off_7FF705403300);
    }
    catch ( ... )
    {
      sub_7FF7053FE29A();
    }
  }
  *a1 = v2;
  a1[1] = v3;
  return a1;
}
// 7FF7053FE29A: using guessed type void __noreturn sub_7FF7053FE29A(void);
// 7FF705403300: using guessed type char *off_7FF705403300;
// 7FF70540B058: using guessed type void **off_7FF70540B058;

//----- (00007FF7053F2770) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053F2770(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  _QWORD pExceptionObject[3]; // [rsp+28h] [rbp-18h] BYREF

  v2 = (*(a2 + 32))();
  pExceptionObject[0] = &off_7FF70540B058;
  pExceptionObject[1] = v2;
  pExceptionObject[2] = v3;
  _InterlockedExchange(&pThrowInfo.pmfnUnwind, sub_7FF7053F2800 - &unk_7FF7053E0000);
  _InterlockedExchange(&pThrowInfo.pCatchableTypeArray, &unk_7FF70540B030 - &unk_7FF7053E0000);
  _InterlockedExchange(&dword_7FF70540B034, &unk_7FF70540B038 - &unk_7FF7053E0000);
  _InterlockedExchange(dword_7FF70540B03C, &off_7FF70540B058 - &unk_7FF7053E0000);
  _InterlockedExchange(&dword_7FF70540B050, sub_7FF7053FDE10 - &unk_7FF7053E0000);
  CxxThrowException(pExceptionObject, &pThrowInfo);
}
// 7FF7053F278C: variable 'v3' is possibly undefined
// 7FF7053E0000: using guessed type __int16 word_7FF7053E0000;
// 7FF70540B034: using guessed type int dword_7FF70540B034;
// 7FF70540B03C: using guessed type int dword_7FF70540B03C[5];
// 7FF70540B050: using guessed type int dword_7FF70540B050;
// 7FF70540B058: using guessed type void **off_7FF70540B058;

//----- (00007FF7053F2800) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F2800(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rcx

  result = a1;
  v2 = *(a1 + 8);
  if ( v2 )
  {
    sub_7FF7053F2660(v2, *(result + 16));
    sub_7FF7053EE570();
  }
  return result;
}

//----- (00007FF7053F2854) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F2854(unsigned __int8 **a1)
{
  unsigned __int8 *v1; // rdx
  unsigned __int8 *v2; // r9
  __int64 result; // rax
  bool v4; // cf
  unsigned __int8 *v5; // rdx
  unsigned __int8 *v6; // r10
  unsigned int v7; // r8d
  unsigned int v8; // eax
  unsigned int v9; // r8d
  unsigned int v10; // r11d
  char v11; // r11
  unsigned __int64 v12; // r8
  __int64 v13; // rdx
  char v14; // r9
  unsigned __int8 *v15; // r8
  __int16 *v16; // rax
  unsigned __int8 *v17; // r9
  __int64 v18; // r10
  unsigned int v19; // edi
  unsigned int v20; // esi
  unsigned int v21; // ebx
  unsigned int v22; // edi
  int v23; // eax
  int v24; // r11d
  int v25; // r10d
  _QWORD v26[6]; // [rsp+20h] [rbp-60h] BYREF
  unsigned __int64 v27; // [rsp+50h] [rbp-30h] BYREF
  char **v28; // [rsp+58h] [rbp-28h] BYREF
  char *v29; // [rsp+60h] [rbp-20h]
  _QWORD *v30; // [rsp+68h] [rbp-18h]
  __int64 (__fastcall *v31)(__int64, _QWORD *); // [rsp+70h] [rbp-10h]
  unsigned __int64 *v32; // [rsp+78h] [rbp-8h]
  __int64 (__fastcall *v33)(unsigned __int64 *, __int64); // [rsp+80h] [rbp+0h]
  _QWORD v34[2]; // [rsp+88h] [rbp+8h] BYREF
  char *v35; // [rsp+98h] [rbp+18h] BYREF
  __int64 v36; // [rsp+A0h] [rbp+20h]
  char v37; // [rsp+ACh] [rbp+2Ch] BYREF
  __int16 v38; // [rsp+ADh] [rbp+2Dh] BYREF
  char v39; // [rsp+AFh] [rbp+2Fh]

  v1 = a1[1];
  v2 = a1[4];
  result = 1114113LL;
  v4 = v1 < v2;
  v5 = (v1 - v2);
  if ( !v4 )
  {
    v6 = *a1;
    *a1 = &v2[*a1];
    a1[1] = v5;
    if ( v2 != 2 )
      sub_7FF7053FE1B0("internal error: entered unreachable code", 40LL, &off_7FF705403998);
    v7 = *v6;
    v8 = v7 - 48;
    if ( v7 >= 0x3A )
      v8 = ((v7 - 65) & 0xFFFFFFDF) + 10;
    if ( v8 > 0xF )
      goto LABEL_38;
    v9 = v6[1];
    v10 = v9 - 48;
    if ( v9 >= 0x3A )
      v10 = ((v9 - 65) & 0xFFFFFFDF) + 10;
    if ( v10 >= 0x10 )
LABEL_38:
      sub_7FF7053FE090(&off_7FF7054039B0);
    v11 = (16 * v8) | v10;
    if ( v11 < 0 )
    {
      result = 1114112LL;
      if ( v11 >= 0xC0u )
      {
        v12 = 2LL;
        if ( v11 < 0xE0u || (v12 = 3LL, v11 < 0xF0u) || (v12 = 4LL, v11 < 0xF8u) )
        {
          v16 = &v38;
          v37 = v11;
          v38 = 0;
          v39 = 0;
          v35 = &v37;
          v36 = v12;
          v17 = v6 + 4;
          v18 = 0LL;
          while ( &v5[v18] >= 2 )
          {
            *a1 = v17;
            a1[1] = &v5[v18 - 2];
            v19 = *(v17 - 2);
            v20 = v19 - 48;
            if ( v19 >= 0x3A )
              v20 = ((v19 - 65) & 0xFFFFFFDF) + 10;
            if ( v20 > 0xF )
              goto LABEL_38;
            v21 = *(v17 - 1);
            v22 = v21 - 48;
            if ( v21 >= 0x3A )
              v22 = ((v21 - 65) & 0xFFFFFFDF) + 10;
            if ( v22 >= 0x10 )
              goto LABEL_38;
            *v16 = (16 * v20) | v22;
            v18 -= 2LL;
            v16 = (v16 + 1);
            v17 += 2;
            if ( !(v18 + 2 * v12 - 2) )
              goto LABEL_11;
          }
          return 1114112LL;
        }
      }
    }
    else
    {
      v37 = v11;
      v38 = 0;
      v39 = 0;
      v35 = &v37;
      v36 = 1LL;
      v12 = 1LL;
LABEL_11:
      sub_7FF7053FA930(&v28, &v37, v12);
      result = 1114112LL;
      if ( (v28 & 1) == 0 )
      {
        v34[0] = v29;
        v34[1] = v30;
        v13 = v30 + v29;
        if ( !v30 )
          goto LABEL_40;
        v14 = *v29;
        if ( *v29 < 0 )
        {
          v23 = v14 & 0x1F;
          v24 = v29[1] & 0x3F;
          if ( v14 <= 0xDFu )
          {
            v15 = (v29 + 2);
            result = v24 | (v23 << 6);
          }
          else
          {
            v25 = (v24 << 6) | v29[2] & 0x3F;
            if ( v14 < 0xF0u )
            {
              v15 = (v29 + 3);
              result = v25 | (v23 << 12);
            }
            else
            {
              v15 = (v29 + 4);
              result = (v25 << 6) | v29[3] & 0x3F | ((v14 & 7) << 18);
            }
          }
        }
        else
        {
          v15 = (v29 + 1);
          result = *v29;
        }
        if ( v15 != v13 || result == 1114112 )
        {
LABEL_40:
          v27 = sub_7FF7053F337F(v29, v13);
          v28 = &v35;
          v29 = sub_7FF7053F2F85;
          v30 = v34;
          v31 = sub_7FF7053F2B89;
          v32 = &v27;
          v33 = sub_7FF7053FC390;
          v26[0] = &off_7FF705403A38;
          v26[1] = 4LL;
          v26[4] = 0LL;
          v26[2] = &v28;
          v26[3] = 3LL;
          sub_7FF7053FE110(v26, &off_7FF705403A78);
        }
      }
    }
  }
  return result;
}
// 7FF705403998: using guessed type char *off_7FF705403998;
// 7FF7054039B0: using guessed type char *off_7FF7054039B0;
// 7FF705403A38: using guessed type char *off_7FF705403A38;
// 7FF705403A78: using guessed type char *off_7FF705403A78;

//----- (00007FF7053F2B6A) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F2B6A(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rcx
  int v3; // eax

  v2 = *a1;
  v3 = *(a2 + 16);
  if ( (v3 & 0x2000000) != 0 )
    return sub_7FF7053FBDB0(v2, a2);
  if ( (v3 & 0x4000000) != 0 )
    return sub_7FF7053FBE40(v2, a2);
  return sub_7FF7053FC080(v2, a2);
}

//----- (00007FF7053F2B89) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F2B89(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053FA120(*a1, *(a1 + 8), a2);
}

//----- (00007FF7053F2B9B) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F2B9B(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9DC0(a2);
}

//----- (00007FF7053F2BC5) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F2BC5(__int64 *a1, __int64 *a2)
{
  return sub_7FF7053F7E2D(*a1, a2);
}

//----- (00007FF7053F2BCD) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F2BCD(__int64 a1, __int64 *a2)
{
  return sub_7FF7053FA4C0(*a1, *(a1 + 8), a2);
}

//----- (00007FF7053F2BDF) ----------------------------------------------------
char __fastcall sub_7FF7053F2BDF(__int64 a1, __int64 *a2)
{
  return sub_7FF7053F9980(a2, word_7FF705403360, 2uLL);
}
// 7FF705403360: using guessed type unsigned __int16 word_7FF705403360[4];

//----- (00007FF7053F2BF4) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F2BF4(__int64 a1, __int64 a2, _QWORD *a3)
{
  _BYTE v6[16]; // [rsp+20h] [rbp-10h] BYREF
  _QWORD v7[6]; // [rsp+30h] [rbp+0h] BYREF

  sub_7FF7053FA0C0(v6, a3);
  for ( ; a2; --a2 )
  {
    v7[0] = a1++;
    sub_7FF7053F90A0(v6, v7, &unk_7FF705403368);
  }
  return sub_7FF7053F91C0(v6);
}

//----- (00007FF7053F2C5B) ----------------------------------------------------
char __fastcall sub_7FF7053F2C5B(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // r8
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  v4 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(v4) = (a2 >> 18) | 0xF0;
        BYTE1(v4) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(v4) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(v4) = a2 & 0x3F | 0x80;
        v2 = 4LL;
      }
      else
      {
        LOBYTE(v4) = (a2 >> 12) | 0xE0;
        BYTE1(v4) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(v4) = a2 & 0x3F | 0x80;
        v2 = 3LL;
      }
    }
    else
    {
      LOBYTE(v4) = (a2 >> 6) | 0xC0;
      BYTE1(v4) = a2 & 0x3F | 0x80;
      v2 = 2LL;
    }
  }
  else
  {
    LOBYTE(v4) = a2;
    v2 = 1LL;
  }
  return sub_7FF7053F7E74(a1, &v4, v2);
}

//----- (00007FF7053F2D0E) ----------------------------------------------------
char __fastcall sub_7FF7053F2D0E(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9220(a1, &unk_7FF7054035B8, a2);
}

//----- (00007FF7053F2D1D) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F2D1D(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v6; // rax
  _BYTE v8[104]; // [rsp+30h] [rbp-50h] BYREF
  _QWORD v9[7]; // [rsp+98h] [rbp+18h] BYREF

  sub_7FF7053FB220(v8, a1, a2, a3, a4);
  do
    sub_7FF7053F2FFD(v9, v8);
  while ( !v9[0] );
  if ( LODWORD(v9[0]) == 1 )
    v6 = v9[1];
  else
    v6 = a2;
  return v6 + a1;
}

//----- (00007FF7053F2D95) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F2D95(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // r12
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // r13
  size_t v6; // rdi
  unsigned __int8 v7; // r14
  unsigned __int64 v8; // r8
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // r12
  __int64 v13; // r12
  unsigned __int64 v14; // [rsp+28h] [rbp-8h]

  if ( *(a1 + 65) )
    return 0LL;
  v3 = *(a1 + 16);
  v4 = *(a1 + 40);
  v14 = *(a1 + 24);
  v5 = *(a1 + 32);
  if ( v4 > v14 || v4 < v5 )
  {
LABEL_20:
    *(a1 + 65) = 1;
    v12 = *a1 + v3;
    result = 0LL;
    if ( *(a1 + 8) != *a1 )
      result = v12;
    if ( *(a1 + 64) )
      return v12;
  }
  else
  {
    v6 = *(a1 + 56);
    v7 = *(a1 + v6 + 47);
    while ( 1 )
    {
      v8 = v4 - v5;
      v9 = v3 + v5;
      if ( v4 - v5 > 0xF )
      {
        if ( (sub_7FF7053FA720(v7, v9, v8) & 1) == 0 )
        {
LABEL_19:
          *(a1 + 32) = v4;
          goto LABEL_20;
        }
        v10 = v11;
      }
      else
      {
        if ( v4 == v5 )
          goto LABEL_19;
        v10 = 0LL;
        while ( *(v9 + v10) != v7 )
        {
          if ( v8 == ++v10 )
            goto LABEL_19;
        }
      }
      v5 += v10 + 1;
      *(a1 + 32) = v5;
      if ( v5 >= v6 && v5 <= v14 )
      {
        if ( v6 >= 5u )
          sub_7FF7053FE4E0(v6, 4LL, &off_7FF705403600);
        if ( !memcmp((v3 + v5 - v6), (a1 + 48), v6) )
          break;
      }
      if ( v4 < v5 )
        goto LABEL_20;
    }
    v13 = *a1 + v3;
    *a1 = v5;
    return v13;
  }
  return result;
}
// 7FF7053F2E26: variable 'v11' is possibly undefined
// 7FF705403600: using guessed type char *off_7FF705403600;

//----- (00007FF7053F2EBF) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F2EBF(__int64 a1, unsigned int a2)
{
  __int64 result; // rax
  unsigned int v3; // ecx
  __int64 v4; // rcx
  __int16 v5; // [rsp+4h] [rbp-Ch]
  __int64 v6; // [rsp+6h] [rbp-Ah]
  __int16 v7; // [rsp+Eh] [rbp-2h]

  result = a1;
  _BitScanReverse(&v3, a2 | 1);
  v4 = (v3 ^ 0x1C) >> 2;
  BYTE2(v6) = 0;
  LOWORD(v6) = 0;
  BYTE3(v6) = a0123456789abcd_0[a2 >> 20];
  BYTE4(v6) = a0123456789abcd_0[HIWORD(a2) & 0xF];
  BYTE5(v6) = a0123456789abcd_0[a2 >> 12];
  BYTE6(v6) = a0123456789abcd_0[(a2 >> 8) & 0xF];
  HIBYTE(v6) = a0123456789abcd_0[a2 >> 4];
  LOBYTE(v7) = a0123456789abcd_0[a2 & 0xF];
  HIBYTE(v7) = 125;
  *(&v5 + v4) = 30044;
  *(&v6 + v4) = 123;
  *(result + 8) = v7;
  *result = v6;
  *(result + 10) = v4 - 2;
  *(result + 11) = 10;
  return result;
}

//----- (00007FF7053F2F85) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F2F85(__int64 *a1, _QWORD *a2)
{
  return sub_7FF7053F2BF4(*a1, a1[1], a2);
}

//----- (00007FF7053F2F97) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F2F97(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9DC0(a2);
}

//----- (00007FF7053F2FAC) ----------------------------------------------------
char __fastcall sub_7FF7053F2FAC(__int64 a1, char *a2)
{
  __int64 v3; // [rsp+38h] [rbp-8h] BYREF

  v3 = a1;
  return sub_7FF7053F9DE0(a2, "ParseIntErrorkind", 13LL, "kind", 4uLL, &v3, "");
}

//----- (00007FF7053F2FFD) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053F2FFD(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rax
  __int64 v4; // rsi
  unsigned __int64 v5; // r11
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // rdi
  __int64 v9; // r14
  __int64 v10; // rbx
  __int64 v11; // r10
  unsigned __int64 v12; // r12
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // r13
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // r10
  bool v17; // zf
  unsigned __int64 v18; // r9
  unsigned __int64 v19; // rdi
  unsigned __int64 v20; // r9
  __int64 v21; // r10
  char v22; // r10
  _BYTE *v23; // rax
  unsigned __int64 v24; // r9
  char v25; // bl
  unsigned int v26; // r9d
  int v27; // r11d
  int v28; // esi
  int v29; // r9d
  unsigned __int64 i; // r9
  __int64 v31; // rax
  unsigned __int64 v33; // r9
  char **v34; // r8
  __int64 v35; // rcx
  unsigned __int64 v36; // [rsp+30h] [rbp-30h]
  unsigned __int64 v37; // [rsp+40h] [rbp-20h]
  unsigned __int64 v38; // [rsp+48h] [rbp-18h]
  unsigned __int64 v39; // [rsp+50h] [rbp-10h]
  __int64 v40; // [rsp+58h] [rbp-8h]
  unsigned __int64 v41; // [rsp+60h] [rbp+0h]

  if ( *a2 == 1 )
  {
    v2 = *(a2 + 40);
    v3 = *(a2 + 80);
    if ( v2 != v3 )
    {
      v4 = *(a2 + 72);
      v5 = *(a2 + 96);
      v6 = v2 + v5 - 1;
      v7 = *(a2 + 80);
      if ( v6 < v3 )
      {
        v8 = *(a2 + 56);
        v9 = *(a2 + 88);
        v36 = v5 - 1;
        v10 = *(a2 + 32);
        v11 = *(a2 + 24);
        v38 = v5 - v11;
        v37 = v2 + v11;
        v41 = v2 + v5;
        v39 = *(a2 + 8);
        v12 = v8;
        v7 = *(a2 + 40);
        v40 = v10;
        while ( v2 == v7 )
        {
          if ( _bittest64(&v10, *(v4 + v6)) )
          {
            v13 = v39;
            if ( v12 > v39 )
              v13 = v12;
            v14 = v8;
            if ( v8 == -1LL )
              v13 = v39;
            v15 = v13;
            do
            {
              if ( v15 >= v5 )
              {
                v19 = v12;
                if ( v14 == -1LL )
                  v19 = 0LL;
                v20 = v39;
                do
                {
                  if ( v19 >= v20 )
                  {
                    *(a2 + 40) = v41;
                    if ( v14 != -1LL )
                      *(a2 + 56) = 0LL;
                    *a1 = 0LL;
                    a1[1] = v2;
                    a1[2] = v41;
                    return a1;
                  }
                  if ( --v20 >= v5 )
                    sub_7FF7053FE234(v20, v5, &off_7FF705403448);
                  v21 = v20 + v2;
                  if ( v20 + v2 >= v3 )
                  {
                    v34 = &off_7FF705403460;
                    v35 = v21;
                    goto LABEL_74;
                  }
                }
                while ( *(v9 + v20) == *(v4 + v21) );
                v7 = v37;
                *(a2 + 40) = v37;
                v18 = v38;
                v8 = v14;
                v10 = v40;
                if ( v14 == -1LL )
                  goto LABEL_28;
                goto LABEL_27;
              }
              if ( v2 + v15 >= v3 )
              {
                v33 = v2 + v13;
                if ( v3 > v33 )
                  v33 = v3;
                v34 = &off_7FF705403478;
                v35 = v33;
LABEL_74:
                sub_7FF7053FE234(v35, v3, v34);
              }
              v16 = v15 + 1;
              v17 = *(v9 + v15) == *(v4 + v2 + v15);
              ++v15;
            }
            while ( v17 );
            v7 = v2 - v39 + v16;
            *(a2 + 40) = v7;
            v8 = v14;
            if ( v14 != -1LL )
            {
              v18 = 0LL;
              v10 = v40;
              goto LABEL_27;
            }
            v10 = v40;
          }
          else
          {
            v7 = v2 + v5;
            *(a2 + 40) = v41;
            if ( v8 != -1LL )
            {
              v18 = 0LL;
              v7 = v2 + v5;
LABEL_27:
              *(a2 + 56) = v18;
              v12 = v18;
            }
          }
LABEL_28:
          v6 = v7 + v36;
          if ( v7 + v36 >= v3 )
          {
            v7 = v3;
            break;
          }
        }
      }
      if ( v7 )
      {
        for ( i = v7; i; ++i )
        {
          if ( i >= v3 )
          {
            if ( i == v3 )
              goto LABEL_57;
          }
          else if ( *(v4 + i) > -65 )
          {
            v3 = i;
            goto LABEL_57;
          }
        }
      }
      v3 = 0LL;
LABEL_57:
      if ( v7 <= v3 )
        v7 = v3;
      *(a2 + 40) = v7;
      goto LABEL_67;
    }
    goto LABEL_32;
  }
  if ( !*(a2 + 26) )
  {
    v22 = *(a2 + 24);
    *(a2 + 24) = v22 ^ 1;
    v2 = *(a2 + 8);
    v23 = *(a2 + 72);
    v24 = *(a2 + 80);
    if ( v2 )
    {
      if ( v2 >= v24 )
      {
        if ( v2 != v24 )
LABEL_36:
          sub_7FF7053FE500(v23, v24, v2, v24, &off_7FF7054035E8);
      }
      else if ( v23[v2] <= -65 )
      {
        goto LABEL_36;
      }
    }
    if ( v2 == v24 )
    {
      if ( !v22 )
      {
        *(a2 + 26) = 1;
        goto LABEL_32;
      }
    }
    else
    {
      v25 = v23[v2];
      v26 = v25;
      if ( v25 < 0 )
      {
        v27 = v25 & 0x1F;
        v28 = v23[v2 + 1] & 0x3F;
        if ( v25 <= 0xDFu )
        {
          v26 = v28 | (v27 << 6);
        }
        else
        {
          v29 = (v28 << 6) | v23[v2 + 2] & 0x3F;
          if ( v25 < 0xF0u )
            v26 = (v27 << 12) | v29;
          else
            v26 = ((v25 & 7) << 18) | (v29 << 6) | v23[v2 + 3] & 0x3F;
        }
      }
      if ( !v22 )
      {
        v31 = 1LL;
        if ( v26 >= 0x80 )
        {
          v31 = 2LL;
          if ( v26 >= 0x800 )
            v31 = 4LL - (v26 < 0x10000);
        }
        v3 = v2 + v31;
        *(a2 + 8) = v3;
LABEL_67:
        a1[1] = v2;
        a1[2] = v3;
        *a1 = 1LL;
        return a1;
      }
    }
    a1[1] = v2;
    a1[2] = v2;
    *a1 = 0LL;
    return a1;
  }
LABEL_32:
  *a1 = 2LL;
  return a1;
}
// 7FF705403448: using guessed type char *off_7FF705403448;
// 7FF705403460: using guessed type char *off_7FF705403460;
// 7FF705403478: using guessed type char *off_7FF705403478;
// 7FF7054035E8: using guessed type char *off_7FF7054035E8;

//----- (00007FF7053F337F) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053F337F(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v4; // r8
  __m128i v5; // xmm0
  __int64 v6; // rax
  __m128i si128; // xmm2
  __m128i v8; // xmm3
  __m128i v9; // xmm1
  __m128i v10; // xmm4
  __m128i v11; // xmm5
  __m128i v12; // xmm1

  v2 = a2 - a1;
  if ( v2 >= 0x20 )
    return sub_7FF7053FAB30(a1, v2);
  if ( !v2 )
    return 0LL;
  if ( v2 >= 4 )
  {
    v4 = v2 & 0x1C;
    v5 = 0LL;
    v6 = 0LL;
    si128 = _mm_load_si128(&xmmword_7FF7054041E0);
    v8 = _mm_load_si128(&xmmword_7FF7054041F0);
    v9 = 0LL;
    do
    {
      v10 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(a1 + v6)), si128);
      v5 = _mm_add_epi64(
             v5,
             _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v10, v10), 212), 212), v8));
      v11 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(a1 + v6 + 2)), si128);
      v9 = _mm_add_epi64(
             v9,
             _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v11, v11), 212), 212), v8));
      v6 += 4LL;
    }
    while ( v4 != v6 );
    v12 = _mm_add_epi64(v9, v5);
    result = _mm_add_epi64(_mm_shuffle_epi32(v12, 238), v12).m128i_u64[0];
    goto LABEL_11;
  }
  result = 0LL;
  v4 = 0LL;
  do
  {
    result += *(a1 + v4++) >= 0xC0;
LABEL_11:
    ;
  }
  while ( v2 != v4 );
  return result;
}
// 7FF7053FB17B: mask 0xFFFFFFFFFFFFFFFC is shortened because rdx.8 <= 0x1F
// 7FF7054041E0: using guessed type __int128 xmmword_7FF7054041E0;
// 7FF7054041F0: using guessed type __int128 xmmword_7FF7054041F0;

//----- (00007FF7053F3391) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F3391(__int64 a1, __int64 *a2)
{
  char *v2; // r15
  char *v3; // rsi
  unsigned __int64 v4; // r12
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // r8
  char *v9; // rbx
  char v10; // r9
  unsigned __int64 i; // r14
  int v12; // r10d
  int v13; // edx
  int v14; // r10d
  int v15; // r11d
  unsigned __int8 v16; // al
  int v17; // edx
  char v18; // al
  __int64 v19; // r10
  char *v20; // r11
  __int64 v21; // rsi
  unsigned __int64 v22; // r13
  bool v23; // di
  unsigned int v24; // edx
  __int64 v25; // r13
  bool v26; // cf
  __int64 v27; // rax
  unsigned int v28; // edx
  unsigned __int64 v29; // rdi
  unsigned __int64 v30; // r12
  char *v31; // rax
  unsigned int v32; // edx
  int v33; // r8d
  int v34; // r11d
  int v35; // r9d
  unsigned int v36; // r9d
  char *v37; // rbx
  unsigned __int64 v38; // r14
  int v39; // eax
  unsigned __int64 v40; // r9
  unsigned __int8 *v41; // rcx
  unsigned __int64 v42; // rdi
  int v43; // edx
  unsigned __int8 *v44; // r8
  int v45; // r9d
  int v46; // r10d
  int v47; // edx
  unsigned __int64 v48; // r15
  char *v49; // rdi
  unsigned __int64 v50; // r13
  unsigned __int64 v51; // r8
  __int64 v52; // rdx
  unsigned __int64 v53; // r9
  unsigned __int64 v54; // rax
  char v55; // dl
  int v56; // eax
  int v57; // ecx
  int v58; // r8d
  int v59; // eax
  unsigned __int64 v60; // r14
  unsigned __int8 *v61; // rbx
  char v62; // al
  unsigned __int64 v63; // r15
  char v64; // al
  unsigned __int8 *v65; // rdi
  unsigned __int8 *v66; // r8
  unsigned int v67; // ecx
  int v68; // r10d
  int v69; // r11d
  int v70; // edx
  int v71; // edx
  char v72; // r8
  bool v73; // r10
  _BYTE *v74; // rdi
  int v75; // eax
  __int64 v76; // r9
  unsigned int v77; // edx
  unsigned int v78; // eax
  unsigned int v79; // ecx
  __int64 v80; // r9
  unsigned int v81; // edx
  unsigned int v82; // eax
  bool v83; // zf
  char *v85; // rbx
  char **v86; // rax
  char **v87; // rax
  unsigned __int64 v88; // r8
  char **v89; // [rsp+20h] [rbp-40h]
  unsigned __int64 v90; // [rsp+30h] [rbp-30h]
  _BYTE *v91; // [rsp+38h] [rbp-28h]
  unsigned __int64 v92; // [rsp+40h] [rbp-20h]
  unsigned int v93; // [rsp+48h] [rbp-18h] BYREF
  int v94; // [rsp+4Ch] [rbp-14h]
  unsigned __int64 v95; // [rsp+50h] [rbp-10h]
  char v96; // [rsp+5Fh] [rbp-1h] BYREF
  __int64 *v97; // [rsp+60h] [rbp+0h]

  v97 = a2;
  v3 = *a1;
  v4 = *(a1 + 8);
  v5 = *(a1 + 16);
  v6 = 0LL;
  v92 = v5;
  while ( 1 )
  {
    v7 = v6;
    v8 = v6 + 1;
    LOBYTE(v2) = v6 < v5;
    if ( v6 >= v5 )
      return v2;
    if ( !v4 )
LABEL_199:
      sub_7FF7053FE090(&off_7FF7054036A8);
    v9 = v3;
    v10 = *v3;
    for ( i = 0LL; ; ++i )
    {
      if ( v10 < 0 )
      {
        v13 = v10 & 0x1F;
        v14 = v3[i + 1] & 0x3F;
        if ( v10 <= 0xDFu )
        {
          v12 = v14 | (v13 << 6);
        }
        else
        {
          v15 = (v14 << 6) | v3[i + 2] & 0x3F;
          if ( v10 < 0xF0u )
          {
            v12 = (v13 << 12) | v15;
          }
          else
          {
            v12 = ((v10 & 7) << 18) | (v15 << 6) | v3[i + 3] & 0x3F;
            if ( v12 == 1114112 )
              goto LABEL_199;
          }
        }
      }
      else
      {
        v12 = v10;
      }
      if ( (v12 - 48) >= 0xA )
        break;
      if ( v4 - 1 == i )
        goto LABEL_199;
      v10 = v3[i + 1];
      if ( v10 <= -65 )
        sub_7FF7053FE500(&v3[i], v4 - i, 1uLL, v4 - i, &off_7FF7054036C0);
    }
    if ( !i )
    {
      v18 = 0;
      goto LABEL_201;
    }
    if ( v3[i] <= -65 )
      sub_7FF7053FE500(v3, v4, 0LL, i, &off_7FF7054036D8);
    v16 = *v3;
    v90 = v6 + 1;
    if ( i == 1 )
    {
      v17 = v16;
      v18 = 1;
      if ( v17 != 43 )
      {
        v19 = 1LL;
        v20 = v3;
        if ( v17 != 45 )
        {
LABEL_32:
          v27 = 0LL;
          v22 = 0LL;
          while ( 1 )
          {
            v28 = v20[v27] - 48;
            if ( v28 > 9 )
              break;
            v22 = v28 + 10 * v22;
            if ( v19 == ++v27 )
              goto LABEL_35;
          }
LABEL_200:
          v18 = 1;
        }
      }
LABEL_201:
      v96 = v18;
      sub_7FF7053FE440(aCalledResultUn_0, 43LL, &v96, &unk_7FF705403530, &off_7FF7054036F0);
    }
    if ( v16 == 43 )
    {
      v20 = v3 + 1;
      v19 = i - 1;
      if ( i < 0x12 )
        goto LABEL_32;
    }
    else
    {
      v20 = v3;
      v19 = i;
      if ( i < 0x11 )
        goto LABEL_32;
    }
    v21 = 0LL;
    v22 = 0LL;
    while ( v19 != v21 )
    {
      v23 = (0xA * v22) >> 64 != 0;
      v24 = v20[v21] - 48;
      if ( v24 > 9 )
        goto LABEL_200;
      v25 = 10 * v22;
      v18 = 2;
      if ( !v23 )
      {
        ++v21;
        v26 = __CFADD__(v24, v25);
        v22 = v24 + v25;
        if ( !v26 )
          continue;
      }
      goto LABEL_201;
    }
LABEL_35:
    v29 = v4 - v22;
    if ( v22 )
    {
      v30 = v4 - i;
      if ( v22 >= v30 )
      {
        if ( v29 != i )
LABEL_205:
          sub_7FF7053FE500(&v9[i], v30, v22, v30, &off_7FF705403708);
      }
      else if ( v9[v22 + i] <= -65 )
      {
        goto LABEL_205;
      }
    }
    v3 = &v9[v22 + i];
    if ( v8 == v92 && (v97[2] & 0x800000) != 0 && v10 == 104 && v22 )
      break;
LABEL_59:
    if ( v7 && sub_7FF7053F9DC0(v97) )
      return v2;
    v94 = v2;
    v2 = &v9[i];
    if ( v22 >= 2 && *v2 == 9311 )
    {
      if ( v9[i + 1] < -64 )
      {
        v85 = &v9[i];
        v86 = &off_7FF705403740;
LABEL_211:
        sub_7FF7053FE500(v85, v22, 1uLL, v22, v86);
      }
      v2 = &v9[i + 1];
      --v22;
    }
    v4 = v29 - i;
    while ( 1 )
    {
      while ( 1 )
      {
        v37 = v2;
        v38 = v22;
        if ( !v22 )
        {
LABEL_72:
          v40 = 0LL;
          v41 = v2;
          do
          {
            if ( v41 == &v2[v22] )
              goto LABEL_193;
            v42 = v40;
            v43 = *v41;
            if ( (v43 & 0x80u) != 0 )
            {
              v45 = v43 & 0x1F;
              v46 = v41[1] & 0x3F;
              if ( v43 <= 0xDFu )
              {
                v44 = v41 + 2;
                v43 = v46 | (v45 << 6);
              }
              else
              {
                v47 = (v46 << 6) | v41[2] & 0x3F;
                if ( *v41 < 0xF0u )
                {
                  v44 = v41 + 3;
                  v43 = (v45 << 12) | v47;
                }
                else
                {
                  v44 = v41 + 4;
                  v43 = ((v45 & 7) << 18) | (v47 << 6) | v41[3] & 0x3F;
                }
              }
            }
            else
            {
              v44 = v41 + 1;
            }
            if ( v43 == 36 )
              break;
            v40 = &v44[v42 - v41];
            v41 = v44;
          }
          while ( v43 != 46 );
          if ( v42 )
          {
            if ( v42 >= v22 )
            {
              if ( v42 != v22 || !v2 )
LABEL_197:
                sub_7FF7053FE500(v2, v22, 0LL, v42, &off_7FF705403758);
            }
            else if ( v2[v42] <= -65 )
            {
              goto LABEL_197;
            }
            if ( sub_7FF7053F9DC0(v97) )
            {
LABEL_198:
              LOBYTE(v2) = 1;
              return v2;
            }
            if ( v42 >= v22 )
            {
              v54 = v22;
              if ( v42 != v22 )
LABEL_206:
                sub_7FF7053FE500(v2, v22, v42, v22, &off_7FF705403770);
            }
            else
            {
              if ( v2[v42] < -64 )
                goto LABEL_206;
              v54 = v42;
            }
          }
          else
          {
            if ( sub_7FF7053F9DC0(v97) )
              goto LABEL_198;
            v54 = 0LL;
          }
          v60 = v22 - v54;
          v61 = &v2[v54];
          goto LABEL_126;
        }
        v39 = *v2;
        if ( v39 == 36 )
          break;
        if ( v39 != 46 )
          goto LABEL_72;
        if ( v22 == 1 )
        {
          if ( sub_7FF7053F9DC0(v97) )
            goto LABEL_198;
LABEL_125:
          v60 = v22 - 1;
          v61 = (v2 + 1);
          goto LABEL_126;
        }
        if ( v2[1] <= -65 )
        {
          v87 = &off_7FF7054037F8;
          goto LABEL_213;
        }
        v55 = v2[1];
        v56 = v55;
        if ( v55 < 0 )
        {
          v57 = v55 & 0x1F;
          v58 = v2[2] & 0x3F;
          if ( v55 <= 0xDFu )
          {
            v56 = v58 | (v57 << 6);
          }
          else
          {
            v59 = (v58 << 6) | v2[3] & 0x3F;
            if ( v55 < 0xF0u )
              v56 = (v57 << 12) | v59;
            else
              v56 = ((v55 & 7) << 18) | (v59 << 6) | v2[4] & 0x3F;
          }
        }
        if ( v56 != 46 )
        {
          if ( sub_7FF7053F9DC0(v97) )
            goto LABEL_198;
          if ( v2[1] < -64 )
          {
            v87 = &off_7FF705403830;
LABEL_213:
            v89 = v87;
            v88 = 1LL;
LABEL_214:
            sub_7FF7053FE500(v2, v22, v88, v22, v89);
          }
          goto LABEL_125;
        }
        if ( sub_7FF7053F9DC0(v97) )
          goto LABEL_198;
        if ( v22 >= 3 && v2[2] < -64 )
        {
          v89 = &off_7FF705403810;
          v88 = 2LL;
          goto LABEL_214;
        }
        v60 = v22 - 2;
        v61 = (v2 + 2);
LABEL_126:
        v22 = v60;
        v2 = v61;
      }
      if ( v22 != 1 && v2[1] <= -65 )
      {
        v87 = &off_7FF705403788;
        goto LABEL_213;
      }
      v48 = v22 - 1;
      v49 = v37 + 1;
      v50 = 0LL;
      while ( 1 )
      {
        v51 = v48 - v50;
        if ( v48 - v50 > 0xF )
        {
          if ( (sub_7FF7053FA720(0x24u, &v49[v50], v51) & 1) == 0 )
            goto LABEL_193;
        }
        else
        {
          if ( v48 == v50 )
            goto LABEL_193;
          v52 = 0LL;
          while ( v49[v50 + v52] != 36 )
          {
            if ( v51 == ++v52 )
              goto LABEL_193;
          }
        }
        v53 = v52 + v50;
        if ( v52 + v50 < v48 && v49[v53] == 36 )
          break;
        v50 += v52 + 1;
        if ( v48 < v50 )
          goto LABEL_193;
      }
      v62 = *v49;
      if ( *v49 < -64 )
        sub_7FF7053FE500(v37, v38, 1uLL, v53 + 1, &off_7FF7054037A0);
      v63 = v53 + 2;
      v22 = v38 - (v53 + 2);
      if ( v38 <= v53 + 2 )
      {
        if ( v38 != v53 + 2 )
LABEL_217:
          sub_7FF7053FE500(v37, v38, v53 + 2, v38, &off_7FF7054037B8);
      }
      else if ( v37[v63] < -64 )
      {
        goto LABEL_217;
      }
      v2 = &v37[v63];
      if ( v53 == 1 )
        break;
      if ( v53 != 2 )
      {
        if ( !v53 )
          goto LABEL_193;
LABEL_135:
        if ( v62 != 117 )
          goto LABEL_193;
        if ( v37[2] < -64 )
          sub_7FF7053FE500(v37 + 1, v53, 1uLL, v53, &off_7FF7054037D8);
        goto LABEL_149;
      }
      if ( *v49 != 20563
        && *v49 != 20546
        && *v49 != 18002
        && *v49 != 21580
        && *v49 != 21575
        && *v49 != 20556
        && *v49 != 20562 )
      {
        goto LABEL_135;
      }
LABEL_147:
      v64 = sub_7FF7053F9DC0(v97);
LABEL_191:
      if ( v64 )
        goto LABEL_198;
    }
    if ( *v49 == 67 )
      goto LABEL_147;
    if ( v62 != 117 )
      goto LABEL_193;
LABEL_149:
    v65 = &v49[v53];
    v95 = v53 - 1;
    v66 = (v37 + 2);
    v91 = v37 + 2;
    while ( 1 )
    {
      v67 = 0;
      if ( v66 == v65 )
        break;
      v68 = *v66;
      if ( (v68 & 0x80u) != 0 )
      {
        v69 = v68 & 0x1F;
        v70 = v66[1] & 0x3F;
        if ( v68 <= 0xDFu )
        {
          v66 += 2;
          v68 = v70 | (v69 << 6);
        }
        else
        {
          v71 = (v70 << 6) | v66[2] & 0x3F;
          if ( *v66 < 0xF0u )
          {
            v66 += 3;
            v68 = (v69 << 12) | v71;
          }
          else
          {
            v68 = ((v68 & 7) << 18) | (v71 << 6) | v66[3] & 0x3F;
            if ( v68 == 1114112 )
              break;
            v66 += 4;
          }
        }
      }
      else
      {
        ++v66;
      }
      if ( (v68 - 58) < 0xFFFFFFF6 && (v68 - 103) < 0xFFFFFFFA )
      {
        v72 = 1;
        goto LABEL_162;
      }
    }
    v72 = 0;
LABEL_162:
    v73 = 1;
    v74 = v37 + 2;
    if ( v53 != 1 )
    {
      if ( v53 == 2 )
      {
        v75 = *v91;
        if ( v75 == 43 )
          goto LABEL_184;
        v95 = 1LL;
        if ( v75 == 45 )
          goto LABEL_184;
LABEL_177:
        v80 = 0LL;
        v67 = 0;
        while ( 1 )
        {
          v81 = v74[v80];
          v82 = v81 - 48;
          if ( v81 >= 0x3A )
            v82 = ((v81 - 65) & 0xFFFFFFDF) + 10;
          v73 = v82 >= 0x10;
          if ( v82 >= 0x10 )
            break;
          v67 = v82 | (16 * v67);
          if ( v95 == ++v80 )
            goto LABEL_184;
        }
      }
      else
      {
        if ( *v91 == 43 )
        {
          v74 = v37 + 3;
          v26 = v95 < 0xA;
          v95 = v53 - 2;
          if ( v26 )
            goto LABEL_177;
        }
        else if ( v95 < 9 )
        {
          goto LABEL_177;
        }
        v76 = 0LL;
        v77 = 0;
        while ( v77 <= 0xFFFFFFF )
        {
          v78 = v74[v76];
          v79 = v78 - 48;
          if ( v78 >= 0x3A )
            v79 = ((v78 - 65) & 0xFFFFFFDF) + 10;
          if ( v79 >= 0x10 )
            break;
          v67 = (16 * v77) | v79;
          ++v76;
          v77 = v67;
          if ( v95 == v76 )
          {
            v73 = 0;
            goto LABEL_184;
          }
        }
      }
      v67 = 0;
    }
LABEL_184:
    if ( (v67 ^ 0xD800) - 1114112 < 0xFFEF0800 )
      v67 = 1114112;
    if ( v73 )
      v67 = 1114112;
    if ( !((v67 == 1114112) | v72) )
    {
      v93 = v67;
      if ( !sub_7FF7053FC5E0(v67) )
      {
        v64 = sub_7FF7053FA580(&v93, v97);
        goto LABEL_191;
      }
    }
LABEL_193:
    v83 = sub_7FF7053F9DC0(v97) == 0;
    LODWORD(v2) = v94;
    v5 = v92;
    v6 = v90;
    if ( !v83 )
      return v2;
  }
  if ( v22 != 1 && v9[i + 1] < -64 )
  {
    v85 = &v9[i];
    v86 = &off_7FF705403690;
    goto LABEL_211;
  }
  v31 = &v9[i + 1];
  while ( v3 != v31 )
  {
    v32 = *v31;
    if ( (v32 & 0x80u) != 0 )
    {
      v33 = v32 & 0x1F;
      v34 = v31[1] & 0x3F;
      if ( v32 <= 0xDFu )
      {
        v31 += 2;
        v32 = v34 | (v33 << 6);
      }
      else
      {
        v35 = (v34 << 6) | v31[2] & 0x3F;
        if ( *v31 < 0xF0u )
        {
          v31 += 3;
          v32 = (v33 << 12) | v35;
        }
        else
        {
          v32 = ((v32 & 7) << 18) | (v35 << 6) | v31[3] & 0x3F;
          if ( v32 == 1114112 )
            break;
          v31 += 4;
        }
      }
    }
    else
    {
      ++v31;
    }
    v36 = v32 - 48;
    if ( v32 >= 0x3A )
      v36 = ((v32 - 65) & 0xFFFFFFDE) + 10;
    if ( v36 > 0xF )
      goto LABEL_59;
  }
  LODWORD(v2) = 0;
  return v2;
}
// 7FF7053F36BA: variable 'v2' is possibly undefined
// 7FF7053F3859: variable 'v52' is possibly undefined
// 7FF705403690: using guessed type char *off_7FF705403690;
// 7FF7054036A8: using guessed type char *off_7FF7054036A8;
// 7FF7054036C0: using guessed type char *off_7FF7054036C0;
// 7FF7054036D8: using guessed type char *off_7FF7054036D8;
// 7FF7054036F0: using guessed type char *off_7FF7054036F0;
// 7FF705403708: using guessed type char *off_7FF705403708;
// 7FF705403740: using guessed type char *off_7FF705403740;
// 7FF705403758: using guessed type char *off_7FF705403758;
// 7FF705403770: using guessed type char *off_7FF705403770;
// 7FF705403788: using guessed type char *off_7FF705403788;
// 7FF7054037A0: using guessed type char *off_7FF7054037A0;
// 7FF7054037B8: using guessed type char *off_7FF7054037B8;
// 7FF7054037D8: using guessed type char *off_7FF7054037D8;
// 7FF7054037F8: using guessed type char *off_7FF7054037F8;
// 7FF705403810: using guessed type char *off_7FF705403810;
// 7FF705403830: using guessed type char *off_7FF705403830;

//----- (00007FF7053F3E7E) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F3E7E(unsigned __int8 **a1, __int64 *a2)
{
  unsigned __int8 *v2; // r13
  unsigned __int8 v5; // r15
  unsigned __int8 *v6; // rcx
  unsigned __int8 *v7; // rax
  unsigned __int8 *v8; // rax
  unsigned __int64 v9; // r11
  int v10; // edx
  int v11; // esi
  int v12; // r9d
  unsigned __int8 *v14; // rbx
  unsigned __int64 v15; // rsi
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // r9
  char v18; // r10
  char v19; // dl
  unsigned __int64 v20; // r14
  unsigned __int64 v21; // r8
  unsigned __int64 v22; // rdi
  unsigned __int64 v23; // rdi
  unsigned __int8 v24; // al
  unsigned __int8 v25; // dl
  unsigned __int64 v26; // rax
  bool v27; // cf
  bool v28; // of
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // rcx
  unsigned int *v34; // r14
  unsigned __int64 v35; // r8
  unsigned __int64 v36; // r9
  __int64 v37; // r11
  unsigned __int64 v38; // r8
  bool v39; // cc
  __int64 *v40; // rsi
  __int64 v41; // rbx
  int v42; // eax
  _DWORD v44[128]; // [rsp+20h] [rbp-60h] BYREF
  unsigned __int8 *v45; // [rsp+220h] [rbp+1A0h]
  unsigned __int8 *v46; // [rsp+228h] [rbp+1A8h]
  unsigned __int8 *v47; // [rsp+230h] [rbp+1B0h]
  __int64 *v48; // [rsp+238h] [rbp+1B8h]
  unsigned __int8 *v49; // [rsp+240h] [rbp+1C0h]
  unsigned __int64 v50; // [rsp+248h] [rbp+1C8h]
  __int64 v51; // [rsp+250h] [rbp+1D0h]
  unsigned int v52; // [rsp+25Ch] [rbp+1DCh] BYREF
  unsigned __int64 v53; // [rsp+260h] [rbp+1E0h]

  memset(v44, 0, sizeof(v44));
  v47 = a1[3];
  if ( !v47 )
    return sub_7FF7053F9DC0(a2);
  v48 = a2;
  v49 = a1[2];
  v5 = *v49;
  v6 = *a1;
  v7 = a1[1];
  v46 = *a1;
  v45 = v7;
  if ( v7 )
  {
    v8 = &v7[v6];
    v9 = 0LL;
    while ( 1 )
    {
      v10 = *v6;
      if ( (v10 & 0x80u) != 0 )
      {
        v11 = v6[1] & 0x3F;
        if ( v10 <= 0xDFu )
        {
          v6 += 2;
          v10 = v11 | ((v10 & 0x1F) << 6);
        }
        else
        {
          v12 = ((v6[1] & 0x3F) << 6) | v6[2] & 0x3F;
          if ( *v6 < 0xF0u )
          {
            v6 += 3;
            v10 = ((v10 & 0x1F) << 12) | v12;
          }
          else
          {
            v10 = ((v10 & 7) << 18) | (((v11 << 6) | v6[2] & 0x3F) << 6) | v6[3] & 0x3F;
            if ( v10 == 1114112 )
              goto LABEL_17;
            v6 += 4;
          }
        }
      }
      else
      {
        ++v6;
      }
      if ( v9 == 128 )
        break;
      v44[v9++] = v10;
      if ( v6 == v8 )
        goto LABEL_17;
    }
  }
  else
  {
    v9 = 0LL;
LABEL_17:
    v14 = v49;
    v2 = &v47[v49];
    v51 = 4 * v9 + 4;
    v50 = 700LL;
    v15 = 72LL;
    v53 = 128LL;
    v16 = 0LL;
LABEL_18:
    ++v14;
    v17 = 1LL;
    v18 = 1;
    v19 = 0;
    v20 = 36LL;
    v21 = 0LL;
    do
    {
      v22 = 0LL;
      if ( v20 >= v15 )
        v22 = v20 - v15;
      v23 = (v22 == 0) + v22;
      if ( v23 >= 0x1A )
        v23 = 26LL;
      if ( (v19 & 1) != 0 )
      {
        if ( v14 == v2 )
          break;
        v24 = *v14++;
      }
      else
      {
        v24 = v5;
        if ( (v18 & 1) == 0 )
          break;
      }
      v25 = v24 - 97;
      if ( (v24 - 97) >= 0x1Au )
      {
        if ( (v24 - 48) > 9u )
          break;
        v25 = v24 - 22;
      }
      v26 = v17 * v25;
      if ( !is_mul_ok(v17, v25) )
        break;
      v27 = __CFADD__(v26, v21);
      v21 += v26;
      if ( v27 )
        break;
      if ( v23 > v25 )
      {
        v27 = __CFADD__(v21, v16);
        v29 = v21 + v16;
        if ( v27 )
          break;
        v30 = v9 + 1;
        v31 = v29 / (v9 + 1);
        v32 = v29 % (v9 + 1);
        v27 = __CFADD__(v31, v53);
        v53 += v31;
        if ( v27 || HIDWORD(v53) || (v53 ^ 0xD800) - 1114112 < 0xFFEF0800 || v53 == 1114112 || v9 > 0x7F )
          break;
        v33 = v29 % (v9 + 1);
        if ( v9 <= v32 )
        {
          if ( v32 >= 0x80 )
            sub_7FF7053FE234(v33, 128LL, &off_7FF705403930);
        }
        else
        {
          do
          {
            v44[v9] = v44[v9 - 1];
            --v9;
          }
          while ( v9 > v32 );
        }
        v44[v32] = v53;
        v34 = v44;
        if ( v14 != v2 )
        {
          v35 = v21 / v50;
          v36 = v35 + v35 / v30;
          v37 = 0LL;
          if ( v36 < 0x1C8 )
          {
            v38 = v35 + v35 / v30;
          }
          else
          {
            do
            {
              v38 = v36 / 0x23;
              v37 += 36LL;
              v39 = v36 <= 0x3E57;
              v36 /= 0x23uLL;
            }
            while ( !v39 );
          }
          v16 = v33 + 1;
          v5 = *v14;
          v15 = v37 + ((36 * v38) / (v38 + 38));
          v51 += 4LL;
          v50 = 2LL;
          v9 = v30;
          goto LABEL_18;
        }
        v40 = v48;
        v41 = v51;
        do
        {
          v52 = *v34;
          LOBYTE(v42) = sub_7FF7053FA580(&v52, v40);
          LODWORD(v2) = v42;
          if ( v42 )
            break;
          ++v34;
          v41 -= 4LL;
        }
        while ( v41 );
        return v2;
      }
      v20 += 36LL;
      v18 = 0;
      v28 = ((36 - v23) * v17) >> 64 != 0;
      v19 = 1;
      v17 *= 36 - v23;
    }
    while ( !v28 );
  }
  a2 = v48;
  LOBYTE(v2) = 1;
  if ( sub_7FF7053F9DC0(v48) || v45 && (sub_7FF7053F9DC0(a2) || sub_7FF7053F9DC0(a2)) )
    return v2;
  if ( sub_7FF7053F9DC0(a2) )
    return v2;
  else
    return sub_7FF7053F9DC0(a2);
}
// 7FF7053F4270: variable 'v2' is possibly undefined
// 7FF7053F42C2: variable 'v42' is possibly undefined
// 7FF705403930: using guessed type char *off_7FF705403930;

//----- (00007FF7053F42E7) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F42E7(__int64 *a1)
{
  __int64 v1; // rsi
  unsigned __int8 *v2; // rax
  unsigned __int64 v3; // rdx
  unsigned __int8 *v4; // rcx
  __int64 v5; // rdx
  int v6; // r10d
  unsigned int v7; // r8d
  int v8; // r8d
  int v9; // r11d
  int v10; // r9d
  unsigned __int8 v11; // r10
  unsigned int v12; // r9d

  v1 = 1LL;
  v2 = sub_7FF7053F2D1D(*a1, a1[1], a0, 1uLL);
  if ( v3 <= 0x10 )
  {
    if ( !v3 )
      return v1;
    v4 = &v2[v3];
    v5 = 0LL;
    while ( 1 )
    {
      v6 = *v2;
      if ( (v6 & 0x80u) != 0 )
      {
        v8 = v6 & 0x1F;
        v9 = v2[1] & 0x3F;
        if ( v6 <= 0xDFu )
        {
          v2 += 2;
          v7 = v9 | (v8 << 6);
          goto LABEL_13;
        }
        v10 = (v9 << 6) | v2[2] & 0x3F;
        if ( v6 < 0xF0u )
        {
          v2 += 3;
          v7 = (v8 << 12) | v10;
          goto LABEL_13;
        }
        v11 = v2[3];
        v2 += 4;
        v6 = ((v8 & 7) << 18) | (v10 << 6) | v11 & 0x3F;
      }
      else
      {
        ++v2;
      }
      v7 = v6;
LABEL_13:
      v12 = v7 - 48;
      if ( v7 >= 0x3A )
        v12 = ((v7 - 65) & 0xFFFFFFDF) + 10;
      if ( v12 >= 0x10 )
        sub_7FF7053FE090(&off_7FF705403958);
      v5 = (16 * v5) | v12;
      if ( v2 == v4 )
        return v1;
    }
  }
  return 0LL;
}
// 7FF7053F4317: variable 'v3' is possibly undefined
// 7FF705403953: using guessed type char a0;
// 7FF705403958: using guessed type char *off_7FF705403958;

//----- (00007FF7053F43F8) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F43F8(char a1)
{
  unsigned __int8 v1; // cl

  v1 = a1 - 97;
  if ( v1 > 0x19u )
    return 0LL;
  else
    return *(&off_7FF705403E40 + v1);
}
// 7FF705403E40: using guessed type _UNKNOWN *off_7FF705403E40;

//----- (00007FF7053F4420) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053F4420(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v3; // r8
  _BYTE *v4; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // r11
  unsigned __int64 v7; // r9
  char v8; // si
  unsigned __int64 v9; // r9

  v3 = *(a2 + 16);
  v4 = *a2;
  v5 = *(a2 + 8);
  v6 = -1LL;
  v7 = v3;
  do
  {
    if ( v7 >= v5 )
      goto LABEL_10;
    v8 = v4[v7++];
    *(a2 + 16) = v7;
    ++v6;
  }
  while ( (v8 - 48) < 0xAu || (v8 - 97) < 6u );
  if ( v8 == 95 )
  {
    v9 = v7 - 1;
    if ( v3 > v9 )
      goto LABEL_9;
    if ( v3 )
    {
      if ( v3 >= v5 )
      {
        if ( v3 != v5 )
LABEL_9:
          sub_7FF7053FE500(v4, v5, v3, v9, &off_7FF705403AD0);
      }
      else if ( v4[v3] < -64 )
      {
        goto LABEL_9;
      }
    }
    *a1 = &v4[v3];
    a1[1] = v6;
  }
  else
  {
LABEL_10:
    *(a1 + 8) = 0;
    *a1 = 0LL;
  }
  return a1;
}
// 7FF705403AD0: using guessed type char *off_7FF705403AD0;

//----- (00007FF7053F44CD) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F44CD(__int64 a1, __int64 *a2)
{
  __int64 v3; // r10
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // rax
  char v7; // dl
  unsigned __int8 v8; // di
  unsigned __int8 v9; // dl
  __int64 v10; // rax
  unsigned __int64 v11; // kr00_8
  bool v12; // cf
  char v13; // al

  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  if ( v5 < v4 && *(v3 + v5) == 95 )
  {
    a2[2] = v5 + 1;
    *(a1 + 8) = 0LL;
  }
  else
  {
    v6 = 0LL;
    while ( 1 )
    {
      if ( v5 >= v4 )
        goto LABEL_15;
      if ( *(v3 + v5) == 95 )
        break;
      v7 = *(v3 + v5);
      v8 = v7 - 48;
      if ( (v7 - 48) >= 0xAu )
      {
        if ( (v7 - 97) >= 0x1Au )
        {
          if ( (v7 - 65) >= 0x1Au )
            goto LABEL_15;
          v9 = v7 - 29;
        }
        else
        {
          v9 = v7 - 87;
        }
        v8 = v9;
      }
      a2[2] = ++v5;
      v11 = v6;
      v10 = 62 * v6;
      if ( is_mul_ok(0x3EuLL, v11) )
      {
        v12 = __CFADD__(v8, v10);
        v6 = v8 + v10;
        if ( !v12 )
          continue;
      }
      goto LABEL_15;
    }
    a2[2] = v5 + 1;
    if ( v6 == -1LL )
    {
LABEL_15:
      *(a1 + 1) = 0;
      v13 = 1;
      goto LABEL_19;
    }
    *(a1 + 8) = v6 + 1;
  }
  v13 = 0;
LABEL_19:
  *a1 = v13;
  return a1;
}

//----- (00007FF7053F4571) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F4571(__int64 a1, __int64 *a2, char a3)
{
  unsigned __int64 v4; // rax
  char v5; // al
  _BYTE v7[8]; // [rsp+20h] [rbp-10h] BYREF
  __int64 v8; // [rsp+28h] [rbp-8h]

  v4 = a2[2];
  if ( v4 >= a2[1] || *(*a2 + v4) != a3 )
  {
    *(a1 + 8) = 0LL;
    goto LABEL_7;
  }
  a2[2] = v4 + 1;
  sub_7FF7053F44CD(v7, a2);
  if ( !v7[0] )
  {
    if ( v8 == -1 )
    {
      *(a1 + 1) = 0;
      goto LABEL_5;
    }
    *(a1 + 8) = v8 + 1;
LABEL_7:
    v5 = 0;
    goto LABEL_8;
  }
  *(a1 + 1) = v7[1];
LABEL_5:
  v5 = 1;
LABEL_8:
  *a1 = v5;
  return a1;
}

//----- (00007FF7053F45E5) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F45E5(_QWORD *a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 v4; // rax
  bool v5; // cf

  v1 = a1[2];
  if ( v1 >= a1[1] )
  {
    v4 = 1LL;
    v3 = 0LL;
  }
  else
  {
    v2 = *(*a1 + v1);
    a1[2] = v1 + 1;
    if ( (v2 - 65) >= 0x1Au )
    {
      v5 = (v2 - 123) < 0xE6u;
      v4 = v5;
      v3 = 0x11000000000000LL;
      if ( v5 )
        v3 = 0LL;
    }
    else
    {
      v3 = v2 << 32;
      v4 = 0LL;
    }
  }
  return v3 | v4;
}

//----- (00007FF7053F4634) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F4634(__int64 a1, __int64 a2)
{
  __int64 v4; // r14
  unsigned __int64 v5; // rax
  unsigned int v6; // ecx
  _BYTE v8[8]; // [rsp+20h] [rbp-10h] BYREF
  unsigned __int64 v9; // [rsp+28h] [rbp-8h]

  v4 = *(a2 + 16);
  sub_7FF7053F44CD(v8, a2);
  if ( v8[0] == 1 )
  {
    *(a1 + 8) = v8[1];
  }
  else
  {
    v5 = v9;
    if ( v9 >= v4 - 1 )
    {
      *(a1 + 8) = 0;
    }
    else
    {
      v6 = *(a2 + 24) + 1;
      if ( v6 <= 0x1F4 )
      {
        *a1 = *a2;
        *(a1 + 16) = v5;
        *(a1 + 24) = v6;
        return a1;
      }
      *(a1 + 8) = 1;
    }
  }
  *a1 = 0LL;
  return a1;
}

//----- (00007FF7053F46AD) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 *__fastcall sub_7FF7053F46AD(__int64 *a1, _QWORD *a2)
{
  unsigned __int64 v2; // r10
  unsigned __int64 v3; // r8
  char v4; // di
  _BYTE *v5; // rsi
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r8
  unsigned __int8 v8; // bl
  __int64 v9; // rax
  unsigned __int64 v10; // kr00_8
  bool v11; // cf
  unsigned __int64 v12; // r9
  _BYTE *v14; // rsi
  _BYTE *v15; // rdx
  unsigned __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r10
  unsigned __int64 v20; // r8
  __int64 v21; // rdx
  __int64 v22; // r11

  v2 = a2[1];
  v3 = a2[2];
  if ( v3 < v2 && *(*a2 + v3) == 117 )
  {
    a2[2] = ++v3;
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  if ( v3 < v2 )
  {
    v5 = *a2;
    LOBYTE(v6) = *(*a2 + v3) - 48;
    if ( v6 < 0xAu )
    {
      v7 = v3 + 1;
      a2[2] = v7;
      if ( v6 )
      {
        v6 = v6;
        while ( v7 < v2 )
        {
          v8 = v5[v7] - 48;
          if ( v8 > 9u )
            break;
          a2[2] = ++v7;
          v10 = v6;
          v9 = 10 * v6;
          if ( is_mul_ok(0xAuLL, v10) )
          {
            v11 = __CFADD__(v8, v9);
            v6 = v8 + v9;
            if ( !v11 )
              continue;
          }
          goto LABEL_20;
        }
      }
      else
      {
        v6 = 0LL;
      }
      if ( v7 < v2 && v5[v7] == 95 )
        a2[2] = ++v7;
      v12 = v6 + v7;
      if ( !__CFADD__(v6, v7) )
      {
        a2[2] = v12;
        if ( v12 <= v2 )
        {
          if ( v7 < v2 && v5[v7] <= -65 || v12 < v2 && v5[v12] <= -65 )
            sub_7FF7053FE500(v5, v2, v7, v12, &off_7FF705403AE8);
          v14 = &v5[v7];
          if ( !v4 )
          {
            *a1 = v14;
            a1[1] = v6;
            a1[2] = 1LL;
            a1[3] = 0LL;
            return a1;
          }
          v15 = &v14[v6];
          v16 = 0LL;
          v17 = 0LL;
          do
          {
            if ( !(v17 + v6) )
            {
              v21 = 1LL;
              goto LABEL_45;
            }
            v18 = v17 - 1;
          }
          while ( v15[--v17] != 95 );
          v20 = v6 + v18 + 1;
          v16 = v18 + v6;
          if ( !(v18 + v6) )
            goto LABEL_38;
          if ( v16 < v6 )
          {
            if ( v15[v18] <= -65 )
LABEL_48:
              sub_7FF7053FE500(v14, v6, 0LL, v16, &off_7FF705403B00);
            goto LABEL_38;
          }
          if ( v18 )
            goto LABEL_48;
          if ( v6 == -1LL )
          {
            v22 = 0LL;
          }
          else
          {
LABEL_38:
            if ( v20 < v6 )
            {
              if ( v15[v18 + 1] > -65 )
              {
                v22 = v6 + v18 + 1;
                goto LABEL_44;
              }
LABEL_42:
              sub_7FF7053FE500(v14, v6, v20, v6, &off_7FF705403B18);
            }
            v22 = v6;
            if ( v18 != -1 )
              goto LABEL_42;
          }
LABEL_44:
          v6 -= v22;
          v21 = v14;
          v14 += v22;
LABEL_45:
          if ( v6 )
          {
            *a1 = v21;
            a1[1] = v16;
            a1[2] = v14;
            a1[3] = v6;
            return a1;
          }
        }
      }
    }
  }
LABEL_20:
  *(a1 + 8) = 0;
  *a1 = 0LL;
  return a1;
}
// 7FF705403AE8: using guessed type char *off_7FF705403AE8;
// 7FF705403B00: using guessed type char *off_7FF705403B00;
// 7FF705403B18: using guessed type char *off_7FF705403B18;

//----- (00007FF7053F4895) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F4895(__int64 a1)
{
  __int64 v2; // rdi
  __int64 result; // rax
  _BYTE v4[17]; // [rsp+2Fh] [rbp-1h] BYREF

  v2 = *(a1 + 32);
  *(a1 + 32) = 0LL;
  result = sub_7FF7053F57DE(a1, 0LL);
  if ( result )
    sub_7FF7053FE440(aFmtErrorSShoul, 61LL, v4, "", &off_7FF705403B30);
  *(a1 + 32) = v2;
  return result;
}
// 7FF7053F57DE: using guessed type __int64 __fastcall sub_7FF7053F57DE(_QWORD, _QWORD);
// 7FF705403B30: using guessed type char *off_7FF705403B30;

//----- (00007FF7053F48F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F48F0(__int64 a1, _BYTE *a2)
{
  __int64 v4; // rdx
  __int128 v5; // xmm1
  char result; // al
  __int64 *v7; // r8
  __int64 *v8; // r8
  char *v9; // rcx
  char v10; // cl
  __int128 v11; // xmm0
  __int128 v12; // [rsp+20h] [rbp-40h]
  __int128 v13; // [rsp+30h] [rbp-30h]
  __int128 v14; // [rsp+48h] [rbp-18h] BYREF
  __int128 v15; // [rsp+58h] [rbp-8h]

  if ( !*a1 )
  {
    v7 = *(a1 + 32);
    if ( v7 )
      return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v7);
    return 0;
  }
  sub_7FF7053F4634(&v14, a1);
  if ( v14 )
  {
    if ( *(a1 + 32) )
    {
      v13 = *(a1 + 16);
      v12 = *a1;
      v5 = v15;
      *a1 = v14;
      *(a1 + 16) = v5;
      LOBYTE(v4) = *a2;
      result = sub_7FF7053F6831(a1, v4);
      *a1 = v12;
      *(a1 + 16) = v13;
      return result;
    }
    return 0;
  }
  v8 = *(a1 + 32);
  if ( !v8 )
    goto LABEL_11;
  v9 = aInvalidSyntax;
  if ( BYTE8(v14) )
    v9 = aRecursionLimit;
  v10 = sub_7FF7053FA4C0(v9, 9LL * BYTE8(v14) + 16, v8);
  result = 1;
  if ( !v10 )
  {
LABEL_11:
    v11 = v14;
    *(a1 + 16) = v15;
    *a1 = v11;
    return 0;
  }
  return result;
}
// 7FF7053F494C: variable 'v4' is possibly undefined
// 7FF7053F6831: using guessed type __int64 __fastcall sub_7FF7053F6831(_QWORD, _QWORD);
// 7FF705403B71: using guessed type char asc_7FF705403B71;

//----- (00007FF7053F49D6) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F49D6(__int64 a1, _BYTE *a2)
{
  __int64 v4; // rdx
  __int128 v5; // xmm1
  char result; // al
  __int64 *v7; // r8
  __int64 *v8; // r8
  char *v9; // rcx
  char v10; // cl
  __int128 v11; // xmm0
  __int128 v12; // [rsp+20h] [rbp-40h]
  __int128 v13; // [rsp+30h] [rbp-30h]
  __int128 v14; // [rsp+48h] [rbp-18h] BYREF
  __int128 v15; // [rsp+58h] [rbp-8h]

  if ( !*a1 )
  {
    v7 = *(a1 + 32);
    if ( v7 )
      return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v7);
    return 0;
  }
  sub_7FF7053F4634(&v14, a1);
  if ( v14 )
  {
    if ( *(a1 + 32) )
    {
      v13 = *(a1 + 16);
      v12 = *a1;
      v5 = v15;
      *a1 = v14;
      *(a1 + 16) = v5;
      LOBYTE(v4) = *a2;
      result = sub_7FF7053F57DE(a1, v4);
      *a1 = v12;
      *(a1 + 16) = v13;
      return result;
    }
    return 0;
  }
  v8 = *(a1 + 32);
  if ( !v8 )
    goto LABEL_11;
  v9 = aInvalidSyntax;
  if ( BYTE8(v14) )
    v9 = aRecursionLimit;
  v10 = sub_7FF7053FA4C0(v9, 9LL * BYTE8(v14) + 16, v8);
  result = 1;
  if ( !v10 )
  {
LABEL_11:
    v11 = v14;
    *(a1 + 16) = v15;
    *a1 = v11;
    return 0;
  }
  return result;
}
// 7FF7053F4A32: variable 'v4' is possibly undefined
// 7FF7053F57DE: using guessed type __int64 __fastcall sub_7FF7053F57DE(_QWORD, _QWORD);
// 7FF705403B71: using guessed type char asc_7FF705403B71;

//----- (00007FF7053F4ABC) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F4ABC(__int64 a1)
{
  __int128 v2; // xmm1
  char result; // al
  __int64 *v4; // r8
  __int64 *v5; // r8
  char *v6; // rcx
  char v7; // cl
  __int128 v8; // xmm0
  __int128 v9; // [rsp+20h] [rbp-40h]
  __int128 v10; // [rsp+30h] [rbp-30h]
  __int128 v11; // [rsp+40h] [rbp-20h] BYREF
  __int128 v12; // [rsp+50h] [rbp-10h]

  if ( !*a1 )
  {
    v4 = *(a1 + 32);
    if ( v4 )
      return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v4);
    return 0;
  }
  sub_7FF7053F4634(&v11, a1);
  if ( v11 )
  {
    if ( *(a1 + 32) )
    {
      v10 = *(a1 + 16);
      v9 = *a1;
      v2 = v12;
      *a1 = v11;
      *(a1 + 16) = v2;
      result = sub_7FF7053F5E83(a1);
      *a1 = v9;
      *(a1 + 16) = v10;
      return result;
    }
    return 0;
  }
  v5 = *(a1 + 32);
  if ( !v5 )
    goto LABEL_11;
  v6 = aInvalidSyntax;
  if ( BYTE8(v11) )
    v6 = aRecursionLimit;
  v7 = sub_7FF7053FA4C0(v6, 9LL * BYTE8(v11) + 16, v5);
  result = 1;
  if ( !v7 )
  {
LABEL_11:
    v8 = v11;
    *(a1 + 16) = v12;
    *a1 = v8;
    return 0;
  }
  return result;
}
// 7FF7053F5E83: using guessed type __int64 __fastcall sub_7FF7053F5E83(_QWORD);
// 7FF705403B71: using guessed type char asc_7FF705403B71;

//----- (00007FF7053F4B9A) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F4B9A(__int64 a1, signed int a2)
{
  unsigned int v2; // esi
  _QWORD *v3; // rdi
  unsigned __int8 v5; // r14
  unsigned __int8 v6; // al
  unsigned __int64 i; // r12
  _TBYTE v9; // [rsp+28h] [rbp-18h] BYREF
  unsigned __int8 v10; // [rsp+32h] [rbp-Eh]
  unsigned __int8 v11; // [rsp+33h] [rbp-Dh]
  _TBYTE v12; // [rsp+38h] [rbp-8h]

  v3 = *(a1 + 32);
  if ( !v3 )
    return 0;
  LOBYTE(v2) = 1;
  if ( sub_7FF7053FA100(*(a1 + 32)) )
    return v2;
  while ( 1 )
  {
    while ( a2 == 34 )
    {
      a2 = 1114112;
      if ( sub_7FF7053FA100(v3) )
        return v2;
    }
    if ( a2 == 1114112 )
      return sub_7FF7053FA100(v3);
    if ( a2 > 12 )
    {
      switch ( a2 )
      {
        case 13:
          LOWORD(v12) = 29276;
          break;
        case 39:
          LOWORD(v12) = 10076;
          break;
        case 92:
          LOWORD(v12) = 23644;
          break;
        default:
LABEL_18:
          if ( a2 > 0x2FF && sub_7FF7053FC600(a2) || !sub_7FF7053FBC50(a2) )
          {
            sub_7FF7053F2EBF(&v9, a2);
            v12 = v9;
            v6 = v10;
            v5 = v11;
          }
          else
          {
            LODWORD(v12) = a2;
            v5 = -127;
            v6 = 0x80;
          }
          goto LABEL_25;
      }
    }
    else if ( a2 )
    {
      if ( a2 == 9 )
      {
        LOWORD(v12) = 29788;
      }
      else
      {
        if ( a2 != 10 )
          goto LABEL_18;
        LOWORD(v12) = 28252;
      }
    }
    else
    {
      LOWORD(v12) = 12380;
    }
    *(&v12 + 2) = 0LL;
    v5 = 2;
    v6 = 0;
LABEL_25:
    v9 = v12;
    for ( i = v6; i < v5; ++i )
    {
      if ( sub_7FF7053FA100(v3) )
        return v2;
    }
    a2 = 1114112;
  }
}
// 7FF7053F4D10: variable 'v2' is possibly undefined

//----- (00007FF7053F4D40) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F4D40(__int64 a1, unsigned __int64 a2)
{
  __int64 *v2; // rsi
  char v5; // di
  unsigned __int64 v6; // r15
  bool v7; // cf
  unsigned __int64 v8; // r15
  unsigned __int64 v11; // [rsp+28h] [rbp-8h] BYREF
  unsigned int v12[11]; // [rsp+34h] [rbp+4h] BYREF

  v2 = *(a1 + 32);
  if ( !v2 )
    return 0;
  v5 = 1;
  if ( sub_7FF7053FA4C0(asc_7FF705403B72, 1uLL, v2) )
    return v5;
  if ( a2 )
  {
    v6 = *(a1 + 40);
    v7 = v6 < a2;
    v8 = v6 - a2;
    if ( !v7 )
    {
      if ( v8 >= 0x1A )
      {
        if ( sub_7FF7053FA4C0(asc_7FF705403ACA, 1uLL, v2) )
          return v5;
        v11 = v8;
        return sub_7FF7053FC390(&v11, v2);
      }
      else
      {
        v12[0] = v8 + 97;
        return sub_7FF7053FA580(v12, v2);
      }
    }
    if ( !sub_7FF7053FA4C0(aInvalidSyntax, 0x10uLL, v2) )
    {
      *a1 = 0LL;
      *(a1 + 8) = 0;
      return 0;
    }
    return v5;
  }
  return sub_7FF7053FA4C0(asc_7FF705403ACA, 1uLL, v2);
}
// 7FF705403ACA: using guessed type char asc_7FF705403ACA;
// 7FF705403B72: using guessed type char asc_7FF705403B72;

//----- (00007FF7053F4E23) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F4E23(__int64 a1)
{
  unsigned __int8 v2; // bl
  __int64 *v3; // r8
  char *v4; // rcx
  char v5; // di
  __int64 *v6; // r8
  char result; // al
  __int64 *v8; // r8
  __int64 v9; // r14
  __int64 v10; // r15
  __int64 *v11; // r8
  __int64 *v12; // r8
  char v13; // [rsp+28h] [rbp-8h] BYREF
  unsigned __int8 v14; // [rsp+29h] [rbp-7h]
  __int64 v15; // [rsp+30h] [rbp+0h]

  if ( !*a1 )
  {
    v6 = *(a1 + 32);
    if ( v6 )
      return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v6);
    return 0;
  }
  sub_7FF7053F4571(&v13, a1, 71);
  if ( v13 == 1 )
  {
    v2 = v14;
    v3 = *(a1 + 32);
    if ( v3 )
    {
      v4 = aInvalidSyntax;
      if ( v14 )
        v4 = aRecursionLimit;
      v5 = 1;
      if ( sub_7FF7053FA4C0(v4, 9LL * v14 + 16, v3) )
        return v5;
    }
    *a1 = 0LL;
    *(a1 + 8) = v2;
    return 0;
  }
  v8 = *(a1 + 32);
  if ( !v8 )
    return sub_7FF7053F6368(a1);
  v9 = v15;
  if ( v15 )
  {
    v5 = 1;
    if ( sub_7FF7053FA4C0(aFor, 4uLL, v8) )
      return v5;
    v10 = 0LL;
    while ( v9 != v10 )
    {
      if ( !v10 || (v11 = *(a1 + 32)) == 0LL || !sub_7FF7053FA4C0(asc_7FF705403B79, 2uLL, v11) )
      {
        ++*(a1 + 40);
        ++v10;
        if ( !sub_7FF7053F4D40(a1, 1uLL) )
          continue;
      }
      return v5;
    }
    v12 = *(a1 + 32);
    if ( v12 )
    {
      if ( sub_7FF7053FA4C0(asc_7FF705403B77, 2uLL, v12) )
        return v5;
    }
  }
  result = sub_7FF7053F6368(a1);
  *(a1 + 40) -= v9;
  return result;
}
// 7FF705403B71: using guessed type char asc_7FF705403B71;

//----- (00007FF7053F4F8D) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F4F8D(__int64 a1)
{
  unsigned __int8 v2; // bl
  __int64 *v3; // r8
  char *v4; // rcx
  char v5; // di
  __int64 *v6; // r8
  __int64 *v8; // r8
  __int64 v9; // r14
  __int64 v10; // r15
  __int64 *v11; // r8
  __int64 *v12; // r8
  char v13; // [rsp+28h] [rbp-8h] BYREF
  unsigned __int8 v14; // [rsp+29h] [rbp-7h]
  __int64 v15; // [rsp+30h] [rbp+0h]

  if ( !*a1 )
  {
    v6 = *(a1 + 32);
    if ( v6 )
      return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v6);
    goto LABEL_10;
  }
  sub_7FF7053F4571(&v13, a1, 71);
  if ( v13 != 1 )
  {
    v8 = *(a1 + 32);
    if ( v8 )
    {
      v9 = v15;
      if ( !v15 )
        goto LABEL_24;
      v5 = 1;
      if ( !sub_7FF7053FA4C0(aFor, 4uLL, v8) )
      {
        v10 = 0LL;
        while ( v9 != v10 )
        {
          if ( !v10 || (v11 = *(a1 + 32)) == 0LL || !sub_7FF7053FA4C0(asc_7FF705403B79, 2uLL, v11) )
          {
            ++*(a1 + 40);
            ++v10;
            if ( !sub_7FF7053F4D40(a1, 1uLL) )
              continue;
          }
          return v5 & 1;
        }
        v12 = *(a1 + 32);
        if ( !v12 || !sub_7FF7053FA4C0(asc_7FF705403B77, 2uLL, v12) )
        {
LABEL_24:
          v5 = sub_7FF7053F55AF(a1);
          *(a1 + 40) -= v9;
        }
      }
    }
    else
    {
      v5 = sub_7FF7053F55AF(a1);
    }
    return v5 & 1;
  }
  v2 = v14;
  v3 = *(a1 + 32);
  if ( !v3 )
    goto LABEL_7;
  v4 = aInvalidSyntax;
  if ( v14 )
    v4 = aRecursionLimit;
  v5 = 1;
  if ( !sub_7FF7053FA4C0(v4, 9LL * v14 + 16, v3) )
  {
LABEL_7:
    *a1 = 0LL;
    *(a1 + 8) = v2;
LABEL_10:
    v5 = 0;
  }
  return v5 & 1;
}
// 7FF705403B71: using guessed type char asc_7FF705403B71;

//----- (00007FF7053F50F8) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F50F8(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // rdi
  __int64 i; // rsi
  unsigned __int64 v6; // rcx
  __int64 *v7; // r8

  v2 = *a1;
  if ( *a1 )
  {
    v4 = 0LL;
    for ( i = 0LL; ; ++i )
    {
      v6 = a1[2];
      if ( v6 < a1[1] && *(v2 + v6) == 69 )
        break;
      if ( i )
      {
        v7 = a1[4];
        if ( v7 )
        {
          if ( sub_7FF7053FA4C0(asc_7FF705403B79, 2uLL, v7) )
            return 1LL;
        }
      }
      LOBYTE(a2) = 1;
      if ( sub_7FF7053F6831(a1, a2) )
        return 1LL;
      v2 = *a1;
      if ( !*a1 )
        return v4;
    }
    a1[2] = v6 + 1;
  }
  return 0LL;
}
// 7FF7053F5151: variable 'a2' is possibly undefined
// 7FF7053F6831: using guessed type __int64 __fastcall sub_7FF7053F6831(_QWORD, _QWORD);

//----- (00007FF7053F518C) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F518C(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // rsi
  __int64 v5; // r14
  unsigned __int64 v6; // rcx
  __int64 *v8; // r8

  v2 = *a1;
  if ( *a1 )
  {
    v4 = 0LL;
    v5 = 0LL;
    while ( 1 )
    {
      v6 = a1[2];
      if ( v6 < a1[1] && *(v2 + v6) == 69 )
        break;
      if ( v5-- != 0 )
      {
        v8 = a1[4];
        if ( v8 )
        {
          if ( sub_7FF7053FA4C0(asc_7FF705403B79, 2uLL, v8) )
            return 1LL;
        }
      }
      LOBYTE(a2) = 1;
      if ( sub_7FF7053F6831(a1, a2) )
        return 1LL;
      v2 = *a1;
      if ( !*a1 )
        return v4;
    }
    a1[2] = v6 + 1;
  }
  return 0LL;
}
// 7FF7053F51E7: variable 'a2' is possibly undefined
// 7FF7053F6831: using guessed type __int64 __fastcall sub_7FF7053F6831(_QWORD, _QWORD);

//----- (00007FF7053F5218) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F5218(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v3; // rdi
  __int64 i; // rsi
  unsigned __int64 v5; // rcx
  __int64 *v6; // r8

  v1 = *a1;
  if ( *a1 )
  {
    v3 = 0LL;
    for ( i = 0LL; ; ++i )
    {
      v5 = a1[2];
      if ( v5 < a1[1] && *(v1 + v5) == 69 )
        break;
      if ( i )
      {
        v6 = a1[4];
        if ( v6 )
        {
          if ( sub_7FF7053FA4C0(asc_7FF705403B79, 2uLL, v6) )
            return 1LL;
        }
      }
      if ( sub_7FF7053F5E83(a1) )
        return 1LL;
      v1 = *a1;
      if ( !*a1 )
        return v3;
    }
    a1[2] = v5 + 1;
  }
  return 0LL;
}
// 7FF7053F5E83: using guessed type __int64 __fastcall sub_7FF7053F5E83(_QWORD);

//----- (00007FF7053F52AA) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F52AA(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v3; // rdi
  __int64 v4; // r15
  unsigned __int64 v5; // rcx
  __int64 *v7; // r8
  unsigned __int64 v8; // rcx
  char v9; // al
  unsigned __int8 v10; // bl
  __int64 *v11; // r8
  char *v12; // rcx
  char v14; // [rsp+28h] [rbp-8h] BYREF
  unsigned __int8 v15; // [rsp+29h] [rbp-7h]
  unsigned __int64 v16; // [rsp+30h] [rbp+0h]

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  v3 = 0LL;
  v4 = 0LL;
  while ( 1 )
  {
    v5 = a1[2];
    if ( v5 < a1[1] && *(v1 + v5) == 69 )
    {
      a1[2] = v5 + 1;
      return 0LL;
    }
    if ( v4-- != 0 )
    {
      v7 = a1[4];
      if ( v7 )
      {
        if ( sub_7FF7053FA4C0(asc_7FF705403B79, 2uLL, v7) )
          return 1LL;
        v1 = *a1;
        if ( !*a1 )
          goto LABEL_15;
      }
    }
    v8 = a1[2];
    if ( v8 >= a1[1] )
      goto LABEL_15;
    if ( *(v1 + v8) == 76 )
      break;
    if ( *(v1 + v8) == 75 )
    {
      a1[2] = v8 + 1;
      v9 = sub_7FF7053F6831(a1, 0);
      goto LABEL_16;
    }
LABEL_15:
    v9 = sub_7FF7053F5E83(a1);
LABEL_16:
    if ( v9 )
      return 1LL;
    v1 = *a1;
    if ( !*a1 )
      return v3;
  }
  a1[2] = v8 + 1;
  sub_7FF7053F44CD(&v14, a1);
  if ( !v14 )
  {
    v9 = sub_7FF7053F4D40(a1, v16);
    goto LABEL_16;
  }
  v10 = v15;
  v11 = a1[4];
  if ( v11 )
  {
    v12 = aInvalidSyntax;
    if ( v15 )
      v12 = aRecursionLimit;
    if ( sub_7FF7053FA4C0(v12, 9LL * v15 + 16, v11) )
      return 1LL;
  }
  *a1 = 0LL;
  *(a1 + 8) = v10;
  return 0LL;
}

//----- (00007FF7053F53E3) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F53E3(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v3; // rbx
  unsigned __int64 v4; // rcx
  __int64 *v6; // r8
  char v7; // r13
  __int64 *v8; // r8
  char *v9; // rcx
  unsigned __int64 v10; // rdx
  __int64 *v11; // rdx
  __int64 *v12; // r8
  __int64 *v13; // r8
  __int64 v14; // r13
  _OWORD v16[2]; // [rsp+20h] [rbp-40h] BYREF
  _OWORD v17[5]; // [rsp+48h] [rbp-18h] BYREF

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  v3 = 0LL;
  while ( 1 )
  {
    v4 = a1[2];
    if ( v4 < a1[1] && *(v1 + v4) == 69 )
      break;
    if ( v3-- != 0 )
    {
      v6 = a1[4];
      if ( v6 )
      {
        if ( sub_7FF7053FA4C0(asc_7FF705403B79, 2uLL, v6) )
          return 1LL;
        if ( !*a1 )
          goto LABEL_24;
      }
    }
    sub_7FF7053F4571(v17, a1, 115);
    if ( LOBYTE(v17[0]) == 1 )
    {
      v7 = BYTE1(v17[0]);
      v8 = a1[4];
      if ( v8 )
      {
        v9 = aInvalidSyntax;
        if ( BYTE1(v17[0]) )
          v9 = aRecursionLimit;
        v10 = 9LL * BYTE1(v17[0]) + 16;
LABEL_14:
        if ( sub_7FF7053FA4C0(v9, v10, v8) )
          return 1LL;
      }
      goto LABEL_15;
    }
    if ( *a1 )
    {
      sub_7FF7053F46AD(v17, a1);
      if ( !*&v17[0] )
      {
        v7 = BYTE8(v17[0]);
        v8 = a1[4];
        if ( v8 )
        {
          v10 = 9LL * BYTE8(v17[0]) + 16;
          v9 = aInvalidSyntax;
          if ( BYTE8(v17[0]) )
            v9 = aRecursionLimit;
          goto LABEL_14;
        }
LABEL_15:
        *a1 = 0LL;
        *(a1 + 8) = v7;
        goto LABEL_26;
      }
      v16[1] = v17[1];
      v16[0] = v17[0];
      v11 = a1[4];
      if ( v11 )
      {
        if ( sub_7FF7053F3E7E(v16, v11) )
          return 1LL;
        v12 = a1[4];
        if ( v12 )
        {
          if ( sub_7FF7053FA4C0(asc_7FF705403BEB, 2uLL, v12) )
            return 1LL;
        }
      }
      LOBYTE(v11) = 1;
      if ( sub_7FF7053F6831(a1, v11) )
        return 1LL;
    }
    else
    {
LABEL_24:
      v13 = a1[4];
      if ( v13 )
      {
        v14 = 1LL;
        if ( sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v13) )
          return v14;
      }
    }
LABEL_26:
    v1 = *a1;
    if ( !*a1 )
      return 0LL;
  }
  a1[2] = v4 + 1;
  return 0LL;
}
// 7FF7053F5521: variable 'v11' is possibly undefined
// 7FF7053F6831: using guessed type __int64 __fastcall sub_7FF7053F6831(_QWORD, _QWORD);
// 7FF705403B71: using guessed type char asc_7FF705403B71;

//----- (00007FF7053F55AF) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F55AF(_QWORD *a1)
{
  __int64 v1; // rax
  __int64 v3; // rbx
  unsigned __int64 v4; // rcx
  __int64 *v5; // r8
  char v6; // al
  char v7; // di
  unsigned __int64 v8; // rax
  __int64 *v9; // r8
  unsigned __int64 v10; // rdx
  unsigned __int16 *v11; // rcx
  __int64 *v12; // rdx
  __int64 *v13; // r8
  __int64 *v14; // r8
  __int64 v15; // rdi
  unsigned __int16 *v16; // rcx
  char v17; // di
  __int64 *v18; // r8
  char *v19; // rcx
  _OWORD v21[2]; // [rsp+20h] [rbp-40h] BYREF
  _OWORD v22[5]; // [rsp+48h] [rbp-18h] BYREF

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  v3 = 0LL;
  while ( 2 )
  {
    v4 = a1[2];
    if ( v4 < a1[1] && *(v1 + v4) == 69 )
    {
      a1[2] = v4 + 1;
      return 0LL;
    }
    if ( v3 )
    {
      v5 = a1[4];
      if ( v5 )
      {
        if ( sub_7FF7053FA4C0(asc_7FF705403BA2, 3uLL, v5) )
          return 1LL;
      }
    }
    v6 = sub_7FF7053F66EF(a1);
    if ( v6 == 2 )
      return 1LL;
    v7 = v6;
    while ( 1 )
    {
      if ( !*a1 || (v8 = a1[2], v8 >= a1[1]) || *(*a1 + v8) != 112 )
      {
        if ( (v7 & 1) == 0 )
          goto LABEL_39;
        v14 = a1[4];
        if ( !v14 )
          goto LABEL_39;
        v15 = 1LL;
        v16 = &unk_7FF7054037F3;
        goto LABEL_32;
      }
      a1[2] = v8 + 1;
      if ( (v7 & 1) != 0 )
      {
        v9 = a1[4];
        if ( !v9 )
          goto LABEL_19;
        v10 = 2LL;
        v11 = asc_7FF705403B79;
      }
      else
      {
        v9 = a1[4];
        v7 = 1;
        if ( !v9 )
          goto LABEL_19;
        v10 = 1LL;
        v11 = &unk_7FF7054037F4;
      }
      if ( sub_7FF7053FA4C0(v11, v10, v9) )
        return 1LL;
LABEL_19:
      if ( !*a1 )
      {
        v14 = a1[4];
        if ( !v14 )
          goto LABEL_39;
        v15 = 1LL;
        v16 = asc_7FF705403B71;
LABEL_32:
        if ( sub_7FF7053FA4C0(v16, 1uLL, v14) )
          return v15;
        goto LABEL_39;
      }
      sub_7FF7053F46AD(v22, a1);
      if ( !*&v22[0] )
        break;
      v21[1] = v22[1];
      v21[0] = v22[0];
      v12 = a1[4];
      if ( v12 )
      {
        if ( sub_7FF7053F3E7E(v21, v12) )
          return 1LL;
        v13 = a1[4];
        if ( v13 )
        {
          if ( sub_7FF7053FA4C0(asc_7FF705403BD9, 3uLL, v13) )
            return 1LL;
        }
      }
      if ( sub_7FF7053F5E83(a1) )
        return 1LL;
    }
    v17 = BYTE8(v22[0]);
    v18 = a1[4];
    if ( v18 )
    {
      v19 = aInvalidSyntax;
      if ( BYTE8(v22[0]) )
        v19 = aRecursionLimit;
      if ( sub_7FF7053FA4C0(v19, 9LL * BYTE8(v22[0]) + 16, v18) )
        return 1LL;
    }
    *a1 = 0LL;
    *(a1 + 8) = v17;
LABEL_39:
    ++v3;
    v1 = *a1;
    if ( *a1 )
      continue;
    return 0LL;
  }
}
// 7FF7053F5E83: using guessed type __int64 __fastcall sub_7FF7053F5E83(_QWORD);
// 7FF705403B71: using guessed type char asc_7FF705403B71;

//----- (00007FF7053F57DE) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F57DE(__int64 a1, unsigned int a2)
{
  __int64 v3; // rax
  unsigned int v4; // ecx
  __int64 *v5; // r8
  char v6; // di
  unsigned __int64 v7; // rcx
  unsigned __int8 v9; // bl
  __int64 v10; // rax
  unsigned __int64 v11; // rbx
  __int64 v12; // rbx
  __int64 *v13; // r8
  char *v14; // rcx
  __int64 *v15; // r8
  __int64 *v16; // r8
  __int64 *v17; // r8
  unsigned __int8 v18; // bl
  __int64 *v19; // r8
  unsigned __int64 v20; // rdx
  char *v21; // rcx
  char v22; // al
  __int64 *v23; // r8
  __int64 *v24; // r8
  __int64 *v25; // r8
  unsigned __int16 *v26; // rcx
  __int64 v27; // r15
  unsigned __int64 v28; // rbx
  __int64 *v29; // r8
  __int64 *v30; // rdx
  __int64 v31; // rbx
  __int64 *v32; // rdx
  __int64 v33; // rcx
  __int64 *v34; // r8
  __int64 *v35; // r8
  __int64 *v36; // r8
  __int64 *v38; // r8
  __int64 *v39; // r8
  char *v40; // rcx
  unsigned __int64 v41; // rdx
  char v42; // al
  __int64 *v43; // rdx
  __int64 *v44; // r8
  __int64 v45; // rdx
  __int64 *v46; // rdx
  _OWORD v47[2]; // [rsp+20h] [rbp-60h] BYREF
  unsigned __int64 v48; // [rsp+48h] [rbp-38h] BYREF
  __int128 v49; // [rsp+50h] [rbp-30h] BYREF
  __int128 v50; // [rsp+60h] [rbp-20h]
  __int128 v51; // [rsp+70h] [rbp-10h] BYREF
  __int128 v52; // [rsp+80h] [rbp+0h]
  char v53[41]; // [rsp+97h] [rbp+17h] BYREF

  v53[0] = a2;
  v3 = *a1;
  if ( !*a1 )
    goto LABEL_88;
  v4 = *(a1 + 24) + 1;
  *(a1 + 24) = v4;
  if ( v4 >= 0x1F5 )
  {
    v5 = *(a1 + 32);
    if ( v5 )
    {
      v6 = 1;
      if ( sub_7FF7053FA4C0(aRecursionLimit, 0x19uLL, v5) )
        return v6;
    }
    *a1 = 0LL;
    *(a1 + 8) = 1;
    return 0;
  }
  v7 = *(a1 + 16);
  if ( v7 >= *(a1 + 8) )
    goto LABEL_30;
  v9 = *(v3 + v7);
  *(a1 + 16) = v7 + 1;
  if ( v9 <= 0x4Cu )
  {
    switch ( v9 )
    {
      case 'B':
        v22 = sub_7FF7053F49D6(a1, v53);
        v6 = 1;
        goto LABEL_49;
      case 'C':
        sub_7FF7053F4571(&v51, a1, 115);
        if ( v51 != 1 )
        {
          v31 = *(&v51 + 1);
          v48 = *(&v51 + 1);
          if ( !*a1 )
          {
            v34 = *(a1 + 32);
            if ( v34 )
              return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v34);
            return 0;
          }
          sub_7FF7053F46AD(&v51, a1);
          if ( v51 )
          {
            v47[1] = v52;
            v47[0] = v51;
            v32 = *(a1 + 32);
            if ( v32 )
            {
              v6 = 1;
              if ( sub_7FF7053F3E7E(v47, v32) )
                return v6;
              v33 = *(a1 + 32);
              if ( v33
                && v31
                && (*(v33 + 16) & 0x800000) == 0
                && (sub_7FF7053F9DC0(v33) || sub_7FF7053FBF60(&v48, *(a1 + 32)) || sub_7FF7053F9DC0(*(a1 + 32))) )
              {
                return 1;
              }
            }
            goto LABEL_50;
          }
          goto LABEL_84;
        }
LABEL_53:
        v18 = BYTE1(v51);
        goto LABEL_54;
      case 'I':
        v6 = 1;
        if ( sub_7FF7053F57DE(a1, a2) )
          return v6;
        if ( a2 )
        {
          v15 = *(a1 + 32);
          if ( v15 )
          {
            if ( sub_7FF7053FA4C0(word_7FF705403738, 2uLL, v15) )
              return v6;
          }
        }
        v16 = *(a1 + 32);
        if ( v16 )
        {
          if ( sub_7FF7053FA4C0(&unk_7FF7054037F4, 1uLL, v16) )
            return v6;
        }
        if ( (sub_7FF7053F52AA(a1) & 1) != 0 )
          return v6;
LABEL_46:
        v25 = *(a1 + 32);
        if ( !v25 )
          goto LABEL_50;
        v26 = &unk_7FF7054037F3;
        goto LABEL_48;
    }
    goto LABEL_30;
  }
  if ( v9 > 0x57u )
  {
    if ( v9 == 88 )
      goto LABEL_33;
    if ( v9 == 89 )
    {
LABEL_39:
      v23 = *(a1 + 32);
      if ( v23 )
      {
        v6 = 1;
        if ( sub_7FF7053FA4C0(&unk_7FF7054037F4, 1uLL, v23) )
          return v6;
      }
      v6 = 1;
      if ( sub_7FF7053F5E83(a1) )
        return v6;
      if ( v9 != 77 )
      {
        v24 = *(a1 + 32);
        if ( v24 )
        {
          if ( sub_7FF7053FA4C0(aAs, 4uLL, v24) )
            return v6;
        }
        if ( sub_7FF7053F57DE(a1, 0LL) )
          return v6;
      }
      goto LABEL_46;
    }
LABEL_30:
    v17 = *(a1 + 32);
    if ( v17 )
    {
      v6 = 1;
      if ( sub_7FF7053FA4C0(aInvalidSyntax, 0x10uLL, v17) )
        return v6;
    }
    *a1 = 0LL;
    *(a1 + 8) = 0;
    return 0;
  }
  if ( v9 == 77 )
  {
LABEL_33:
    sub_7FF7053F4571(&v51, a1, 115);
    if ( v51 == 1 )
    {
      v18 = BYTE1(v51);
      v19 = *(a1 + 32);
      if ( v19 )
      {
        v20 = 9LL * BYTE1(v51) + 16;
        v21 = aInvalidSyntax;
        if ( BYTE1(v51) )
          v21 = aRecursionLimit;
LABEL_58:
        v6 = 1;
        if ( sub_7FF7053FA4C0(v21, v20, v19) )
          return v6;
      }
LABEL_59:
      *a1 = 0LL;
      *(a1 + 8) = v18;
      return 0;
    }
    sub_7FF7053F4895(a1);
    goto LABEL_39;
  }
  if ( v9 != 78 )
    goto LABEL_30;
  v10 = sub_7FF7053F45E5(a1);
  v11 = v10;
  if ( (v10 & 1) != 0 )
  {
    v12 = v10 & 0x100;
    v13 = *(a1 + 32);
    if ( v13 )
    {
      v14 = aRecursionLimit;
      if ( (v10 & 0x100) == 0 )
        v14 = aInvalidSyntax;
      v6 = 1;
      if ( sub_7FF7053FA4C0(v14, 9LL * (v12 != 0) + 16, v13) )
        return v6;
    }
    *a1 = 0LL;
    *(a1 + 8) = BYTE1(v12);
    return 0;
  }
  v6 = 1;
  if ( sub_7FF7053F57DE(a1, a2) )
    return v6;
  if ( !*a1 )
  {
    v35 = *(a1 + 32);
    if ( !v35 )
      return 0;
    if ( sub_7FF7053FA4C0(word_7FF705403738, 2uLL, v35) )
      return v6;
    if ( !*a1 )
    {
LABEL_88:
      v36 = *(a1 + 32);
      if ( v36 )
        return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v36);
      return 0;
    }
  }
  sub_7FF7053F4571(&v51, a1, 115);
  if ( v51 == 1 )
    goto LABEL_53;
  if ( !*a1 )
    goto LABEL_88;
  v27 = *(&v51 + 1);
  sub_7FF7053F46AD(&v51, a1);
  if ( !v51 )
  {
LABEL_84:
    v18 = BYTE8(v51);
LABEL_54:
    v19 = *(a1 + 32);
    if ( v19 )
    {
      v21 = aInvalidSyntax;
      if ( v18 )
        v21 = aRecursionLimit;
      v20 = 9LL * v18 + 16;
      goto LABEL_58;
    }
    goto LABEL_59;
  }
  v28 = HIDWORD(v11);
  v50 = v52;
  v49 = v51;
  if ( v28 != 1114112 )
  {
    v38 = *(a1 + 32);
    if ( v38 && sub_7FF7053FA4C0(asc_7FF705403B7D, 3uLL, v38) )
      return v6;
    if ( v28 == 67 )
    {
      v39 = *(a1 + 32);
      if ( v39 )
      {
        v40 = aClosure;
        v41 = 7LL;
        goto LABEL_100;
      }
    }
    else if ( v28 == 83 )
    {
      v39 = *(a1 + 32);
      if ( v39 )
      {
        v40 = aShim;
        v41 = 4LL;
LABEL_100:
        v42 = sub_7FF7053FA4C0(v40, v41, v39);
        goto LABEL_103;
      }
    }
    else
    {
      LODWORD(v51) = v28;
      v43 = *(a1 + 32);
      if ( v43 )
      {
        v42 = sub_7FF7053FA580(&v51, v43);
LABEL_103:
        if ( v42 )
          return v6;
      }
    }
    v44 = *(a1 + 32);
    if ( *(&v49 + 1) | *(&v50 + 1) )
    {
      if ( !v44 )
        goto LABEL_50;
      if ( sub_7FF7053FA4C0(asc_7FF705403B8B, 1uLL, v44) )
        return v6;
      v46 = *(a1 + 32);
      if ( !v46 )
        goto LABEL_50;
      if ( sub_7FF7053F3E7E(&v49, v46) )
        return v6;
      v44 = *(a1 + 32);
    }
    if ( !v44 )
      goto LABEL_50;
    if ( sub_7FF7053FA4C0(asc_7FF705403B8C, 1uLL, v44) )
      return v6;
    v45 = *(a1 + 32);
    *&v51 = v27;
    if ( !v45 )
      goto LABEL_50;
    if ( sub_7FF7053FC390(&v51, v45) )
      return v6;
    v25 = *(a1 + 32);
    if ( !v25 )
      goto LABEL_50;
    v26 = asc_7FF705403952;
LABEL_48:
    v22 = sub_7FF7053FA4C0(v26, 1uLL, v25);
    goto LABEL_49;
  }
  if ( !(*(&v49 + 1) | *(&v50 + 1)) )
    goto LABEL_50;
  v29 = *(a1 + 32);
  if ( !v29 )
    goto LABEL_50;
  if ( sub_7FF7053FA4C0(word_7FF705403738, 2uLL, v29) )
    return v6;
  v30 = *(a1 + 32);
  if ( !v30 )
  {
LABEL_50:
    if ( *a1 )
      --*(a1 + 24);
    return 0;
  }
  v22 = sub_7FF7053F3E7E(&v49, v30);
LABEL_49:
  if ( !v22 )
    goto LABEL_50;
  return v6;
}
// 7FF705403738: using guessed type unsigned __int16 word_7FF705403738[4];
// 7FF705403952: using guessed type char asc_7FF705403952;
// 7FF705403B71: using guessed type char asc_7FF705403B71;
// 7FF705403B8B: using guessed type char asc_7FF705403B8B;
// 7FF705403B8C: using guessed type char asc_7FF705403B8C;

//----- (00007FF7053F5E83) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F5E83(__int64 a1)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // r14
  char v4; // bl
  __int64 v5; // rax
  unsigned __int64 v6; // rdx
  __int64 *v7; // r8
  unsigned __int16 *v8; // rcx
  __int64 *v10; // r8
  char v11; // al
  char v12; // di
  unsigned int v13; // eax
  __int64 *v14; // r8
  __int64 *v15; // r8
  __int64 *v16; // r8
  __int64 *v17; // r8
  char v18; // al
  __int64 *v19; // r8
  unsigned __int64 v20; // rax
  unsigned __int8 v21; // bl
  __int64 *v22; // r8
  char *v23; // rcx
  unsigned __int64 v24; // rdx
  __int64 *v25; // r8
  __int64 *v26; // r8
  char *v27; // rcx
  unsigned __int64 v28; // rdx
  __int64 *v29; // r8
  unsigned __int64 v30; // rax
  __int64 *v31; // r8
  __int64 v32; // rdx
  __int64 *v33; // r8
  __int64 *v34; // r8
  __int64 *v35; // r8
  __int64 *v36; // r8
  unsigned __int64 v37; // rbx
  __int64 *v38; // r8
  char v39; // [rsp+20h] [rbp-10h] BYREF
  unsigned __int8 v40; // [rsp+21h] [rbp-Fh]
  unsigned __int64 v41; // [rsp+28h] [rbp-8h]

  v2 = *a1;
  if ( !*a1 )
  {
    v7 = *(a1 + 32);
    if ( v7 )
    {
      v8 = asc_7FF705403B71;
      v6 = 1LL;
      return sub_7FF7053FA4C0(v8, v6, v7);
    }
    return 0;
  }
  v3 = *(a1 + 16);
  if ( v3 >= *(a1 + 8) )
  {
    v10 = *(a1 + 32);
    if ( v10 )
    {
      v11 = sub_7FF7053FA4C0(aInvalidSyntax, 0x10uLL, v10);
      v12 = 1;
LABEL_11:
      if ( v11 )
        return v12;
    }
LABEL_12:
    *a1 = 0LL;
    *(a1 + 8) = 0;
    return 0;
  }
  v4 = *(v2 + v3);
  *(a1 + 16) = v3 + 1;
  v5 = sub_7FF7053F43F8(v4);
  if ( v5 )
  {
    v7 = *(a1 + 32);
    if ( v7 )
    {
      v8 = v5;
      return sub_7FF7053FA4C0(v8, v6, v7);
    }
    return 0;
  }
  v13 = *(a1 + 24) + 1;
  *(a1 + 24) = v13;
  if ( v13 < 0x1F5 )
  {
    switch ( v4 )
    {
      case 'A':
      case 'S':
        v15 = *(a1 + 32);
        if ( !v15 || (v12 = 1, !sub_7FF7053FA4C0(asc_7FF705403B7B, 1uLL, v15)) )
        {
          v12 = 1;
          if ( !sub_7FF7053F5E83(a1) )
          {
            if ( v4 != 65
              || ((v16 = *(a1 + 32)) == 0LL || !sub_7FF7053FA4C0(asc_7FF705403B9C, 2uLL, v16))
              && (v12 = 1, !sub_7FF7053F6831(a1, 1)) )
            {
              v17 = *(a1 + 32);
              if ( !v17 )
                goto LABEL_80;
              v18 = sub_7FF7053FA4C0(asc_7FF705403B7C, 1uLL, v17);
              goto LABEL_78;
            }
          }
        }
        return v12;
      case 'B':
        v18 = sub_7FF7053F4ABC(a1);
        goto LABEL_78;
      case 'D':
        v29 = *(a1 + 32);
        if ( v29 )
        {
          v12 = 1;
          if ( sub_7FF7053FA4C0(aDyn, 4uLL, v29) )
            return v12;
        }
        v12 = 1;
        if ( sub_7FF7053F4F8D(a1) )
          return v12;
        if ( !*a1 || (v30 = *(a1 + 16), v30 >= *(a1 + 8)) || *(*a1 + v30) != 76 )
        {
          v35 = *(a1 + 32);
          if ( !v35 )
            goto LABEL_12;
          v11 = sub_7FF7053FA4C0(aInvalidSyntax, 0x10uLL, v35);
          goto LABEL_11;
        }
        *(a1 + 16) = v30 + 1;
        sub_7FF7053F44CD(&v39, a1);
        if ( v39 )
        {
          v21 = v40;
          v22 = *(a1 + 32);
          if ( !v22 )
            goto LABEL_40;
          v24 = 9LL * v40 + 16;
          v23 = aInvalidSyntax;
          if ( v40 )
            v23 = aRecursionLimit;
          goto LABEL_39;
        }
        v37 = v41;
        if ( !v41 )
          goto LABEL_80;
        v38 = *(a1 + 32);
        if ( !v38 || !sub_7FF7053FA4C0(asc_7FF705403BA2, 3uLL, v38) )
        {
          v18 = sub_7FF7053F4D40(a1, v37);
          goto LABEL_79;
        }
        return v12;
      case 'F':
        v18 = sub_7FF7053F4E23(a1);
        goto LABEL_78;
      case 'O':
      case 'P':
        v25 = *(a1 + 32);
        if ( v25 )
        {
          v12 = 1;
          if ( sub_7FF7053FA4C0(&unk_7FF7054037F6, 1uLL, v25) )
            return v12;
        }
        if ( v4 != 80 )
          goto LABEL_74;
        v26 = *(a1 + 32);
        if ( !v26 )
          goto LABEL_77;
        v27 = aConst;
        v28 = 6LL;
        goto LABEL_76;
      case 'Q':
      case 'R':
        v19 = *(a1 + 32);
        if ( !v19 )
          goto LABEL_32;
        v12 = 1;
        if ( sub_7FF7053FA4C0(&unk_7FF7054037F5, 1uLL, v19) )
          return v12;
        v2 = *a1;
        if ( !*a1 )
          goto LABEL_73;
LABEL_32:
        v20 = *(a1 + 16);
        if ( v20 >= *(a1 + 8) || *(v2 + v20) != 76 )
          goto LABEL_73;
        *(a1 + 16) = v20 + 1;
        sub_7FF7053F44CD(&v39, a1);
        if ( v39 )
        {
          v21 = v40;
          v22 = *(a1 + 32);
          if ( !v22 )
            goto LABEL_40;
          v23 = aInvalidSyntax;
          if ( v40 )
            v23 = aRecursionLimit;
          v24 = 9LL * v40 + 16;
LABEL_39:
          v12 = 1;
          if ( !sub_7FF7053FA4C0(v23, v24, v22) )
          {
LABEL_40:
            *a1 = 0LL;
            *(a1 + 8) = v21;
            return 0;
          }
        }
        else
        {
          if ( v41 )
          {
            v12 = 1;
            if ( sub_7FF7053F4D40(a1, v41) )
              return v12;
            v36 = *(a1 + 32);
            if ( v36 )
            {
              if ( sub_7FF7053FA4C0(asc_7FF705403B91, 1uLL, v36) )
                return v12;
            }
          }
LABEL_73:
          if ( v4 != 82 )
          {
LABEL_74:
            v26 = *(a1 + 32);
            if ( v26 )
            {
              v27 = aMut;
              v28 = 4LL;
LABEL_76:
              v12 = 1;
              if ( sub_7FF7053FA4C0(v27, v28, v26) )
                return v12;
            }
          }
LABEL_77:
          v18 = sub_7FF7053F5E83(a1);
LABEL_78:
          v12 = 1;
LABEL_79:
          if ( !v18 )
          {
LABEL_80:
            if ( *a1 )
              --*(a1 + 24);
            return 0;
          }
        }
        break;
      case 'T':
        v31 = *(a1 + 32);
        if ( v31 )
        {
          v12 = 1;
          if ( sub_7FF7053FA4C0(&unk_7FF7054037F2, 1uLL, v31) )
            return v12;
        }
        v12 = 1;
        if ( (sub_7FF7053F5218(a1) & 1) != 0 )
          return v12;
        if ( v32 != 1 )
          goto LABEL_64;
        v33 = *(a1 + 32);
        if ( !v33 )
          goto LABEL_80;
        if ( sub_7FF7053FA4C0(&unk_7FF7054037F0, 1uLL, v33) )
          return v12;
LABEL_64:
        v34 = *(a1 + 32);
        if ( !v34 )
          goto LABEL_80;
        v18 = sub_7FF7053FA4C0(&unk_7FF7054037F1, 1uLL, v34);
        goto LABEL_79;
      default:
        *(a1 + 16) = v3;
        v18 = sub_7FF7053F57DE(a1, 0LL);
        goto LABEL_78;
    }
    return v12;
  }
  v14 = *(a1 + 32);
  if ( !v14 || (v12 = 1, !sub_7FF7053FA4C0(aRecursionLimit, 0x19uLL, v14)) )
  {
    *a1 = 0LL;
    *(a1 + 8) = 1;
    return 0;
  }
  return v12;
}
// 7FF7053F5EEC: variable 'v6' is possibly undefined
// 7FF7053F6228: variable 'v32' is possibly undefined
// 7FF7053F57DE: using guessed type __int64 __fastcall sub_7FF7053F57DE(_QWORD, _QWORD);
// 7FF705403B71: using guessed type char asc_7FF705403B71;
// 7FF705403B7B: using guessed type char asc_7FF705403B7B;
// 7FF705403B7C: using guessed type char asc_7FF705403B7C;
// 7FF705403B91: using guessed type char asc_7FF705403B91;

//----- (00007FF7053F6368) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F6368(__int64 *a1)
{
  __int64 *v1; // rsi
  __int64 v2; // r15
  __int64 v4; // rcx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rax
  char v7; // r14
  void *v8; // rdi
  __int64 *v9; // r8
  __int64 *v10; // r14
  unsigned __int16 *v11; // rax
  unsigned __int64 v12; // rdx
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  unsigned __int16 *v15; // r12
  unsigned __int64 v16; // r13
  __int64 *v17; // r15
  unsigned __int64 v18; // rdx
  char v19; // di
  __int64 *v20; // r8
  char *v21; // rcx
  __int64 *v22; // r8
  __int64 *v23; // r8
  __int64 *v24; // r8
  unsigned __int64 v25; // rax
  __int64 *v26; // r8
  _QWORD v28[9]; // [rsp+28h] [rbp-58h] BYREF
  __int64 v29[16]; // [rsp+70h] [rbp-10h] BYREF

  v4 = *a1;
  if ( !v4 )
    goto LABEL_49;
  v5 = a1[1];
  v6 = a1[2];
  if ( v6 < v5 && *(v4 + v6) == 85 )
  {
    a1[2] = ++v6;
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  if ( v6 >= v5 || *(v4 + v6) != 75 )
  {
    if ( !v7 )
      goto LABEL_49;
    v8 = 0LL;
LABEL_13:
    v9 = a1[4];
    if ( v9 )
    {
      LOBYTE(v1) = 1;
      if ( sub_7FF7053FA4C0(aUnsafe, 7uLL, v9) )
        return v1;
    }
    if ( !v8 )
      goto LABEL_49;
    goto LABEL_21;
  }
  a1[2] = v6 + 1;
  if ( v6 + 1 < v5 && *(v4 + v6 + 1) == 67 )
  {
    a1[2] = v6 + 2;
    v2 = 1LL;
    v8 = &unk_7FF7054037D0;
  }
  else
  {
    v1 = v29;
    sub_7FF7053F46AD(v29, a1);
    v8 = v29[0];
    if ( !v29[0] )
    {
      v19 = v29[1];
      v20 = a1[4];
      if ( v20 )
      {
        v21 = aInvalidSyntax;
        if ( LOBYTE(v29[1]) )
          v21 = aRecursionLimit;
        LOBYTE(v1) = 1;
        if ( sub_7FF7053FA4C0(v21, 9LL * LOBYTE(v29[1]) + 16, v20) )
          return v1;
      }
      *a1 = 0LL;
      *(a1 + 8) = v19;
      goto LABEL_58;
    }
    v2 = v29[1];
    if ( !v29[1] || v29[3] )
    {
      v22 = a1[4];
      if ( v22 )
      {
        LOBYTE(v1) = 1;
        if ( sub_7FF7053FA4C0(aInvalidSyntax, 0x10uLL, v22) )
          return v1;
      }
      *a1 = 0LL;
      *(a1 + 8) = 0;
      goto LABEL_58;
    }
  }
  if ( v7 )
    goto LABEL_13;
LABEL_21:
  v10 = a1[4];
  if ( v10 )
  {
    LOBYTE(v1) = 1;
    if ( sub_7FF7053FA4C0(aExtern, 8uLL, a1[4]) )
      return v1;
  }
  v28[0] = 0LL;
  v28[1] = v2;
  v28[2] = v8;
  v28[3] = v2;
  v28[4] = 0LL;
  v28[5] = v2;
  v28[6] = 0x5F0000005FLL;
  LOBYTE(v28[7]) = 1;
  LOWORD(v28[8]) = 1;
  v11 = sub_7FF7053F2D95(v28);
  if ( !v11 )
    sub_7FF7053FE090(&off_7FF705403BB8);
  if ( v10 && sub_7FF7053FA4C0(v11, v12, v10) )
    goto LABEL_48;
  qmemcpy(v29, v28, 0x48uLL);
  v1 = v29;
  v13 = sub_7FF7053F2D95(v29);
  if ( v13 )
  {
    v15 = v13;
    v16 = v14;
    v1 = v29;
    v17 = v10;
    while ( 1 )
    {
      if ( v10 )
      {
        if ( sub_7FF7053FA4C0(asc_7FF705403951, 1uLL, v10) )
          goto LABEL_48;
        v17 = a1[4];
        if ( v17 )
        {
          v10 = a1[4];
          if ( sub_7FF7053FA4C0(v15, v16, v10) )
            goto LABEL_48;
          goto LABEL_35;
        }
        v17 = 0LL;
      }
      v10 = 0LL;
LABEL_35:
      v15 = sub_7FF7053F2D95(v29);
      v16 = v18;
      if ( !v15 )
        goto LABEL_46;
    }
  }
  v17 = v10;
LABEL_46:
  if ( v17 && sub_7FF7053FA4C0(asc_7FF705403BD0, 2uLL, v17) )
  {
LABEL_48:
    LOBYTE(v1) = 1;
    return v1;
  }
LABEL_49:
  v23 = a1[4];
  if ( v23 )
  {
    LOBYTE(v1) = 1;
    if ( sub_7FF7053FA4C0(aFn, 3uLL, v23) )
      return v1;
  }
  LOBYTE(v1) = 1;
  if ( (sub_7FF7053F5218(a1) & 1) != 0 )
    return v1;
  v24 = a1[4];
  if ( v24 )
  {
    if ( sub_7FF7053FA4C0(&unk_7FF7054037F1, 1uLL, v24) )
      return v1;
  }
  if ( *a1 )
  {
    v25 = a1[2];
    if ( v25 < a1[1] && *(*a1 + v25) == 117 )
    {
      a1[2] = v25 + 1;
LABEL_58:
      LODWORD(v1) = 0;
      return v1;
    }
  }
  v26 = a1[4];
  if ( v26 && sub_7FF7053FA4C0(asc_7FF705403BD5, 4uLL, v26) )
    return v1;
  return sub_7FF7053F5E83(a1);
}
// 7FF7053F648D: variable 'v2' is possibly undefined
// 7FF7053F64D2: variable 'v12' is possibly undefined
// 7FF7053F6506: variable 'v14' is possibly undefined
// 7FF7053F6569: variable 'v18' is possibly undefined
// 7FF7053F66B1: variable 'v1' is possibly undefined
// 7FF7053F5E83: using guessed type __int64 __fastcall sub_7FF7053F5E83(_QWORD);
// 7FF705403951: using guessed type char asc_7FF705403951;
// 7FF705403BB8: using guessed type char *off_7FF705403BB8;

//----- (00007FF7053F66EF) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F66EF(_QWORD *a1)
{
  __int128 *v1; // rdi
  __int64 v3; // rcx
  unsigned __int64 v4; // rax
  __int128 v5; // xmm1
  __int64 result; // rax
  __int64 *v7; // r8
  __int64 *v8; // r8
  char *v9; // rcx
  __int128 v10; // xmm0
  __int128 v11; // [rsp+20h] [rbp-40h]
  __int128 v12; // [rsp+30h] [rbp-30h]
  __int128 v13; // [rsp+40h] [rbp-20h] BYREF
  __int128 v14; // [rsp+50h] [rbp-10h]

  v3 = *a1;
  if ( !v3 || (v4 = a1[2], v4 >= a1[1]) )
  {
LABEL_12:
    LODWORD(v1) = sub_7FF7053F57DE(a1, 0LL);
    LOBYTE(v1) = 2 * v1;
    return v1;
  }
  if ( *(v3 + v4) != 66 )
  {
    if ( *(v3 + v4) == 73 )
    {
      a1[2] = v4 + 1;
      LOBYTE(v1) = 2;
      if ( !sub_7FF7053F57DE(a1, 0LL) )
      {
        v7 = a1[4];
        if ( !v7 || !sub_7FF7053FA4C0(&unk_7FF7054037F4, 1uLL, v7) )
        {
          LODWORD(v1) = sub_7FF7053F52AA(a1);
          LOBYTE(v1) = v1 + 1;
        }
      }
      return v1;
    }
    goto LABEL_12;
  }
  a1[2] = v4 + 1;
  v1 = &v13;
  sub_7FF7053F4634(&v13, a1);
  if ( v13 )
  {
    if ( a1[4] )
    {
      v12 = *(a1 + 1);
      v11 = *a1;
      v5 = v14;
      *a1 = v13;
      *(a1 + 1) = v5;
      result = sub_7FF7053F66EF(a1);
      *a1 = v11;
      *(a1 + 1) = v12;
      return result;
    }
    goto LABEL_20;
  }
  v8 = a1[4];
  if ( !v8 )
    goto LABEL_19;
  v9 = aInvalidSyntax;
  if ( BYTE8(v13) )
    v9 = aRecursionLimit;
  if ( !sub_7FF7053FA4C0(v9, 9LL * BYTE8(v13) + 16, v8) )
  {
LABEL_19:
    v10 = v13;
    *(a1 + 1) = v14;
    *a1 = v10;
LABEL_20:
    LODWORD(v1) = 0;
    return v1;
  }
  LOBYTE(v1) = 2;
  return v1;
}
// 7FF7053F67DB: variable 'v1' is possibly undefined
// 7FF7053F52AA: using guessed type __int64 __fastcall sub_7FF7053F52AA(_QWORD);
// 7FF7053F57DE: using guessed type __int64 __fastcall sub_7FF7053F57DE(_QWORD, _QWORD);

//----- (00007FF7053F6831) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F6831(__int64 a1, char a2)
{
  __int64 v3; // rcx
  unsigned __int64 v4; // r8
  unsigned __int64 v5; // rax
  char v7; // r14
  unsigned __int64 v8; // rdx
  unsigned int v9; // r9d
  __int64 *v10; // r8
  char v11; // di
  __int64 *v12; // r8
  char v13; // al
  __int64 v14; // rdx
  __int64 *v15; // r8
  char *v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 *v18; // r8
  __int64 *v19; // r8
  __int64 *v20; // r8
  char v21; // al
  char v22; // al
  unsigned __int64 v23; // rdx
  signed int v24; // ecx
  char v25; // r8
  unsigned int v26; // eax
  signed int v27; // edx
  __int64 *v28; // r8
  char v29; // al
  __int64 *v30; // r8
  __int64 *v31; // r8
  __int64 v32; // rdx
  __int64 *v33; // r8
  __int64 *v34; // r8
  char *v35; // rcx
  __int64 *v36; // r8
  __int64 v37; // rdx
  unsigned __int64 v38; // rcx
  int v39; // eax
  __int64 *v40; // r8
  __int64 *v41; // r8
  __int64 *v43; // r8
  __int64 *v44; // r8
  __int64 *v45; // r8
  __int64 *v46; // r8
  unsigned __int64 v47; // rdx
  char v48; // bl
  __int64 *v49; // r8
  char *v50; // rcx
  __int64 *v51; // r8
  __int64 *v52; // r8
  __int64 v53; // [rsp+28h] [rbp-28h] BYREF
  __int64 v54; // [rsp+30h] [rbp-20h]
  __int64 v55; // [rsp+38h] [rbp-18h] BYREF
  __int64 v56; // [rsp+40h] [rbp-10h]
  char v57[33]; // [rsp+4Fh] [rbp-1h] BYREF

  v57[0] = a2;
  v3 = *a1;
  if ( !v3 )
  {
LABEL_71:
    v41 = *(a1 + 32);
    if ( v41 )
      return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v41);
    return 0;
  }
  v4 = *(a1 + 8);
  v5 = *(a1 + 16);
  if ( v5 >= v4 )
  {
LABEL_45:
    v28 = *(a1 + 32);
    if ( v28 )
    {
      v29 = sub_7FF7053FA4C0(aInvalidSyntax, 0x10uLL, v28);
      v11 = 1;
LABEL_47:
      if ( v29 )
        return v11;
    }
LABEL_48:
    *a1 = 0LL;
    *(a1 + 8) = 0;
    return 0;
  }
  v7 = *(v3 + v5);
  v8 = v5 + 1;
  *(a1 + 16) = v5 + 1;
  v9 = *(a1 + 24) + 1;
  *(a1 + 24) = v9;
  if ( v9 < 0x1F5 )
  {
    switch ( v7 )
    {
      case 'Q':
        goto LABEL_30;
      case 'R':
        if ( v8 < v4 && *(v3 + v8) == 101 )
        {
          *(a1 + 16) = v5 + 2;
          v13 = sub_7FF7053F6FD6(a1);
          goto LABEL_13;
        }
LABEL_30:
        if ( !a2 )
        {
          v18 = *(a1 + 32);
          if ( v18 )
          {
            v11 = 1;
            if ( sub_7FF7053FA4C0(asc_7FF705403BE5, 1uLL, v18) )
              return v11;
          }
        }
        v19 = *(a1 + 32);
        if ( v19 )
        {
          v11 = 1;
          if ( sub_7FF7053FA4C0(&unk_7FF7054037F5, 1uLL, v19) )
            return v11;
        }
        if ( v7 != 82 )
        {
          v20 = *(a1 + 32);
          if ( v20 )
          {
            v11 = 1;
            if ( sub_7FF7053FA4C0(aMut, 4uLL, v20) )
              return v11;
          }
        }
        v11 = 1;
        LOBYTE(v8) = 1;
        v21 = sub_7FF7053F6831(a1, v8);
        goto LABEL_89;
      case 'S':
      case 'U':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '[':
      case '\\':
      case ']':
      case '^':
      case '_':
      case '`':
      case 'd':
      case 'f':
      case 'g':
      case 'k':
      case 'q':
      case 'r':
      case 'u':
      case 'v':
      case 'w':
        goto LABEL_45;
      case 'T':
        if ( !a2 )
        {
          v30 = *(a1 + 32);
          if ( v30 )
          {
            v11 = 1;
            if ( sub_7FF7053FA4C0(asc_7FF705403BE5, 1uLL, v30) )
              return v11;
          }
        }
        v31 = *(a1 + 32);
        if ( v31 )
        {
          v11 = 1;
          if ( sub_7FF7053FA4C0(&unk_7FF7054037F2, 1uLL, v31) )
            return v11;
        }
        v11 = 1;
        if ( (sub_7FF7053F50F8(a1, v8) & 1) != 0 )
          return v11;
        if ( v32 != 1 )
          goto LABEL_58;
        v33 = *(a1 + 32);
        if ( !v33 )
          goto LABEL_90;
        if ( !sub_7FF7053FA4C0(&unk_7FF7054037F0, 1uLL, v33) )
          goto LABEL_58;
        return v11;
      case 'V':
        if ( !a2 )
        {
          v36 = *(a1 + 32);
          if ( v36 )
          {
            v11 = 1;
            if ( sub_7FF7053FA4C0(asc_7FF705403BE5, 1uLL, v36) )
              return v11;
          }
        }
        v11 = 1;
        LOBYTE(v8) = 1;
        if ( sub_7FF7053F57DE(a1, v8) )
          return v11;
        if ( !*a1 )
          goto LABEL_71;
        v38 = *(a1 + 16);
        if ( v38 >= *(a1 + 8) )
          goto LABEL_69;
        v39 = *(*a1 + v38);
        *(a1 + 16) = v38 + 1;
        if ( v39 == 83 )
        {
          v52 = *(a1 + 32);
          if ( v52 && sub_7FF7053FA4C0(asc_7FF705403BE6, 3uLL, v52) || (sub_7FF7053F53E3(a1) & 1) != 0 )
            return v11;
          v34 = *(a1 + 32);
          if ( !v34 )
            goto LABEL_90;
          v35 = asc_7FF705403BE9;
          v47 = 2LL;
          goto LABEL_88;
        }
        if ( v39 != 84 )
        {
          if ( v39 == 85 )
            goto LABEL_90;
LABEL_69:
          v40 = *(a1 + 32);
          if ( v40 )
          {
            v29 = sub_7FF7053FA4C0(aInvalidSyntax, 0x10uLL, v40);
            goto LABEL_47;
          }
          goto LABEL_48;
        }
        v51 = *(a1 + 32);
        if ( v51 && sub_7FF7053FA4C0(&unk_7FF7054037F2, 1uLL, v51) || (sub_7FF7053F518C(a1, v37) & 1) != 0 )
          return v11;
LABEL_58:
        v34 = *(a1 + 32);
        if ( !v34 )
          goto LABEL_90;
        v35 = &unk_7FF7054037F1;
        goto LABEL_87;
      case 'a':
      case 'i':
      case 'l':
      case 'n':
      case 's':
      case 'x':
        if ( v8 < v4 && *(v3 + v8) == 110 )
        {
          *(a1 + 16) = v5 + 2;
          v12 = *(a1 + 32);
          if ( v12 )
          {
            v11 = 1;
            if ( sub_7FF7053FA4C0(asc_7FF705403951, 1uLL, v12) )
              return v11;
          }
        }
        goto LABEL_12;
      case 'b':
        sub_7FF7053F4420(&v55, a1);
        if ( !v55 )
          goto LABEL_95;
        v53 = v55;
        v54 = v56;
        if ( (sub_7FF7053F42E7(&v53) & 1) == 0 )
          goto LABEL_45;
        if ( v14 )
        {
          if ( v14 != 1 )
            goto LABEL_45;
          v15 = *(a1 + 32);
          if ( v15 )
          {
            v16 = aTrue;
            v17 = 4LL;
            goto LABEL_94;
          }
          goto LABEL_14;
        }
        v15 = *(a1 + 32);
        if ( !v15 )
          goto LABEL_14;
        v16 = aFalse;
        v17 = 5LL;
        goto LABEL_94;
      case 'c':
        sub_7FF7053F4420(&v55, a1);
        if ( v55 )
        {
          v53 = v55;
          v54 = v56;
          v22 = sub_7FF7053F42E7(&v53);
          v24 = v23;
          v25 = v22 & (HIDWORD(v23) == 0);
          v26 = (v23 ^ 0xD800) - 1114112;
          v27 = 1114112;
          if ( v26 >= 0xFFEF0800 )
            v27 = v24;
          if ( v25 == 1 && v27 != 1114112 )
          {
            v13 = sub_7FF7053F4B9A(a1, v27);
            goto LABEL_13;
          }
          goto LABEL_45;
        }
LABEL_95:
        v48 = v56;
        v49 = *(a1 + 32);
        if ( !v49 )
          goto LABEL_99;
        v50 = aInvalidSyntax;
        if ( v56 )
          v50 = aRecursionLimit;
        v11 = 1;
        if ( !sub_7FF7053FA4C0(v50, 9LL * v56 + 16, v49) )
        {
LABEL_99:
          *a1 = 0LL;
          *(a1 + 8) = v48;
          return 0;
        }
        return v11;
      case 'e':
        if ( !a2 )
        {
          v43 = *(a1 + 32);
          if ( v43 )
          {
            v11 = 1;
            if ( sub_7FF7053FA4C0(asc_7FF705403BE5, 1uLL, v43) )
              return v11;
          }
        }
        v44 = *(a1 + 32);
        if ( v44 )
        {
          v11 = 1;
          if ( sub_7FF7053FA4C0(&unk_7FF7054037F6, 1uLL, v44) )
            return v11;
        }
        v21 = sub_7FF7053F6FD6(a1);
        v11 = 1;
        goto LABEL_89;
      case 'h':
      case 'j':
      case 'm':
      case 'o':
      case 't':
      case 'y':
LABEL_12:
        v13 = sub_7FF7053F6E80(a1, v7);
        goto LABEL_13;
      case 'p':
        v15 = *(a1 + 32);
        if ( !v15 )
          goto LABEL_14;
        v16 = asc_7FF705403ACA;
        goto LABEL_93;
      default:
        if ( v7 == 65 )
        {
          if ( !a2 )
          {
            v45 = *(a1 + 32);
            if ( v45 )
            {
              v11 = 1;
              if ( sub_7FF7053FA4C0(asc_7FF705403BE5, 1uLL, v45) )
                return v11;
            }
          }
          v46 = *(a1 + 32);
          if ( v46 )
          {
            v11 = 1;
            if ( sub_7FF7053FA4C0(asc_7FF705403B7B, 1uLL, v46) )
              return v11;
          }
          v11 = 1;
          if ( (sub_7FF7053F518C(a1, v8) & 1) != 0 )
            return v11;
          v34 = *(a1 + 32);
          if ( v34 )
          {
            v35 = asc_7FF705403B7C;
LABEL_87:
            v47 = 1LL;
LABEL_88:
            v21 = sub_7FF7053FA4C0(v35, v47, v34);
LABEL_89:
            if ( v21 )
              return v11;
          }
LABEL_90:
          if ( a2 || (v15 = *(a1 + 32)) == 0LL )
          {
LABEL_14:
            if ( *a1 )
              --*(a1 + 24);
            return 0;
          }
          v16 = asc_7FF705403952;
LABEL_93:
          v17 = 1LL;
LABEL_94:
          v13 = sub_7FF7053FA4C0(v16, v17, v15);
        }
        else
        {
          if ( v7 != 66 )
            goto LABEL_45;
          v13 = sub_7FF7053F48F0(a1, v57);
        }
LABEL_13:
        v11 = 1;
        if ( v13 )
          return v11;
        goto LABEL_14;
    }
  }
  v10 = *(a1 + 32);
  if ( v10 )
  {
    v11 = 1;
    if ( sub_7FF7053FA4C0(aRecursionLimit, 0x19uLL, v10) )
      return v11;
  }
  *a1 = 0LL;
  *(a1 + 8) = 1;
  return 0;
}
// 7FF7053F6995: variable 'v14' is possibly undefined
// 7FF7053F6A7D: variable 'v8' is possibly undefined
// 7FF7053F6AB6: variable 'v23' is possibly undefined
// 7FF7053F6B92: variable 'v32' is possibly undefined
// 7FF7053F6E25: variable 'v37' is possibly undefined
// 7FF7053F57DE: using guessed type __int64 __fastcall sub_7FF7053F57DE(_QWORD, _QWORD);
// 7FF705403951: using guessed type char asc_7FF705403951;
// 7FF705403952: using guessed type char asc_7FF705403952;
// 7FF705403ACA: using guessed type char asc_7FF705403ACA;
// 7FF705403B71: using guessed type char asc_7FF705403B71;
// 7FF705403B7B: using guessed type char asc_7FF705403B7B;
// 7FF705403B7C: using guessed type char asc_7FF705403B7C;
// 7FF705403BE5: using guessed type char asc_7FF705403BE5;

//----- (00007FF7053F6E80) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F6E80(__int64 a1, char a2)
{
  unsigned __int16 *v4; // r14
  unsigned __int64 v5; // r15
  __int64 v6; // rdx
  __int64 v7; // rsi
  char v8; // al
  char v9; // di
  __int64 *v10; // r8
  char v12; // bl
  __int64 *v13; // r8
  char *v14; // rcx
  unsigned __int16 *v15; // rax
  unsigned __int64 v16; // rdx
  __int64 v17[2]; // [rsp+28h] [rbp-18h] BYREF
  __int64 v18; // [rsp+38h] [rbp-8h] BYREF
  __int64 v19; // [rsp+40h] [rbp+0h]

  if ( !*a1 )
  {
    v10 = *(a1 + 32);
    if ( v10 )
      return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v10);
    return 0;
  }
  sub_7FF7053F4420(&v18, a1);
  v4 = v18;
  if ( !v18 )
  {
    v12 = v19;
    v13 = *(a1 + 32);
    if ( v13 )
    {
      v14 = aInvalidSyntax;
      if ( v19 )
        v14 = aRecursionLimit;
      v9 = 1;
      if ( sub_7FF7053FA4C0(v14, 9LL * v19 + 16, v13) )
        return v9;
    }
    *a1 = 0LL;
    *(a1 + 8) = v12;
    return 0;
  }
  v5 = v19;
  v17[0] = v18;
  v17[1] = v19;
  if ( (sub_7FF7053F42E7(v17) & 1) != 0 )
  {
    v18 = v6;
    v7 = *(a1 + 32);
    if ( v7 )
    {
      v8 = sub_7FF7053FC390(&v18, v7);
      v9 = 1;
      goto LABEL_16;
    }
    return 0;
  }
  v7 = *(a1 + 32);
  if ( !v7 )
    return 0;
  v9 = 1;
  if ( sub_7FF7053FA4C0(a0x, 2uLL, v7) )
    return v9;
  v8 = sub_7FF7053FA4C0(v4, v5, v7);
LABEL_16:
  if ( !v8 )
  {
    if ( *(v7 + 18) >= 0 )
    {
      v15 = sub_7FF7053F43F8(a2);
      if ( !v15 )
        sub_7FF7053FE090(&off_7FF705403BF0);
      return sub_7FF7053FA4C0(v15, v16, v7);
    }
    return 0;
  }
  return v9;
}
// 7FF7053F6ECF: variable 'v6' is possibly undefined
// 7FF7053F6FAF: variable 'v16' is possibly undefined
// 7FF705403B71: using guessed type char asc_7FF705403B71;
// 7FF705403BF0: using guessed type char *off_7FF705403BF0;

//----- (00007FF7053F6FD6) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F6FD6(__int64 a1)
{
  unsigned __int8 *v2; // rbx
  __int64 v3; // r14
  unsigned int v4; // eax
  _QWORD *v5; // rdi
  char v6; // si
  signed int v7; // eax
  __int64 *v8; // r8
  __int64 *v10; // r8
  char v11; // bl
  __int64 *v12; // r8
  char *v13; // rcx
  signed int v14; // r15d
  unsigned __int8 v15; // r15
  unsigned __int8 v16; // al
  unsigned __int64 i; // r13
  unsigned __int8 *v18; // [rsp+30h] [rbp-40h] BYREF
  __int64 v19; // [rsp+38h] [rbp-38h]
  unsigned __int8 *v20; // [rsp+40h] [rbp-30h]
  __int64 v21; // [rsp+48h] [rbp-28h]
  __int64 v22; // [rsp+50h] [rbp-20h]
  _TBYTE v23; // [rsp+58h] [rbp-18h] BYREF
  unsigned __int8 v24; // [rsp+62h] [rbp-Eh]
  unsigned __int8 v25; // [rsp+63h] [rbp-Dh]
  _TBYTE v26; // [rsp+68h] [rbp-8h]

  if ( !*a1 )
  {
    v8 = *(a1 + 32);
    if ( v8 )
      return sub_7FF7053FA4C0(asc_7FF705403B71, 1uLL, v8);
    return 0;
  }
  sub_7FF7053F4420(&v18, a1);
  v2 = v18;
  if ( !v18 )
  {
    v11 = v19;
    v12 = *(a1 + 32);
    if ( v12 )
    {
      v13 = aInvalidSyntax;
      if ( v19 )
        v13 = aRecursionLimit;
      v6 = 1;
      if ( sub_7FF7053FA4C0(v13, 9LL * v19 + 16, v12) )
        return v6;
    }
    *a1 = 0LL;
    *(a1 + 8) = v11;
    return 0;
  }
  v3 = v19;
  if ( (v19 & 1) != 0 )
    goto LABEL_13;
  v20 = &v18[v19];
  v21 = 0LL;
  v22 = 2LL;
  do
    v4 = sub_7FF7053F2854(&v18);
  while ( v4 < 0x110000 );
  if ( v4 != 1114113 )
  {
LABEL_13:
    v10 = *(a1 + 32);
    if ( v10 )
    {
      v6 = 1;
      if ( sub_7FF7053FA4C0(aInvalidSyntax, 0x10uLL, v10) )
        return v6;
    }
    *a1 = 0LL;
    *(a1 + 8) = 0;
    return 0;
  }
  v5 = *(a1 + 32);
  if ( !v5 )
    return 0;
  v6 = 1;
  if ( !sub_7FF7053FA100(v5) )
  {
    v18 = v2;
    v19 = v3;
    v20 = &v2[v3];
    v21 = 0LL;
    v22 = 2LL;
    v7 = sub_7FF7053F2854(&v18);
    if ( v7 == 1114113 )
      return sub_7FF7053FA100(v5);
    v14 = v7;
    while ( 1 )
    {
      if ( v14 == 1114112 )
        sub_7FF7053FE440(aCalledResultUn_0, 43LL, &v23, &unk_7FF7054034E0, &off_7FF7054033E0);
      if ( v14 == 39 )
      {
        if ( sub_7FF7053FA100(v5) )
          return v6;
        goto LABEL_27;
      }
      if ( v14 > 12 )
      {
        switch ( v14 )
        {
          case 13:
            LOWORD(v26) = 29276;
            goto LABEL_46;
          case 34:
            LOWORD(v26) = 8796;
            goto LABEL_46;
          case 92:
            LOWORD(v26) = 23644;
            goto LABEL_46;
        }
      }
      else
      {
        switch ( v14 )
        {
          case 0:
            LOWORD(v26) = 12380;
            goto LABEL_46;
          case 9:
            LOWORD(v26) = 29788;
            goto LABEL_46;
          case 10:
            LOWORD(v26) = 28252;
LABEL_46:
            *(&v26 + 2) = 0LL;
            v15 = 2;
            v16 = 0;
            goto LABEL_47;
        }
      }
      if ( v14 > 0x2FF && sub_7FF7053FC600(v14) || !sub_7FF7053FBC50(v14) )
      {
        sub_7FF7053F2EBF(&v23, v14);
        v26 = v23;
        v16 = v24;
        v15 = v25;
      }
      else
      {
        LODWORD(v26) = v14;
        v15 = -127;
        v16 = 0x80;
      }
LABEL_47:
      v23 = v26;
      for ( i = v16; i < v15; ++i )
      {
        if ( sub_7FF7053FA100(v5) )
          return v6;
      }
LABEL_27:
      v14 = sub_7FF7053F2854(&v18);
      if ( v14 == 1114113 )
        return sub_7FF7053FA100(v5);
    }
  }
  return v6;
}
// 7FF7054033E0: using guessed type char *off_7FF7054033E0;
// 7FF705403B71: using guessed type char asc_7FF705403B71;

//----- (00007FF7053F72D8) ----------------------------------------------------
__int64 *__fastcall sub_7FF7053F72D8(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r12
  unsigned __int64 v4; // r13
  _BYTE *v5; // rdi
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // r11
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r10
  unsigned __int64 v12; // rbx
  bool v13; // zf
  unsigned __int64 v14; // rcx
  __int64 v15; // r10
  unsigned __int64 v16; // rcx
  __int64 v17; // r9
  __int64 v18; // rcx
  char *v19; // r10
  unsigned __int64 v20; // r9
  char v21; // di
  unsigned __int64 v22; // rbx
  unsigned __int64 v23; // rsi
  unsigned __int64 v24; // r8
  char **v25; // rax
  unsigned __int8 *v26; // r8
  int v27; // ecx
  int v28; // edx
  int v29; // r11d
  int v30; // r10d
  __int64 v31; // r15
  __int64 v32; // r14
  unsigned __int64 v33; // rdx
  unsigned __int64 v34; // r14
  unsigned __int8 *v35; // r8
  unsigned __int8 *v36; // r11
  __int64 v37; // rax
  bool v38; // sf
  int v39; // edx
  int v40; // eax
  int v41; // r10d
  int v42; // edx
  char v43; // al
  __int64 v44; // rax
  _BYTE *v45; // rcx
  int v46; // edx
  unsigned __int64 v47; // r8
  unsigned __int64 v48; // r11
  __int64 v49; // r9
  _BYTE *v50; // rcx
  __int64 *result; // rax
  unsigned __int64 v52; // r11
  unsigned __int64 v53; // rax
  unsigned int v54; // r10d
  __int64 v55; // rax
  unsigned __int64 v56; // kr00_8
  bool v57; // cf
  unsigned __int8 *v58; // r9
  int v59; // r10d
  int v60; // ebx
  int v61; // edx
  char v62; // r11
  unsigned __int64 v63; // r9
  int v64; // r10d
  int v65; // r13d
  unsigned __int8 *v66; // rsi
  int v67; // r11d
  _BYTE *v68; // rcx
  _BYTE *v69; // rcx
  _BYTE *i; // r10
  unsigned __int64 v71; // rax
  int v72; // r13d
  int v73; // esi
  int v74; // edx
  unsigned __int64 v75; // rdx
  __int64 v76; // rax
  unsigned __int64 v77; // rcx
  unsigned __int64 v78; // rsi
  _QWORD v79[3]; // [rsp+28h] [rbp-58h] BYREF
  __int64 *v80; // [rsp+40h] [rbp-40h]
  __int64 v81; // [rsp+48h] [rbp-38h]
  _BYTE *v82; // [rsp+50h] [rbp-30h] BYREF
  unsigned __int64 v83; // [rsp+58h] [rbp-28h]
  unsigned __int64 v84; // [rsp+60h] [rbp-20h]
  __int64 v85; // [rsp+68h] [rbp-18h]
  __int64 v86; // [rsp+70h] [rbp-10h]
  unsigned __int64 v87; // [rsp+78h] [rbp-8h]
  unsigned __int64 v88; // [rsp+88h] [rbp+8h]
  __int64 v89; // [rsp+98h] [rbp+18h]
  unsigned __int64 v90; // [rsp+A0h] [rbp+20h]
  __int64 v91; // [rsp+A8h] [rbp+28h]
  unsigned __int64 v92; // [rsp+B0h] [rbp+30h]
  __int64 v93; // [rsp+B8h] [rbp+38h]
  char *v94; // [rsp+C0h] [rbp+40h]
  unsigned __int64 v95; // [rsp+C8h] [rbp+48h]
  _BYTE *v96; // [rsp+D0h] [rbp+50h]

  v4 = a3;
  v5 = a2;
  v80 = a1;
  sub_7FF7053FB220(&v82, a2, a3, ".llvm./rust/deps\\rustc-demangle-0.1.25\\src\\lib.rs", 6uLL);
  if ( (v82 & 1) != 0 )
  {
    v95 = v4;
    v96 = v5;
    v6 = v88;
    v7 = v92 - 1;
    if ( v88 != -1LL )
    {
      v8 = v87;
      v9 = v87 + v7;
      if ( v87 + v7 < v90 )
      {
        v3 = v86;
        v93 = v85;
        v94 = (v92 - v85);
        do
        {
          if ( _bittest64(&v3, *(v89 + v9)) )
          {
            v10 = v83;
            if ( v6 > v83 )
              v10 = v6;
            v11 = v10;
            while ( v11 < v92 )
            {
              if ( v8 + v11 >= v90 )
              {
                v77 = v8 + v10;
                if ( v90 > v77 )
                  v77 = v90;
                sub_7FF7053FE234(v77, v90, &off_7FF705403478);
              }
              v12 = v11 + 1;
              v13 = *(v91 + v11) == *(v89 + v8 + v11);
              ++v11;
              if ( !v13 )
              {
                v8 = v12 + v8 - v83;
                goto LABEL_14;
              }
            }
            v14 = v83;
            do
            {
              if ( v6 >= v14 )
                goto LABEL_45;
              if ( --v14 >= v92 )
                goto LABEL_201;
              v15 = v14 + v8;
              if ( v14 + v8 >= v90 )
                goto LABEL_200;
            }
            while ( *(v91 + v14) == *(v89 + v15) );
            v8 += v93;
            v6 = v94;
          }
          else
          {
            v8 += v92;
LABEL_14:
            v6 = 0LL;
          }
          v9 = v8 + v7;
        }
        while ( v8 + v7 < v90 );
      }
      goto LABEL_44;
    }
    v8 = v87;
    v16 = v87 + v7;
    if ( v87 + v7 >= v90 )
      goto LABEL_44;
    v93 = v86;
    v81 = v85;
    v94 = (v91 + v83);
    v3 = v89 + v83;
LABEL_29:
    v17 = v93;
    if ( !_bittest64(&v17, *(v89 + v16)) )
    {
      v23 = v92 + v8;
      goto LABEL_42;
    }
    v18 = 0LL;
    v19 = v94;
    v20 = v8;
    while ( v83 + v18 < v92 )
    {
      if ( v83 + v20 >= v90 )
      {
        v78 = v83 + v8;
        if ( v90 > v78 )
          v78 = v90;
        sub_7FF7053FE234(v78, v90, &off_7FF705403478);
      }
      v21 = *v19;
      v22 = v20 + 1;
      ++v19;
      ++v18;
      v13 = v21 == *(v3 + v20++);
      if ( !v13 )
        goto LABEL_43;
    }
    v14 = v83 - 1;
    while ( v14 != -1LL )
    {
      if ( v83 - 1 >= v92 )
LABEL_201:
        sub_7FF7053FE234(v14, v92, &off_7FF705403448);
      v15 = v8 + v14;
      if ( v8 + v14 >= v90 )
LABEL_200:
        sub_7FF7053FE234(v15, v90, &off_7FF705403460);
      v13 = *(v91 + v14) == *(v89 + v8 + v14);
      --v14;
      if ( !v13 )
      {
        v23 = v81 + v8;
LABEL_42:
        v22 = v23;
LABEL_43:
        v16 = v22 + v7;
        v8 = v22;
        if ( v22 + v7 >= v90 )
        {
LABEL_44:
          v5 = v96;
          v4 = v95;
          goto LABEL_69;
        }
        goto LABEL_29;
      }
    }
LABEL_45:
    v5 = v96;
    v4 = v95;
  }
  else
  {
    do
      sub_7FF7053F2FFD(v79, &v82);
    while ( v79[0] == 1LL );
    if ( v79[0] )
    {
      v95 = v4;
      v96 = v5;
      goto LABEL_44;
    }
    v8 = v79[1];
  }
  v24 = v8 + 6;
  if ( v8 != -6LL )
  {
    if ( v24 >= v4 )
    {
      if ( v24 != v4 )
        goto LABEL_49;
    }
    else if ( v5[v24] <= -65 )
    {
LABEL_49:
      v25 = &off_7FF705403C40;
      goto LABEL_210;
    }
  }
  v26 = &v5[v24];
  while ( v26 != &v5[v4] )
  {
    v27 = *v26;
    if ( (v27 & 0x80u) != 0 )
    {
      v28 = v27 & 0x1F;
      v29 = v26[1] & 0x3F;
      if ( v27 <= 0xDFu )
      {
        v26 += 2;
        v27 = v29 | (v28 << 6);
      }
      else
      {
        v30 = (v29 << 6) | v26[2] & 0x3F;
        if ( *v26 < 0xF0u )
        {
          v26 += 3;
          v27 = (v28 << 12) | v30;
        }
        else
        {
          v27 = ((v27 & 7) << 18) | (v30 << 6) | v26[3] & 0x3F;
          if ( v27 == 1114112 )
            break;
          v26 += 4;
        }
      }
    }
    else
    {
      ++v26;
    }
    if ( (v27 - 58) < 0xFFFFFFF6 && (v27 - 71) < 0xFFFFFFF9 )
      goto LABEL_69;
  }
  if ( !v8 )
  {
    v31 = 1LL;
    v4 = 0LL;
    goto LABEL_130;
  }
  if ( v8 < v4 )
  {
    if ( v5[v8] > -65 )
    {
      v4 = v8;
      goto LABEL_69;
    }
LABEL_206:
    sub_7FF7053FE500(v5, v4, 0LL, v8, &off_7FF705403C58);
  }
  if ( v8 != v4 )
    goto LABEL_206;
LABEL_69:
  if ( v4 < 3 )
  {
    if ( v4 != 2 )
      goto LABEL_108;
    if ( *v5 != 20058 )
    {
LABEL_105:
      v4 = 2LL;
      if ( *v5 == 82 )
        goto LABEL_106;
LABEL_108:
      v31 = 1LL;
      goto LABEL_130;
    }
    v32 = -2LL;
    v4 = 2LL;
    v24 = 2LL;
    goto LABEL_85;
  }
  if ( !(*v5 ^ 0x5A5F | v5[2] ^ 0x4E) )
  {
    v32 = -3LL;
    v24 = 3LL;
    if ( v4 == 3 )
    {
      v4 = 3LL;
      goto LABEL_85;
    }
    if ( v5[3] > -65 )
      goto LABEL_85;
    v25 = &off_7FF705403678;
LABEL_210:
    sub_7FF7053FE500(v5, v4, v24, v4, v25);
  }
  if ( *v5 == 20058 )
  {
    if ( v5[2] <= -65 )
      sub_7FF7053FE500(v5, v4, 2uLL, v4, &off_7FF705403660);
    v24 = 2LL;
    v32 = -2LL;
    goto LABEL_85;
  }
  v33 = 3LL;
  if ( v4 == 3 )
    goto LABEL_102;
  if ( *v5 != 1314545503 )
  {
LABEL_101:
    v33 = v4;
LABEL_102:
    if ( *v5 == 21087 )
    {
      v43 = v5[2];
      if ( v43 <= -65 )
        sub_7FF7053FE500(v5, v33, 2uLL, v33, &off_7FF7054038A8);
      v34 = (v5 + 2);
      v3 = -2LL;
    }
    else
    {
      if ( *v5 == 82 )
      {
        v4 = v33;
LABEL_106:
        v43 = v5[1];
        if ( v43 <= -65 )
          sub_7FF7053FE500(v5, v4, 1uLL, v4, &off_7FF705403890);
        v34 = (v5 + 1);
        v3 = -1LL;
LABEL_112:
        v31 = 1LL;
        if ( (v43 - 65) <= 0x19u )
        {
          v3 += v4;
          v35 = 0LL;
          v44 = 0LL;
          while ( v3 != v44 )
          {
            v38 = *(v34 + v44++) < 0;
            if ( v38 )
            {
              v34 = 0LL;
LABEL_132:
              v49 = 0LL;
              v50 = 0LL;
              goto LABEL_133;
            }
          }
          v82 = v34;
          v83 = v3;
          v84 = 0LL;
          LODWORD(v85) = 0;
          v86 = 0LL;
          LODWORD(v87) = 0;
          if ( sub_7FF7053F57DE(&v82, 0) )
            goto LABEL_196;
          v45 = v82;
          if ( v82 )
          {
            v46 = HIBYTE(v83) << 16;
            v47 = v84;
            v48 = v83 | ((((v46 | *(&v83 + 5)) << 32) | *(&v83 + 1)) << 8);
            if ( v84 >= v48 || (v82[v84] - 65) >= 0x1Au )
              goto LABEL_126;
            v83 = v83 | ((((v46 | *(&v83 + 5)) << 32) | *(&v83 + 1)) << 8);
            v86 = 0LL;
            LODWORD(v87) = 0;
            if ( !sub_7FF7053F57DE(&v82, 0) )
            {
              v45 = v82;
              if ( v82 )
              {
                v47 = v84;
                v48 = v83 | (((((HIBYTE(v83) << 16) | *(&v83 + 5)) << 32) | *(&v83 + 1)) << 8);
LABEL_126:
                if ( v47 )
                {
                  if ( v48 <= v47 )
                  {
                    if ( v48 != v47 )
LABEL_129:
                      sub_7FF7053FE500(v45, v48, v47, v48, &off_7FF705403918);
                  }
                  else if ( v45[v47] <= -65 )
                  {
                    goto LABEL_129;
                  }
                }
                v68 = &v45[v47];
                v52 = v48 - v47;
                v35 = 0LL;
                v31 = v68;
                goto LABEL_171;
              }
              goto LABEL_130;
            }
LABEL_196:
            sub_7FF7053FE440(aFmtErrorSShoul, 61LL, v79, "", &off_7FF705403900);
          }
        }
LABEL_130:
        v34 = 0LL;
LABEL_131:
        v35 = 0LL;
        goto LABEL_132;
      }
      v31 = 1LL;
      if ( v33 == 3 )
      {
        v4 = 3LL;
        goto LABEL_130;
      }
      if ( *v5 ^ 0x5F5F | v5[2] ^ 0x52 )
      {
        v34 = 0LL;
        v4 = v33;
        goto LABEL_131;
      }
      v43 = v5[3];
      if ( v43 <= -65 )
        sub_7FF7053FE500(v5, v33, 3uLL, v33, &off_7FF705403878);
      v34 = (v5 + 3);
      v3 = -3LL;
    }
    v4 = v33;
    goto LABEL_112;
  }
  v32 = -4LL;
  v24 = 4LL;
  if ( v4 < 5 )
  {
    v4 = 4LL;
    goto LABEL_85;
  }
  if ( v5[4] <= -65 )
  {
    v25 = &off_7FF705403648;
    goto LABEL_210;
  }
LABEL_85:
  v34 = v4 + v32;
  v35 = &v5[v24];
  v36 = &v35[v34];
  v37 = 0LL;
  while ( v34 != v37 )
  {
    v38 = (v35[v37++] & 0x80u) != 0;
    if ( v38 )
      goto LABEL_100;
  }
  if ( !v34 )
  {
LABEL_100:
    if ( v4 > 2 )
      goto LABEL_101;
    goto LABEL_105;
  }
  v39 = *v35;
  if ( (v39 & 0x80u) != 0 )
  {
    v40 = v39 & 0x1F;
    v41 = v35[1] & 0x3F;
    if ( v39 <= 0xDFu )
    {
      v31 = (v35 + 2);
      v39 = v41 | (v40 << 6);
    }
    else
    {
      v42 = (v41 << 6) | v35[2] & 0x3F;
      if ( *v35 < 0xF0u )
      {
        v31 = (v35 + 3);
        v39 = (v40 << 12) | v42;
      }
      else
      {
        v31 = (v35 + 4);
        v39 = ((v40 & 7) << 18) | (v42 << 6) | v35[3] & 0x3F;
      }
    }
  }
  else
  {
    v31 = (v35 + 1);
  }
  if ( v39 != 69 )
  {
    if ( v39 != 1114112 )
    {
      v3 = 0LL;
      while ( (v39 - 48) <= 9 )
      {
        v53 = 0LL;
        while ( 1 )
        {
          v54 = v39 - 48;
          if ( (v39 - 48) >= 0xA )
            break;
          v56 = v53;
          v55 = 10 * v53;
          if ( is_mul_ok(0xAuLL, v56) )
          {
            v57 = __CFADD__(v54, v55);
            v53 = v54 + v55;
            if ( !v57 && v31 != v36 )
            {
              v58 = v36;
              v39 = *v31;
              if ( (v39 & 0x80u) != 0 )
              {
                v59 = v39 & 0x1F;
                v60 = *(v31 + 1) & 0x3F;
                if ( v39 <= 0xDFu )
                {
                  v31 += 2LL;
                  v39 = v60 | (v59 << 6);
                }
                else
                {
                  v61 = (v60 << 6) | *(v31 + 2) & 0x3F;
                  if ( *v31 < 0xF0u )
                  {
                    v31 += 3LL;
                    v39 = (v59 << 12) | v61;
                  }
                  else
                  {
                    v62 = *(v31 + 3);
                    v31 += 4LL;
                    v39 = ((v59 & 7) << 18) | (v61 << 6) | v62 & 0x3F;
                  }
                }
              }
              else
              {
                ++v31;
              }
              v36 = v58;
              if ( v39 != 1114112 )
                continue;
            }
          }
          goto LABEL_100;
        }
        if ( v53 )
        {
          while ( v31 != v36 )
          {
            v39 = *v31;
            if ( (v39 & 0x80u) != 0 )
            {
              v63 = v4;
              v64 = v39 & 0x1F;
              v65 = *(v31 + 1) & 0x3F;
              if ( v39 <= 0xDFu )
              {
                v31 += 2LL;
                v39 = v65 | (v64 << 6);
                v4 = v63;
              }
              else
              {
                v66 = v36;
                v67 = (v65 << 6) | *(v31 + 2) & 0x3F;
                if ( *v31 < 0xF0u )
                {
                  v31 += 3LL;
                  v39 = (v64 << 12) | v67;
                  v4 = v63;
                  v36 = v66;
                }
                else
                {
                  v39 = ((v39 & 7) << 18) | (v67 << 6) | *(v31 + 3) & 0x3F;
                  v4 = v63;
                  if ( v39 == 1114112 )
                    goto LABEL_100;
                  v36 = v66;
                  v31 += 4LL;
                }
              }
            }
            else
            {
              ++v31;
            }
            if ( !--v53 )
              goto LABEL_165;
          }
          goto LABEL_100;
        }
LABEL_165:
        ++v3;
        if ( v39 == 69 )
          goto LABEL_137;
      }
    }
    goto LABEL_100;
  }
  v3 = 0LL;
LABEL_137:
  v52 = &v36[-v31];
LABEL_171:
  if ( !v52 )
  {
    v49 = 1LL;
    v50 = 0LL;
    goto LABEL_133;
  }
  if ( *v31 != 46 )
  {
    v49 = 0LL;
LABEL_192:
    v50 = 0LL;
    v31 = 1LL;
    goto LABEL_133;
  }
  v96 = v52;
  v69 = (v31 + v52);
  LOBYTE(v52) = 46;
  v49 = 0LL;
  for ( i = v31; ; LOBYTE(v52) = *i )
  {
    if ( (v52 & 0x80u) == 0LL )
    {
      ++i;
      LODWORD(v52) = v52;
      goto LABEL_183;
    }
    v71 = v4;
    v72 = v52 & 0x1F;
    v73 = i[1] & 0x3F;
    if ( v52 <= 0xDFu )
    {
      i += 2;
      LODWORD(v52) = v73 | (v72 << 6);
      goto LABEL_182;
    }
    v74 = (v73 << 6) | i[2] & 0x3F;
    if ( v52 < 0xF0u )
    {
      i += 3;
      LODWORD(v52) = (v72 << 12) | v74;
      goto LABEL_182;
    }
    LODWORD(v52) = ((v52 & 7) << 18) | (v74 << 6) | i[3] & 0x3F;
    if ( v52 == 1114112 )
      break;
    i += 4;
LABEL_182:
    v4 = v71;
LABEL_183:
    if ( (v52 & 0x1FFFDF) - 65 >= 0x1A && (v52 - 48) >= 0xA && (v52 - 33) >= 0xF )
    {
      v75 = (v52 - 58);
      if ( v75 > 0x26 || (v76 = 0x7E0000007FLL, !_bittest64(&v76, v75)) )
      {
        if ( (v52 - 127) < 0xFFFFFFFC )
          goto LABEL_192;
      }
    }
    if ( i == v69 )
    {
      v49 = 1LL;
      goto LABEL_194;
    }
  }
  v49 = 1LL;
  v4 = v71;
LABEL_194:
  v50 = v96;
LABEL_133:
  result = v80;
  *v80 = v49;
  result[1] = v35;
  result[2] = v34;
  result[3] = v3;
  result[4] = v5;
  result[5] = v4;
  result[6] = v31;
  result[7] = v50;
  return result;
}
// 7FF7053F77B8: conditional instruction was optimized away because r13.8==2
// 7FF7053F7979: variable 'v3' is possibly undefined
// 7FF705403448: using guessed type char *off_7FF705403448;
// 7FF705403460: using guessed type char *off_7FF705403460;
// 7FF705403478: using guessed type char *off_7FF705403478;
// 7FF705403648: using guessed type char *off_7FF705403648;
// 7FF705403660: using guessed type char *off_7FF705403660;
// 7FF705403678: using guessed type char *off_7FF705403678;
// 7FF705403878: using guessed type char *off_7FF705403878;
// 7FF705403890: using guessed type char *off_7FF705403890;
// 7FF7054038A8: using guessed type char *off_7FF7054038A8;
// 7FF705403900: using guessed type char *off_7FF705403900;
// 7FF705403918: using guessed type char *off_7FF705403918;
// 7FF705403C40: using guessed type char *off_7FF705403C40;
// 7FF705403C58: using guessed type char *off_7FF705403C58;

//----- (00007FF7053F7DD9) ----------------------------------------------------
_OWORD *__fastcall sub_7FF7053F7DD9(_OWORD *a1, __int64 a2, __int64 a3)
{
  __int128 v4; // xmm0
  __int128 v5; // xmm1
  __int128 v6; // xmm2
  _OWORD v8[5]; // [rsp+20h] [rbp-40h] BYREF

  sub_7FF7053F72D8(v8, a2, a3);
  if ( *&v8[0] )
  {
    v4 = v8[0];
    v5 = v8[1];
    v6 = v8[2];
    a1[3] = v8[3];
    a1[2] = v6;
    a1[1] = v5;
    *a1 = v4;
  }
  else
  {
    *a1 = 2LL;
  }
  return a1;
}

//----- (00007FF7053F7E2D) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F7E2D(__int64 a1, __int64 *a2)
{
  __int128 v3; // [rsp+20h] [rbp-30h] BYREF
  __int64 v4; // [rsp+30h] [rbp-20h]
  int v5; // [rsp+38h] [rbp-18h]
  __int64 *v6; // [rsp+40h] [rbp-10h]
  int v7; // [rsp+48h] [rbp-8h]

  if ( *a1 )
    return sub_7FF7053F3391(a1, a2);
  v3 = *(a1 + 8);
  v4 = 0LL;
  v5 = 0;
  v6 = a2;
  v7 = 0;
  LOBYTE(a2) = 1;
  return sub_7FF7053F57DE(&v3, a2);
}

//----- (00007FF7053F7E74) ----------------------------------------------------
char __fastcall sub_7FF7053F7E74(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  bool v3; // cf
  char v4; // al

  v3 = *(a1 + 8) < a3;
  *(a1 + 8) -= a3;
  v4 = *a1 | v3;
  *a1 = *a1 & 1u | v3;
  if ( (v4 & 1) != 0 )
    return 1;
  else
    return sub_7FF7053F9DC0(*(a1 + 16));
}

//----- (00007FF7053F7E9A) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F7E9A(_DWORD *a1, __int64 a2)
{
  char v3; // cl
  char result; // al
  char v5; // al
  _QWORD v6[4]; // [rsp+30h] [rbp-50h] BYREF
  void *v7; // [rsp+50h] [rbp-30h]
  __int64 v8; // [rsp+58h] [rbp-28h]
  _QWORD v9[2]; // [rsp+60h] [rbp-20h] BYREF
  _QWORD v10[3]; // [rsp+70h] [rbp-10h] BYREF
  _DWORD *v11; // [rsp+88h] [rbp+8h] BYREF

  if ( *a1 == 1 )
  {
    v11 = a1 + 2;
    v10[0] = 0LL;
    v10[1] = 1000000LL;
    v10[2] = a2;
    v9[0] = &v11;
    v9[1] = sub_7FF7053F2BC5;
    v6[0] = &unk_7FF705403C70;
    v6[1] = 1LL;
    if ( _bittest((a2 + 16), 0x17u) )
    {
      v7 = &unk_7FF705403C80;
      v8 = 1LL;
    }
    else
    {
      v7 = 0LL;
    }
    v6[2] = v9;
    v6[3] = 1LL;
    v5 = sub_7FF7053F9220(v10, &unk_7FF7054035B8, v6);
    if ( LODWORD(v10[0]) == 1 )
    {
      if ( !v5 )
        sub_7FF7053FE440(aFmtErrorFromSi, 55LL, v6, &unk_7FF7054034C0, &off_7FF705403D00);
      v5 = sub_7FF7053F9DC0(a2);
    }
    if ( v5 )
      return 1;
    return sub_7FF7053F9DC0(a2);
  }
  v3 = sub_7FF7053F9DC0(a2);
  result = 1;
  if ( !v3 )
    return sub_7FF7053F9DC0(a2);
  return result;
}
// 7FF705403D00: using guessed type char *off_7FF705403D00;

//----- (00007FF7053F7FE6) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F7FE6(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9DC0(a2);
}

//----- (00007FF7053F8000) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F8000(unsigned __int64 **a1, __int64 a2)
{
  unsigned __int64 *v2; // rcx
  int v3; // eax

  v2 = *a1;
  v3 = *(a2 + 16);
  if ( (v3 & 0x2000000) != 0 )
    return sub_7FF7053FBF60(v2, a2);
  if ( (v3 & 0x4000000) != 0 )
    return sub_7FF7053FBFF0(v2, a2);
  return sub_7FF7053FC390(v2, a2);
}

//----- (00007FF7053F8030) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F8030(_DWORD **a1, char *a2)
{
  _DWORD *v2; // rcx
  _DWORD *v4; // [rsp+28h] [rbp-8h] BYREF

  v2 = *a1;
  if ( *v2 != 1 )
    return sub_7FF7053F9DC0(a2);
  v4 = v2 + 2;
  return sub_7FF7053F9F80(a2, "Some", 4LL, &v4, &unk_7FF705404058);
}

//----- (00007FF7053F80A0) ----------------------------------------------------
char __fastcall sub_7FF7053F80A0(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9220(a1, &off_7FF705404080, a2);
}
// 7FF705404080: using guessed type __int64 (__fastcall *off_7FF705404080)();

//----- (00007FF7053F80B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F80B0(_QWORD *a1)
{
  __int64 result; // rax

  if ( *a1 )
    return sub_7FF7053E5E40(a1[1], *a1, 1LL);
  return result;
}
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);

//----- (00007FF7053F80D0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F80D0(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9DC0(a2);
}

//----- (00007FF7053F80F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053F80F0(unsigned __int64 a1, __int64 *a2, __int64 a3)
{
  unsigned __int64 v4; // rsi
  unsigned __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r9
  __int64 v9; // rax
  __int64 v10; // r14
  __int64 v11; // rax
  __int128 v13; // [rsp+28h] [rbp-28h] BYREF
  __int64 v14; // [rsp+38h] [rbp-18h]
  char v15; // [rsp+47h] [rbp-9h] BYREF
  __int64 v16; // [rsp+48h] [rbp-8h]

  v16 = -2LL;
  v4 = a1;
  v5 = a2[1];
  if ( !v5 )
  {
    if ( a2[3] )
    {
      v7 = 0LL;
LABEL_14:
      v9 = 0LL;
      if ( v7 > 0 )
        v9 = v7;
      v7 = 2 * v9;
      goto LABEL_17;
    }
LABEL_21:
    v11 = 1LL;
    v7 = 0LL;
    goto LABEL_22;
  }
  v6 = *a2;
  a1 = v5 & 3;
  if ( v5 >= 4 )
  {
    v5 &= 0xFFFFFFFFFFFFFFFCuLL;
    v8 = (v6 + 56);
    v7 = 0LL;
    a3 = 0LL;
    do
    {
      v7 += *v8 + *(v8 - 2) + *(v8 - 4) + *(v8 - 6);
      a3 += 4LL;
      v8 += 8;
    }
    while ( v5 != a3 );
  }
  else
  {
    v7 = 0LL;
    a3 = 0LL;
  }
  if ( a1 )
  {
    v5 = 16 * a3 + v6 + 8;
    a1 = (16 * a1);
    a3 = 0LL;
    do
    {
      v7 += *(v5 + a3);
      a3 += 16LL;
    }
    while ( a1 != a3 );
  }
  if ( a2[3] )
  {
    if ( v7 > 0xF || *(v6 + 8) )
      goto LABEL_14;
    goto LABEL_21;
  }
LABEL_17:
  if ( v7 < 0 )
  {
    v10 = 0LL;
    goto LABEL_26;
  }
  if ( !v7 )
    goto LABEL_21;
  nullsub_1(a1, v5, a3);
  v10 = 1LL;
  v11 = sub_7FF7053E5E30(v7, 1LL);
  if ( !v11 )
LABEL_26:
    sub_7FF7053FDFF0(v10, v7, &off_7FF705404138);
LABEL_22:
  *&v13 = v7;
  *(&v13 + 1) = v11;
  v14 = 0LL;
  if ( sub_7FF7053F9220(&v13, &off_7FF705404080, a2) )
    sub_7FF7053FE440(
      "a formatting trait implementation returned an error when the underlying stream did notlibrary\\alloc\\src\\fmt.rs",
      86LL,
      &v15,
      &unk_7FF705404008,
      &off_7FF7054041C0);
  *(v4 + 16) = v14;
  *v4 = v13;
  return v4;
}
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD);
// 7FF705404080: using guessed type __int64 (__fastcall *off_7FF705404080)();
// 7FF705404138: using guessed type char *off_7FF705404138;
// 7FF7054041C0: using guessed type char *off_7FF7054041C0;

//----- (00007FF7053F82C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053F82C0(_QWORD *a1, __int16 *a2, __int64 a3)
{
  __int16 *v4; // rdi
  __int64 v6; // r14
  __int64 v7; // rax
  __int16 *v8; // r12
  __int64 v9; // rbx
  __int16 *v10; // r8
  unsigned int v11; // r14d
  __int16 v12; // r8
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // r15
  __int64 v15; // r9
  unsigned __int64 v16; // rdx
  __int64 v18; // [rsp+28h] [rbp-18h] BYREF
  __int64 v19; // [rsp+30h] [rbp-10h]
  __int64 v20; // [rsp+38h] [rbp-8h]
  __int64 v21; // [rsp+40h] [rbp+0h]

  v21 = -2LL;
  if ( a3 < 0 )
  {
    v6 = 0LL;
    goto LABEL_33;
  }
  v4 = a2;
  if ( a3 )
  {
    nullsub_1(a1, a2, a3);
    v6 = 1LL;
    v7 = sub_7FF7053E5E30(a3, 1LL);
    if ( !v7 )
LABEL_33:
      sub_7FF7053FDFF0(v6, a3, &off_7FF705404138);
  }
  else
  {
    v7 = 1LL;
  }
  v18 = a3;
  v19 = v7;
  v20 = 0LL;
  if ( !a3 )
  {
LABEL_28:
    a1[2] = v20;
    *a1 = v18;
    a1[1] = v19;
    return a1;
  }
  v8 = &v4[a3];
  v9 = 0LL;
  while ( 1 )
  {
    v10 = v4 + 1;
    v11 = *v4;
    if ( (*v4 & 0xF800) == 0xD800 )
      break;
    v13 = v11 << 16;
    ++v4;
    v14 = 1LL;
    if ( v13 < 0x800000 )
      goto LABEL_19;
LABEL_17:
    v14 = 2LL;
    if ( v13 >= 0x8000000 )
      v14 = (__PAIR128__(4LL, HIDWORD(v13)) - 1) >> 64;
LABEL_19:
    v15 = v9;
    if ( v14 > v18 - v9 )
    {
      sub_7FF7053FDED0(&v18, v9, v14);
      v7 = v19;
      v15 = v20;
      v16 = v13 >> 16;
      if ( v13 >= 0x800000 )
      {
LABEL_21:
        if ( v13 >= 0x8000000 )
        {
          if ( HIDWORD(v13) )
          {
            *(v7 + v15) = (v13 >> 34) | 0xF0;
            *(v7 + v15 + 1) = (v13 >> 28) & 0x3F | 0x80;
            *(v7 + v15 + 2) = (v13 >> 22) & 0x3F | 0x80;
            *(v7 + v15 + 3) = v16 & 0x3F | 0x80;
          }
          else
          {
            *(v7 + v15) = (v13 >> 28) | 0xE0;
            *(v7 + v15 + 1) = (v13 >> 22) & 0x3F | 0x80;
            *(v7 + v15 + 2) = v16 & 0x3F | 0x80;
          }
        }
        else
        {
          *(v7 + v15) = (v13 >> 22) | 0xC0;
          *(v7 + v15 + 1) = v16 & 0x3F | 0x80;
        }
        goto LABEL_9;
      }
    }
    else
    {
      v16 = v13 >> 16;
      if ( v13 >= 0x800000 )
        goto LABEL_21;
    }
    *(v7 + v15) = v16;
LABEL_9:
    v9 += v14;
    v20 = v9;
    if ( v4 == v8 )
      goto LABEL_28;
  }
  if ( v11 <= 0xDBFF && v10 != v8 )
  {
    v12 = *v10;
    if ( (v12 + 0x2000) >= 0xFC00u )
    {
      v4 += 2;
      v13 = (((v11 & 0x3FF) << 26) | ((v12 & 0x3FF) << 16)) + 0x100000000LL;
      v14 = 1LL;
      if ( v13 < 0x800000 )
        goto LABEL_19;
      goto LABEL_17;
    }
  }
  *a1 = 0x8000000000000000uLL;
  if ( v18 )
    sub_7FF7053E5E40(v19, v18, 1LL);
  return a1;
}
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E40: using guessed type __int64 __fastcall sub_7FF7053E5E40(_QWORD, _QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD);
// 7FF705404138: using guessed type char *off_7FF705404138;

//----- (00007FF7053F85F0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F85F0(__int64 *a1, const void *a2, size_t a3)
{
  __int64 v5; // rbx
  const void *v7; // r14

  v5 = a1[2];
  if ( a3 > *a1 - v5 )
  {
    v7 = a2;
    sub_7FF7053FDED0(a1, a1[2], a3);
    a2 = v7;
    v5 = a1[2];
  }
  memcpy((v5 + a1[1]), a2, a3);
  a1[2] = a3 + v5;
  return 0LL;
}

//----- (00007FF7053F8660) ----------------------------------------------------
__int64 __fastcall sub_7FF7053F8660(__int64 *a1, unsigned int a2)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 *v6; // rbx
  unsigned int v7; // r14d

  v2 = a1[2];
  v3 = 1LL;
  if ( a2 >= 0x80 )
  {
    v3 = 2LL;
    if ( a2 >= 0x800 )
      v3 = 4LL - (a2 < 0x10000);
  }
  v4 = a1[2];
  if ( v3 > *a1 - v2 )
  {
    v6 = a1;
    v7 = a2;
    sub_7FF7053FDED0(a1, a1[2], v3);
    a2 = v7;
    a1 = v6;
    v4 = v6[2];
    v5 = v6[1];
    if ( v7 < 0x80 )
      goto LABEL_6;
  }
  else
  {
    v5 = a1[1];
    if ( a2 < 0x80 )
    {
LABEL_6:
      *(v5 + v4) = a2;
      goto LABEL_13;
    }
  }
  if ( a2 >= 0x800 )
  {
    if ( a2 >= 0x10000 )
    {
      *(v5 + v4) = (a2 >> 18) | 0xF0;
      *(v5 + v4 + 1) = (a2 >> 12) & 0x3F | 0x80;
      *(v5 + v4 + 2) = (a2 >> 6) & 0x3F | 0x80;
      *(v5 + v4 + 3) = a2 & 0x3F | 0x80;
    }
    else
    {
      *(v5 + v4) = (a2 >> 12) | 0xE0;
      *(v5 + v4 + 1) = (a2 >> 6) & 0x3F | 0x80;
      *(v5 + v4 + 2) = a2 & 0x3F | 0x80;
    }
  }
  else
  {
    *(v5 + v4) = (a2 >> 6) | 0xC0;
    *(v5 + v4 + 1) = a2 & 0x3F | 0x80;
  }
LABEL_13:
  a1[2] = v2 + v3;
  return 0LL;
}

//----- (00007FF7053F87A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F87A0(unsigned __int64 *a1, __int64 a2)
{
  unsigned int v2; // ebx
  int v5; // eax
  unsigned __int64 v6; // rcx
  __int64 v7; // rax
  unsigned __int64 v8; // rdx
  char v9; // r9
  bool v10; // cf
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  char v13; // r9
  bool v14; // cc
  unsigned __int64 *v15; // rdi
  int v16; // eax
  unsigned __int64 v18; // rcx
  __int64 v19; // rax
  unsigned __int64 v20; // rdx
  char v21; // r9
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  char v24; // r9
  _BYTE v26[25]; // [rsp+B7h] [rbp+37h] BYREF

  v5 = *(a2 + 16);
  if ( (v5 & 0x2000000) != 0 )
  {
    v6 = *a1;
    v7 = 0LL;
    v8 = *a1;
    do
    {
      v8 >>= 4;
      v9 = (v6 & 0xF) + 87;
      if ( (v6 & 0xF) < 0xA )
        v9 = (v6 & 0xF) + 48;
      v26[v7--] = v9;
      v10 = v6 < 0x10;
      v6 = v8;
    }
    while ( !v10 );
LABEL_14:
    LOBYTE(v2) = 1;
    if ( sub_7FF7053F9420(
           a2,
           1,
           "0x00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525"
           "354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library\\core\\src\\fmt\\mod.rs",
           2uLL,
           &v26[v7 + 1],
           -v7) )
      return v2;
    goto LABEL_15;
  }
  if ( (v5 & 0x4000000) != 0 )
  {
    v11 = *a1;
    v7 = 0LL;
    v12 = *a1;
    do
    {
      v12 >>= 4;
      v13 = (v11 & 0xF) + 55;
      if ( (v11 & 0xF) < 0xA )
        v13 = (v11 & 0xF) + 48;
      v26[v7--] = v13;
      v14 = v11 <= 0xF;
      v11 = v12;
    }
    while ( !v14 );
    goto LABEL_14;
  }
  LOBYTE(v2) = 1;
  if ( sub_7FF7053FC390(a1, a2) )
    return v2;
LABEL_15:
  if ( !(*(*(a2 + 8) + 24LL))(*a2, "..0123456789abcdef", 2LL) )
  {
    v15 = a1 + 1;
    v16 = *(a2 + 16);
    if ( (v16 & 0x2000000) != 0 )
    {
      v18 = *v15;
      v19 = 0LL;
      v20 = *v15;
      do
      {
        v20 >>= 4;
        v21 = (v18 & 0xF) + 87;
        if ( (v18 & 0xF) < 0xA )
          v21 = (v18 & 0xF) + 48;
        v26[v19--] = v21;
        v14 = v18 <= 0xF;
        v18 = v20;
      }
      while ( !v14 );
    }
    else
    {
      if ( (v16 & 0x4000000) == 0 )
        return sub_7FF7053FC390(v15, a2);
      v22 = *v15;
      v19 = 0LL;
      v23 = *v15;
      do
      {
        v23 >>= 4;
        v24 = (v22 & 0xF) + 55;
        if ( (v22 & 0xF) < 0xA )
          v24 = (v22 & 0xF) + 48;
        v26[v19--] = v24;
        v14 = v22 <= 0xF;
        v22 = v23;
      }
      while ( !v14 );
    }
    return sub_7FF7053F9420(
             a2,
             1,
             "0x000102030405060708091011121314151617181920212223242526272829303132333435363738394041424344454647484950515"
             "25354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library\\cor"
             "e\\src\\fmt\\mod.rs",
             2uLL,
             &v26[v19 + 1],
             -v19);
  }
  return v2;
}
// 7FF7053F8992: variable 'v2' is possibly undefined

//----- (00007FF7053F89A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F89A0(__int64 a1, __int64 *a2)
{
  return sub_7FF7053F9980(
           a2,
           "RefCell already borrowed[called `Option::unwrap()` on a `None` valuelibrary\\core\\src\\panicking.rs",
           0x18uLL);
}

//----- (00007FF7053F89C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F89C0(__int64 a1, unsigned int a2, int a3)
{
  __int64 v4; // rdi
  char v5; // al
  unsigned int v6; // edx
  __int64 v7; // rdx
  char result; // al
  __int64 v9; // rdi
  char v10; // dl
  unsigned int v11; // ecx
  __int64 v12; // rcx
  __int16 v13; // [rsp+2Ah] [rbp-16h]
  __int64 v14; // [rsp+2Ch] [rbp-14h]
  __int16 v15; // [rsp+34h] [rbp-Ch]
  __int64 v16; // [rsp+36h] [rbp-Ah]
  __int16 v17; // [rsp+3Eh] [rbp-2h]

  switch ( a2 )
  {
    case 0u:
      *a1 = 12380;
      goto LABEL_19;
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 0xBu:
    case 0xCu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x23u:
    case 0x24u:
    case 0x25u:
    case 0x26u:
      goto LABEL_5;
    case 9u:
      *a1 = 29788;
      goto LABEL_19;
    case 0xAu:
      *a1 = 28252;
      goto LABEL_19;
    case 0xDu:
      *a1 = 29276;
      goto LABEL_19;
    case 0x22u:
      if ( (a3 & 0xFFFFFFu) < 0x10000 )
        goto LABEL_14;
      *a1 = 8796;
      goto LABEL_19;
    case 0x27u:
      if ( (a3 & 0x100) == 0 )
        goto LABEL_14;
      *a1 = 10076;
      goto LABEL_19;
    default:
      if ( a2 == 92 )
      {
        *a1 = 23644;
LABEL_19:
        *(a1 + 2) = 0LL;
        v10 = 2;
        result = 0;
      }
      else
      {
LABEL_5:
        if ( ((a2 >= 0x300) & a3) != 0 && (v4 = a1, v5 = sub_7FF7053FC600(a2), a1 = v4, v5) )
        {
          _BitScanReverse(&v6, a2 | 1);
          v7 = (v6 ^ 0x1C) >> 2;
          result = v7 - 2;
          BYTE2(v16) = 0;
          LOWORD(v16) = 0;
          BYTE3(v16) = a0123456789abcd_1[a2 >> 20];
          BYTE4(v16) = a0123456789abcd_1[HIWORD(a2) & 0xF];
          BYTE5(v16) = a0123456789abcd_1[a2 >> 12];
          BYTE6(v16) = a0123456789abcd_1[(a2 >> 8) & 0xF];
          HIBYTE(v16) = a0123456789abcd_1[a2 >> 4];
          LOBYTE(v17) = a0123456789abcd_1[a2 & 0xF];
          HIBYTE(v17) = 125;
          *(&v15 + v7) = 30044;
          *(&v16 + v7) = 123;
          *(v4 + 8) = v17;
          *v4 = v16;
        }
        else
        {
LABEL_14:
          v9 = a1;
          if ( sub_7FF7053FBC50(a2) )
          {
            a1 = v9;
            *v9 = a2;
            v10 = -127;
            result = 0x80;
            goto LABEL_20;
          }
          _BitScanReverse(&v11, a2 | 1);
          v12 = (v11 ^ 0x1C) >> 2;
          result = v12 - 2;
          BYTE2(v14) = 0;
          LOWORD(v14) = 0;
          BYTE3(v14) = a0123456789abcd_1[a2 >> 20];
          BYTE4(v14) = a0123456789abcd_1[HIWORD(a2) & 0xF];
          BYTE5(v14) = a0123456789abcd_1[a2 >> 12];
          BYTE6(v14) = a0123456789abcd_1[(a2 >> 8) & 0xF];
          HIBYTE(v14) = a0123456789abcd_1[a2 >> 4];
          LOBYTE(v15) = a0123456789abcd_1[a2 & 0xF];
          HIBYTE(v15) = 125;
          *(&v13 + v12) = 30044;
          *(&v14 + v12) = 123;
          a1 = v9;
          *(v9 + 8) = v15;
          *v9 = v14;
        }
        v10 = 10;
      }
LABEL_20:
      *(a1 + 12) = result;
      *(a1 + 13) = v10;
      return result;
  }
}

//----- (00007FF7053F8C10) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F8C10(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r13
  unsigned __int64 v4; // r14
  __int64 v5; // rbx
  unsigned __int64 v6; // r12
  unsigned __int64 v7; // rdi
  bool v8; // al
  char v9; // al
  unsigned __int64 v10; // r15
  __int64 v11; // r10
  unsigned __int64 v12; // rcx
  __int64 v13; // rax
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // r9
  _QWORD *v17; // rsi
  __int64 v18; // rsi
  unsigned __int64 v19; // rbx
  unsigned __int64 v20; // r14
  unsigned __int64 v21; // r12
  char v22; // al
  char v24; // [rsp+28h] [rbp-28h]
  bool *v25; // [rsp+30h] [rbp-20h]
  __int64 v26; // [rsp+38h] [rbp-18h]
  __int64 v27; // [rsp+40h] [rbp-10h]
  unsigned __int64 v28; // [rsp+48h] [rbp-8h]

  v25 = a1[2];
  v26 = *a1;
  v27 = a1[1];
  v3 = 0LL;
  v4 = 0xF5F5F5F5F5F5F5F5uLL;
  v5 = 0x101010101010101LL;
  v6 = 0x8080808080808080uLL;
  v7 = 0LL;
  v24 = 0;
  v28 = a3;
  do
  {
    if ( (v24 & 1) != 0 )
      return 0;
    if ( a3 < v3 )
    {
      v10 = v3;
      v11 = a2;
      goto LABEL_33;
    }
    v11 = a2;
    while ( 1 )
    {
      v12 = a3 - v3;
      v13 = v11 + v3;
      if ( a3 - v3 > 0xF )
        break;
      if ( a3 == v3 )
        goto LABEL_32;
      v14 = 0LL;
      while ( *(v13 + v14) != 10 )
      {
        if ( v12 == ++v14 )
          goto LABEL_32;
      }
LABEL_29:
      v10 = v14 + v3 + 1;
      if ( v14 + v3 < a3 && *(v14 + v13) == 10 )
      {
        v18 = v5;
        v19 = v4;
        v20 = v6;
        v3 += v14 + 1;
        v21 = v10;
        goto LABEL_34;
      }
      v3 += v14 + 1;
      if ( v10 > a3 )
        goto LABEL_33;
    }
    v15 = ((v13 + 7) & 0xFFFFFFFFFFFFFFF8uLL) - v13;
    if ( v15 )
    {
      v14 = 0LL;
      while ( *(v13 + v14) != 10 )
      {
        if ( v15 == ++v14 )
        {
          v16 = v12 - 16;
          if ( v15 <= v12 - 16 )
            goto LABEL_22;
          goto LABEL_25;
        }
      }
      goto LABEL_29;
    }
    v16 = v12 - 16;
LABEL_22:
    v17 = (((v13 + 7) & 0xFFFFFFFFFFFFFFF8uLL) + 8);
    do
    {
      if ( (v6 & ~((*(v17 - 1) | (v5 + (v4 ^ *(v17 - 1)))) & (*v17 | (v5 + (v4 ^ *v17))))) != 0 )
        break;
      v15 += 16LL;
      v17 += 2;
    }
    while ( v15 <= v16 );
LABEL_25:
    v14 = v15;
    v11 = a2;
    a3 = v28;
    if ( v12 != v15 )
    {
      while ( *(v13 + v14) != 10 )
      {
        if ( v12 == ++v14 )
          goto LABEL_32;
      }
      goto LABEL_29;
    }
LABEL_32:
    v10 = a3;
LABEL_33:
    v18 = v5;
    v19 = v4;
    v20 = v6;
    v24 = 1;
    v3 = v10;
    v10 = v7;
    v21 = a3;
    if ( a3 == v7 )
      return 0;
LABEL_34:
    if ( *v25 )
    {
      v22 = (*(v27 + 24))(v26, asc_7FF705404928, 4LL);
      v11 = a2;
      if ( v22 )
        break;
    }
    v8 = v21 != v7 && *(v11 + v21 - 1) == 10;
    *v25 = v8;
    v9 = (*(v27 + 24))(v26, v11 + v7, v21 - v7);
    v7 = v10;
    v6 = v20;
    v4 = v19;
    v5 = v18;
    a3 = v28;
  }
  while ( !v9 );
  return 1;
}

//----- (00007FF7053F8EA0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F8EA0(_QWORD *a1, int a2)
{
  bool *v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  int v5; // r14d
  char v6; // al

  v2 = a1[2];
  v3 = *a1;
  v4 = a1[1];
  if ( *v2 )
  {
    v5 = a2;
    v6 = (*(v4 + 24))(*a1, asc_7FF705404928, 4LL);
    a2 = v5;
    if ( v6 )
      return 1;
  }
  *v2 = a2 == 10;
  return (*(v4 + 32))(v3);
}

//----- (00007FF7053F8F10) ----------------------------------------------------
_BYTE *__fastcall sub_7FF7053F8F10(_BYTE *a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  char v6; // r14
  _QWORD *v9; // rbx
  unsigned __int8 v10; // al
  __int64 v11; // r12
  unsigned __int64 v12; // r15
  char *v13; // rdx
  char v14; // al
  unsigned __int64 v15; // r14
  __int64 v16; // r15
  char v17; // al
  __int128 v18; // [rsp+20h] [rbp-30h] BYREF
  char *v19; // [rsp+30h] [rbp-20h]
  __int128 *v20; // [rsp+38h] [rbp-18h] BYREF
  __int64 (__fastcall **v21)(_OWORD *, const char *, __int64); // [rsp+40h] [rbp-10h]
  __int64 v22; // [rsp+48h] [rbp-8h]
  char v23; // [rsp+57h] [rbp+7h] BYREF

  v6 = 1;
  if ( a1[8] )
    goto LABEL_2;
  v9 = *a1;
  v10 = a1[9];
  if ( *(*a1 + 18LL) < 0 )
  {
    if ( v10
      || (v15 = a3, v16 = a2, v17 = (*(v9[1] + 24LL))(*v9, &asc_7FF70540492C[5], 3LL), a2 = v16, a3 = v15, v6 = 1, !v17) )
    {
      v23 = 1;
      v18 = *v9;
      v19 = &v23;
      v22 = v9[2];
      v20 = &v18;
      v21 = &unk_7FF7054048F8;
      if ( !sub_7FF7053F8C10(&v18, a2, a3)
        && !sub_7FF7053F8C10(&v18, &unk_7FF7054048D0, 2uLL)
        && !(*(a5 + 24))(a4, &v20) )
      {
        v14 = v21[3](v20, asc_7FF705404934, 2LL);
        goto LABEL_16;
      }
    }
  }
  else
  {
    v11 = a2;
    v12 = a3;
    v13 = asc_7FF70540492C;
    if ( v10 )
      v13 = &asc_7FF70540492C[3];
    if ( !(*(v9[1] + 24LL))(*v9, v13, v10 ^ 3LL)
      && !(*(v9[1] + 24LL))(*v9, v11, v12)
      && !(*(v9[1] + 24LL))(*v9, &unk_7FF7054048D0, 2LL) )
    {
      v14 = (*(a5 + 24))(a4, v9);
LABEL_16:
      v6 = v14;
    }
  }
LABEL_2:
  a1[8] = v6;
  a1[9] = 1;
  return a1;
}

//----- (00007FF7053F90A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_BYTE *__fastcall sub_7FF7053F90A0(_BYTE *a1, __int64 a2, __int64 a3)
{
  char v4; // al
  _QWORD *v5; // rdi
  char v6; // al
  __int64 v7; // rbx
  __int64 v8; // r14
  char v9; // al
  char v10; // cl
  __int64 v11; // rbx
  __int64 v12; // r14
  char v13; // al
  char v14; // cl
  __int128 v16; // [rsp+20h] [rbp-40h] BYREF
  char *v17; // [rsp+30h] [rbp-30h]
  __int128 *v18; // [rsp+40h] [rbp-20h] BYREF
  __int64 (__fastcall **v19)(_OWORD *, const char *, __int64); // [rsp+48h] [rbp-18h]
  __int64 v20; // [rsp+50h] [rbp-10h]
  char v21; // [rsp+5Fh] [rbp-1h] BYREF

  v4 = 1;
  if ( !a1[8] )
  {
    v5 = *a1;
    v6 = a1[9];
    if ( *(*a1 + 18LL) < 0 )
    {
      if ( v6
        || (v11 = a3,
            v12 = a2,
            v13 = (*(v5[1] + 24LL))(*v5, &unk_7FF70540493D, 1LL),
            a2 = v12,
            a3 = v11,
            v14 = v13,
            v4 = 1,
            !v14) )
      {
        v21 = 1;
        v16 = *v5;
        v17 = &v21;
        v20 = v5[2];
        v18 = &v16;
        v19 = &unk_7FF7054048F8;
        if ( (*(a3 + 24))(a2, &v18) )
          v4 = 1;
        else
          v4 = v19[3](v18, asc_7FF705404934, 2LL);
      }
    }
    else if ( !v6
           || (v7 = a3,
               v8 = a2,
               v9 = (*(v5[1] + 24LL))(*v5, &asc_7FF70540492C[3], 2LL),
               a2 = v8,
               a3 = v7,
               v10 = v9,
               v4 = 1,
               !v10) )
    {
      v4 = (*(a3 + 24))(a2, v5);
    }
  }
  a1[8] = v4;
  a1[9] = 1;
  return a1;
}

//----- (00007FF7053F91C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F91C0(__int64 a1)
{
  char result; // al

  result = 1;
  if ( !*(a1 + 8) )
    result = (*(*(*a1 + 8LL) + 24LL))(
               **a1,
               "]0x000102030405060708091011121314151617181920212223242526272829303132333435363738394041424344454647484950"
               "51525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library"
               "\\core\\src\\fmt\\mod.rs",
               1LL);
  *(a1 + 8) = result;
  return result;
}
// 7FF70540493E: using guessed type char asc_7FF70540493E;

//----- (00007FF7053F9200) ----------------------------------------------------
char __fastcall sub_7FF7053F9200(__int64 a1, _QWORD *a2)
{
  return sub_7FF7053F9220(a1, &unk_7FF7054048F8, a2);
}

//----- (00007FF7053F9210) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F9210(_QWORD *a1, __int64 *a2)
{
  return sub_7FF7053F9220(*a2, a2[1], a1);
}

//----- (00007FF7053F9220) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F9220(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v4; // r14
  __int64 v5; // rax
  __int64 v6; // r12
  _QWORD *v7; // r15
  __int64 v8; // r13
  __int64 v9; // rdi
  unsigned __int64 v10; // rbx
  __int16 v11; // ax
  int v12; // ecx
  __int16 v13; // cx
  __int64 v14; // r8
  __int64 v15; // r14
  __int64 v16; // r15
  __int64 v17; // r14
  __int64 v18; // r12
  __int64 v19; // r13
  __int64 v20; // rdi
  char result; // al
  char v22; // cl
  __int64 v23; // [rsp+20h] [rbp-10h] BYREF
  __int64 v24; // [rsp+28h] [rbp-8h]
  __int64 v25; // [rsp+30h] [rbp+0h]

  v25 = 3758096416LL;
  v23 = a1;
  v24 = a2;
  v4 = a3[4];
  if ( v4 )
  {
    v5 = a3[5];
    if ( v5 )
    {
      v6 = a3[2];
      v7 = (*a3 + 8LL);
      v8 = 48 * v5;
      v9 = 0LL;
      v10 = 0LL;
      while ( 1 )
      {
        if ( *v7 && (*(v24 + 24))(v23, *(v7 - 1)) )
          return 1;
        if ( *(v4 + v9 + 16) )
        {
          if ( *(v4 + v9 + 16) == 1 )
          {
            v11 = *(v6 + 16LL * *(v4 + v9 + 24) + 8);
            v12 = *(v4 + v9);
            if ( v12 != 2 )
              goto LABEL_9;
          }
          else
          {
            v11 = 0;
            v12 = *(v4 + v9);
            if ( v12 != 2 )
            {
LABEL_9:
              if ( v12 == 1 )
                v13 = *(v6 + 16LL * *(v4 + v9 + 8) + 8);
              else
                v13 = *(v4 + v9 + 2);
              goto LABEL_16;
            }
          }
        }
        else
        {
          v11 = *(v4 + v9 + 18);
          v12 = *(v4 + v9);
          if ( v12 != 2 )
            goto LABEL_9;
        }
        v13 = 0;
LABEL_16:
        v14 = 16LL * *(v4 + v9 + 32);
        LODWORD(v25) = *(v4 + v9 + 40);
        WORD2(v25) = v11;
        HIWORD(v25) = v13;
        if ( (*(v6 + v14 + 8))(*(v6 + v14), &v23) )
          return 1;
        v7 += 2;
        v9 += 48LL;
        ++v10;
        if ( v8 == v9 )
          goto LABEL_25;
      }
    }
    v10 = 0LL;
    if ( a3[1] )
    {
LABEL_31:
      v22 = (*(v24 + 24))(v23, *(*a3 + 16 * v10), *(*a3 + 16 * v10 + 8));
      result = 1;
      if ( v22 )
        return result;
    }
  }
  else
  {
    v15 = a3[3];
    if ( v15 )
    {
      v16 = a3[2];
      v17 = v16 + 16 * v15;
      v18 = *a3;
      v19 = 0LL;
      v10 = 0LL;
      do
      {
        if ( *(v18 + v19 + 8) && (*(v24 + 24))(v23, *(v18 + v19)) )
          return 1;
        v20 = v16 + v19;
        if ( (*(v16 + v19 + 8))(*(v16 + v19), &v23) )
          return 1;
        v19 += 16LL;
        ++v10;
      }
      while ( v20 + 16 != v17 );
LABEL_25:
      if ( v10 >= a3[1] )
        return 0;
      goto LABEL_31;
    }
    v10 = 0LL;
    if ( a3[1] )
      goto LABEL_31;
  }
  return 0;
}

//----- (00007FF7053F9420) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F9420(
        __int64 a1,
        char a2,
        unsigned __int16 *a3,
        unsigned __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v7; // r15
  unsigned int v9; // edi
  int v10; // ecx
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r13
  __int64 v15; // rdi
  __int64 v16; // rbx
  char v17; // al
  __m128i si128; // xmm2
  __m128i v20; // xmm0
  __m128i v21; // xmm3
  __m128i v22; // xmm0
  __m128i v23; // xmm1
  __m128i v24; // xmm1
  __m128i v25; // xmm4
  __m128i v26; // xmm5
  __m128i v27; // xmm4
  __m128i v28; // xmm5
  __m128i v29; // xmm4
  __m128i v30; // xmm5
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  __m128i v33; // xmm4
  __m128i v34; // xmm5
  __m128i v35; // xmm4
  __m128i v36; // xmm5
  __m128i v37; // xmm0
  int v38; // eax
  __int16 v39; // si
  __int64 v40; // rbx
  __int64 v41; // rdi
  char v42; // al
  __int16 v43; // r13
  unsigned int v44; // edi
  __int64 v45; // rbx
  __int64 v46; // r14
  __int16 v47; // si
  char v48; // al
  unsigned __int16 v49; // si
  __int16 v50; // [rsp+28h] [rbp-28h]
  int v51; // [rsp+30h] [rbp-20h]
  __int64 v52; // [rsp+40h] [rbp-10h]
  int v53; // [rsp+48h] [rbp-8h]
  __int64 v54; // [rsp+48h] [rbp-8h]
  unsigned int v55; // [rsp+54h] [rbp+4h]

  v7 = a3;
  if ( a2 )
  {
    v9 = *(a1 + 16);
    v10 = 43;
    if ( (*(a1 + 16) & 0x200000) == 0 )
      v10 = 1114112;
    v55 = v10;
    v11 = a6 + ((v9 & 0x200000) >> 21);
    v52 = a5;
    if ( (v9 & 0x800000) != 0 )
    {
LABEL_5:
      if ( a4 >= 0x20 )
      {
        v12 = sub_7FF7053FAB30(a3, a4);
      }
      else if ( a4 )
      {
        if ( a4 >= 4 )
        {
          v13 = a4 & 0x1C;
          si128 = _mm_load_si128(&xmmword_7FF7054041E0);
          v20 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*a3), si128);
          v21 = _mm_load_si128(&xmmword_7FF7054041F0);
          v22 = _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v20, v20), 212), 212), v21);
          v23 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[1]), si128);
          v24 = _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v23, v23), 212), 212), v21);
          if ( v13 != 4 )
          {
            v25 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[2]), si128);
            v26 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[3]), si128);
            v22 = _mm_add_epi64(
                    v22,
                    _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v25, v25), 212), 212), v21));
            v24 = _mm_add_epi64(
                    v24,
                    _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v26, v26), 212), 212), v21));
            if ( v13 != 8 )
            {
              v27 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[4]), si128);
              v28 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[5]), si128);
              v22 = _mm_add_epi64(
                      v22,
                      _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v27, v27), 212), 212), v21));
              v24 = _mm_add_epi64(
                      v24,
                      _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v28, v28), 212), 212), v21));
              if ( v13 != 12 )
              {
                v29 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[6]), si128);
                v30 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[7]), si128);
                v22 = _mm_add_epi64(
                        v22,
                        _mm_and_si128(
                          _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v29, v29), 212), 212),
                          v21));
                v24 = _mm_add_epi64(
                        v24,
                        _mm_and_si128(
                          _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v30, v30), 212), 212),
                          v21));
                if ( v13 != 16 )
                {
                  v31 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[8]), si128);
                  v32 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[9]), si128);
                  v22 = _mm_add_epi64(
                          v22,
                          _mm_and_si128(
                            _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v31, v31), 212), 212),
                            v21));
                  v24 = _mm_add_epi64(
                          v24,
                          _mm_and_si128(
                            _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v32, v32), 212), 212),
                            v21));
                  if ( v13 != 20 )
                  {
                    v33 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[10]), si128);
                    v34 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[11]), si128);
                    v22 = _mm_add_epi64(
                            v22,
                            _mm_and_si128(
                              _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v33, v33), 212), 212),
                              v21));
                    v24 = _mm_add_epi64(
                            v24,
                            _mm_and_si128(
                              _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v34, v34), 212), 212),
                              v21));
                    if ( v13 != 24 )
                    {
                      v35 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[12]), si128);
                      v36 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a3[13]), si128);
                      v22 = _mm_add_epi64(
                              v22,
                              _mm_and_si128(
                                _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v35, v35), 212), 212),
                                v21));
                      v24 = _mm_add_epi64(
                              v24,
                              _mm_and_si128(
                                _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v36, v36), 212), 212),
                                v21));
                    }
                  }
                }
              }
            }
          }
          v37 = _mm_add_epi64(v22, v24);
          v12 = _mm_add_epi64(_mm_shuffle_epi32(v37, 238), v37).m128i_u64[0];
          goto LABEL_24;
        }
        v12 = 0LL;
        v13 = 0LL;
        do
        {
          v12 += *(a3 + v13++) >= 0xC0;
LABEL_24:
          ;
        }
        while ( a4 != v13 );
      }
      else
      {
        v12 = 0LL;
      }
      v11 += v12;
      v14 = *(a1 + 20);
      if ( v11 < v14 )
        goto LABEL_26;
      goto LABEL_11;
    }
  }
  else
  {
    v11 = a6 + 1;
    v9 = *(a1 + 16);
    v55 = 45;
    v52 = a5;
    if ( (v9 & 0x800000) != 0 )
      goto LABEL_5;
  }
  v7 = 0LL;
  v14 = *(a1 + 20);
  if ( v11 < v14 )
  {
LABEL_26:
    if ( (v9 & 0x1000000) != 0 )
    {
      v39 = v11;
      v54 = *(a1 + 16);
      *(a1 + 16) = v54 & 0x9FE00000 | 0x20000030;
      v40 = *a1;
      v41 = *(a1 + 8);
      v42 = sub_7FF7053F9920(*a1, v41, v55, v7, a4);
      LOBYTE(v7) = 1;
      if ( !v42 )
      {
        v43 = v14 - v39 + 1;
        while ( --v43 )
        {
          if ( (*(v41 + 32))(v40, 48LL) )
            return v7;
        }
        if ( !(*(v41 + 24))(v40, v52, a6) )
        {
          *(a1 + 16) = v54;
          LODWORD(v7) = 0;
        }
      }
    }
    else
    {
      v50 = v11;
      v53 = v14 - v11;
      switch ( (v9 >> 29) & 3 )
      {
        case 0u:
          v38 = 0;
          break;
        case 1u:
        case 3u:
          v38 = v14 - v11;
          break;
        case 2u:
          v38 = (v14 - v11) >> 1;
          break;
      }
      v44 = v9 & 0x1FFFFF;
      v45 = *a1;
      v46 = *(a1 + 8);
      v51 = v38;
      v47 = v38 + 1;
      while ( --v47 )
      {
        if ( (*(v46 + 32))(v45, v44) )
        {
          LOBYTE(v7) = 1;
          return v7;
        }
      }
      v48 = sub_7FF7053F9920(v45, v46, v55, v7, a4);
      LOBYTE(v7) = 1;
      if ( !v48 && !(*(v46 + 24))(v45, v52, a6) )
      {
        LODWORD(v7) = v53 - v51;
        v49 = -1;
        while ( v50 + v51 - v14 + v49 != 0xFFFF )
        {
          ++v49;
          if ( (*(v46 + 32))(v45, v44) )
            goto LABEL_49;
        }
        v49 = v53 - v51;
LABEL_49:
        LOBYTE(v7) = v49 < v7;
      }
    }
    return v7;
  }
LABEL_11:
  v15 = *a1;
  v16 = *(a1 + 8);
  v17 = sub_7FF7053F9920(*a1, v16, v55, v7, a4);
  LOBYTE(v7) = 1;
  if ( !v17 )
    return (*(v16 + 24))(v15, v52, a6);
  return v7;
}
// 7FF7054041E0: using guessed type __int128 xmmword_7FF7054041E0;
// 7FF7054041F0: using guessed type __int128 xmmword_7FF7054041F0;

//----- (00007FF7053F9920) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F9920(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  __int64 v7; // r14
  char v8; // al
  char v9; // dl
  char result; // al

  if ( a3 == 1114112 || (v7 = a1, v8 = (*(a2 + 32))(a1, a3), a1 = v7, v9 = v8, result = 1, !v9) )
  {
    if ( a4 )
      return (*(a2 + 24))(a1, a4, a5);
    else
      return 0;
  }
  return result;
}

//----- (00007FF7053F9980) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053F9980(__int64 *a1, unsigned __int16 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  unsigned __int16 *v4; // r15
  unsigned int v5; // esi
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // rax
  unsigned __int16 *v8; // rbx
  unsigned __int64 v9; // r8
  __int64 v10; // rax
  unsigned __int16 *v11; // r10
  unsigned __int64 v12; // r9
  char v13; // r8
  __int64 *v14; // rdi
  unsigned __int64 v15; // rax
  __m128i si128; // xmm2
  __m128i v17; // xmm0
  __m128i v18; // xmm3
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  __m128i v21; // xmm1
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm4
  __m128i v25; // xmm5
  __m128i v26; // xmm4
  __m128i v27; // xmm5
  __m128i v28; // xmm4
  __m128i v29; // xmm5
  __m128i v30; // xmm4
  __m128i v31; // xmm5
  __m128i v32; // xmm4
  __m128i v33; // xmm5
  __m128i v34; // xmm0
  unsigned __int64 v35; // rax
  int v36; // r13d
  char result; // al
  unsigned int v38; // esi
  __int64 v39; // r15
  __int64 v40; // rdi
  __int16 v41; // r12
  char v42; // cl
  unsigned __int16 v43; // r12
  __int16 v44; // r13
  unsigned __int16 v45; // bx
  unsigned __int16 *v46; // [rsp+20h] [rbp-10h]
  __int16 v47; // [rsp+28h] [rbp-8h]
  __int16 v48; // [rsp+34h] [rbp+4h]

  v3 = a3;
  v4 = a2;
  v5 = *(a1 + 4);
  if ( (v5 & 0x18000000) == 0 )
    return (*(a1[1] + 24))(*a1, v4, v3);
  if ( (v5 & 0x10000000) != 0 )
  {
    if ( *(a1 + 11) )
    {
      v8 = (a2 + a3);
      v9 = 0LL;
      v10 = *(a1 + 11);
      while ( 1 )
      {
        v12 = v9;
        if ( a2 == v8 )
          break;
        v13 = *a2;
        if ( *a2 >= 0 )
        {
          v11 = (a2 + 1);
        }
        else if ( v13 < 0xE0u )
        {
          v11 = a2 + 1;
        }
        else if ( v13 < 0xF0u )
        {
          v11 = (a2 + 3);
        }
        else
        {
          v11 = a2 + 2;
        }
        v9 = v12 + v11 - a2;
        a2 = v11;
        if ( !--v10 )
          goto LABEL_20;
      }
    }
    else
    {
      v9 = 0LL;
LABEL_20:
      v10 = 0LL;
    }
    v6 = *(a1 + 11) - v10;
    v3 = v9;
  }
  else if ( a3 >= 0x20 )
  {
    v14 = a1;
    v15 = sub_7FF7053FAB30(a2, a3);
    a1 = v14;
    v6 = v15;
  }
  else if ( a3 )
  {
    if ( a3 >= 4 )
    {
      v7 = a3 & 0x1C;
      si128 = _mm_load_si128(&xmmword_7FF7054041E0);
      v17 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*a2), si128);
      v18 = _mm_load_si128(&xmmword_7FF7054041F0);
      v19 = _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v17, v17), 212), 212), v18);
      v20 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[1]), si128);
      v21 = _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v20, v20), 212), 212), v18);
      if ( v7 != 4 )
      {
        v22 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[2]), si128);
        v23 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[3]), si128);
        v19 = _mm_add_epi64(
                v19,
                _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v22, v22), 212), 212), v18));
        v21 = _mm_add_epi64(
                v21,
                _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v23, v23), 212), 212), v18));
        if ( v7 != 8 )
        {
          v24 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[4]), si128);
          v25 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[5]), si128);
          v19 = _mm_add_epi64(
                  v19,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v24, v24), 212), 212), v18));
          v21 = _mm_add_epi64(
                  v21,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v25, v25), 212), 212), v18));
          if ( v7 != 12 )
          {
            v26 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[6]), si128);
            v27 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[7]), si128);
            v19 = _mm_add_epi64(
                    v19,
                    _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v26, v26), 212), 212), v18));
            v21 = _mm_add_epi64(
                    v21,
                    _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v27, v27), 212), 212), v18));
            if ( v7 != 16 )
            {
              v28 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[8]), si128);
              v29 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[9]), si128);
              v19 = _mm_add_epi64(
                      v19,
                      _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v28, v28), 212), 212), v18));
              v21 = _mm_add_epi64(
                      v21,
                      _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v29, v29), 212), 212), v18));
              if ( v7 != 20 )
              {
                v30 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[10]), si128);
                v31 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[11]), si128);
                v19 = _mm_add_epi64(
                        v19,
                        _mm_and_si128(
                          _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v30, v30), 212), 212),
                          v18));
                v21 = _mm_add_epi64(
                        v21,
                        _mm_and_si128(
                          _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v31, v31), 212), 212),
                          v18));
                if ( v7 != 24 )
                {
                  v32 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[12]), si128);
                  v33 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[13]), si128);
                  v19 = _mm_add_epi64(
                          v19,
                          _mm_and_si128(
                            _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v32, v32), 212), 212),
                            v18));
                  v21 = _mm_add_epi64(
                          v21,
                          _mm_and_si128(
                            _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v33, v33), 212), 212),
                            v18));
                }
              }
            }
          }
        }
      }
      v34 = _mm_add_epi64(v19, v21);
      v6 = _mm_add_epi64(_mm_shuffle_epi32(v34, 238), v34).m128i_u64[0];
      goto LABEL_31;
    }
    v6 = 0LL;
    v7 = 0LL;
    do
    {
      v6 += *(a2 + v7++) >= 0xC0;
LABEL_31:
      ;
    }
    while ( a3 != v7 );
  }
  else
  {
    v3 = 0LL;
    v6 = 0LL;
  }
  v35 = *(a1 + 10);
  if ( v6 >= v35 )
    return (*(a1[1] + 24))(*a1, v4, v3);
  v47 = *(a1 + 10);
  v46 = v4;
  v48 = v35 - v6;
  switch ( (v5 >> 29) & 3 )
  {
    case 0u:
    case 3u:
      LOWORD(v36) = 0;
      break;
    case 1u:
      LOWORD(v36) = v35 - v6;
      break;
    case 2u:
      v36 = (v35 - v6) >> 1;
      break;
  }
  v38 = v5 & 0x1FFFFF;
  v39 = *a1;
  v40 = a1[1];
  v41 = v36 + 1;
  while ( --v41 )
  {
    if ( (*(v40 + 32))(v39, v38) )
      return 1;
  }
  v42 = (*(v40 + 24))(v39, v46, v3);
  result = 1;
  if ( !v42 )
  {
    v43 = v48 - v36;
    v44 = v6 + v36 - v47;
    v45 = -1;
    while ( v45 + v44 != 0xFFFF )
    {
      ++v45;
      if ( (*(v40 + 32))(v39, v38) )
        return v45 < v43;
    }
    v45 = v43;
    return v45 < v43;
  }
  return result;
}
// 7FF7054041E0: using guessed type __int128 xmmword_7FF7054041E0;
// 7FF7054041F0: using guessed type __int128 xmmword_7FF7054041F0;

//----- (00007FF7053F9DC0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F9DC0(_QWORD *a1)
{
  return (*(a1[1] + 24LL))(*a1);
}

//----- (00007FF7053F9DE0) ----------------------------------------------------
char __fastcall sub_7FF7053F9DE0(
        char *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 a6,
        __int64 a7)
{
  char v9; // al
  char v10; // al
  const char *v11; // rdx
  __int64 v12; // r8
  char *v14; // [rsp+28h] [rbp-8h] BYREF
  char v15; // [rsp+30h] [rbp+0h]
  char v16; // [rsp+31h] [rbp+1h]

  v9 = (*(*(a1 + 1) + 24LL))(*a1);
  v14 = a1;
  v15 = v9;
  v16 = 0;
  sub_7FF7053F8F10(&v14, a4, a5, a6, a7);
  if ( v15 & 1 | ((v16 & 1) == 0) )
  {
    v10 = v15 | v16;
  }
  else
  {
    if ( v14[18] < 0 )
    {
      v11 = asc_7FF705404936;
      v12 = 1LL;
    }
    else
    {
      v11 = asc_7FF705404937;
      v12 = 2LL;
    }
    v10 = (*(*(v14 + 1) + 24LL))(*v14, v11, v12);
  }
  return v10 & 1;
}
// 7FF705404936: using guessed type char asc_7FF705404936;

//----- (00007FF7053F9E90) ----------------------------------------------------
char __fastcall sub_7FF7053F9E90(
        char *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        unsigned __int64 a9,
        __int64 a10,
        __int64 a11)
{
  char v13; // al
  char v14; // al
  const char *v15; // rdx
  __int64 v16; // r8
  char *v18; // [rsp+28h] [rbp-8h] BYREF
  char v19; // [rsp+30h] [rbp+0h]
  char v20; // [rsp+31h] [rbp+1h]

  v13 = (*(*(a1 + 1) + 24LL))(*a1);
  v18 = a1;
  v19 = v13;
  v20 = 0;
  sub_7FF7053F8F10(&v18, a4, a5, a6, a7);
  sub_7FF7053F8F10(&v18, a8, a9, a10, a11);
  if ( v19 & 1 | ((v20 & 1) == 0) )
  {
    v14 = v19 | v20;
  }
  else
  {
    if ( v18[18] < 0 )
    {
      v15 = asc_7FF705404936;
      v16 = 1LL;
    }
    else
    {
      v15 = asc_7FF705404937;
      v16 = 2LL;
    }
    v14 = (*(*(v18 + 1) + 24LL))(*v18, v15, v16);
  }
  return v14 & 1;
}
// 7FF705404936: using guessed type char asc_7FF705404936;

//----- (00007FF7053F9F80) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053F9F80(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned int v5; // ebx
  __int64 v9; // r15
  __int64 v10; // r13
  unsigned __int8 (__fastcall *v11)(__int64, const char *, __int64); // r12
  _QWORD v13[3]; // [rsp+20h] [rbp-30h] BYREF
  _QWORD *v14; // [rsp+38h] [rbp-18h] BYREF
  unsigned __int8 (__fastcall **v15)(_QWORD *, const char *, __int64); // [rsp+40h] [rbp-10h]
  __int64 v16; // [rsp+48h] [rbp-8h]
  char v17; // [rsp+57h] [rbp+7h] BYREF

  v9 = *a1;
  v10 = *(a1 + 1);
  v11 = *(v10 + 24);
  LOBYTE(v5) = 1;
  if ( !(v11)(*a1) )
  {
    if ( a1[18] < 0 )
    {
      if ( v11(v9, asc_7FF70540493A, 2LL) )
        return v5;
      v17 = 1;
      v13[0] = v9;
      v13[1] = v10;
      v13[2] = &v17;
      v16 = *(a1 + 2);
      v14 = v13;
      v15 = &unk_7FF7054048F8;
      if ( (*(a5 + 24))(a4, &v14) || v15[3](v14, asc_7FF705404934, 2LL) )
        return v5;
    }
    else if ( v11(v9, asc_7FF705404939, 1LL) || (*(a5 + 24))(a4, a1) )
    {
      return v5;
    }
    if ( a3 || a1[18] < 0 || !(*(*(a1 + 1) + 24LL))(*a1, asc_7FF70540493C, 1LL) )
      return (*(*(a1 + 1) + 24LL))(*a1, ")..0123456789abcdef", 1LL);
  }
  return v5;
}
// 7FF7053F9FB5: variable 'v5' is possibly undefined
// 7FF7054046B8: using guessed type char asc_7FF7054046B8;
// 7FF705404939: using guessed type char asc_7FF705404939;
// 7FF70540493C: using guessed type char asc_7FF70540493C;

//----- (00007FF7053FA0C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FA0C0(__int64 a1, _QWORD *a2)
{
  char v4; // al

  v4 = (*(a2[1] + 24LL))(*a2, "[called `Option::unwrap()` on a `None` valuelibrary\\core\\src\\panicking.rs", 1LL);
  *a1 = a2;
  *(a1 + 8) = v4;
  *(a1 + 9) = 0;
  return a1;
}
// 7FF7054046F8: using guessed type char asc_7FF7054046F8;

//----- (00007FF7053FA100) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FA100(_QWORD *a1)
{
  return (*(a1[1] + 32LL))(*a1);
}

//----- (00007FF7053FA120) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FA120(_BYTE *a1, unsigned __int64 a2, _QWORD *a3)
{
  _BYTE *v3; // r14
  __int64 v6; // rdi
  __int64 v7; // r13
  unsigned __int8 (__fastcall *v8)(_QWORD, __int64); // rbx
  unsigned __int64 v9; // r15
  _BYTE *v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // r13
  __int64 v13; // rsi
  int v14; // edx
  char v15; // r8
  unsigned int v16; // ebx
  __int64 v17; // rdi
  int v18; // ecx
  int v19; // r9d
  int v20; // edx
  unsigned __int8 (__fastcall *v21)(__int64, _BYTE *, unsigned __int64); // r12
  unsigned __int8 v22; // al
  __int64 v23; // r15
  __int64 v24; // rax
  unsigned __int64 v25; // r12
  __int64 v27; // [rsp+28h] [rbp-38h]
  __int64 v28; // [rsp+30h] [rbp-30h]
  _DWORD v29[3]; // [rsp+38h] [rbp-28h] BYREF
  unsigned __int8 v30; // [rsp+44h] [rbp-1Ch]
  unsigned __int8 v31; // [rsp+45h] [rbp-1Bh]
  __int64 v32; // [rsp+48h] [rbp-18h]
  unsigned __int8 (__fastcall *v33)(__int64, _QWORD); // [rsp+50h] [rbp-10h]
  unsigned __int64 v34; // [rsp+58h] [rbp-8h]
  _BYTE *v35; // [rsp+60h] [rbp+0h]

  v6 = *a3;
  v7 = a3[1];
  v8 = *(v7 + 32);
  LOBYTE(v3) = 1;
  if ( v8(*a3, 34LL) )
    return v3;
  if ( !a2 )
  {
    v25 = 0LL;
    v9 = 0LL;
    goto LABEL_58;
  }
  v28 = v7;
  v33 = v8;
  v32 = v6;
  v27 = -a2;
  v9 = 0LL;
  v35 = a1;
  v10 = a1;
  v34 = a2;
  v11 = a2;
  v12 = 0LL;
  do
  {
    v3 = &v10[v11];
    v13 = 0LL;
    while ( 1 )
    {
      v14 = v10[v13];
      if ( (v14 - 127) < 0xA1u || v14 == 34 || v14 == 92 )
        break;
      if ( v11 == ++v13 )
      {
        v25 = v12 + v11;
        goto LABEL_44;
      }
    }
    v25 = v13 + v12;
    v15 = v10[v13];
    v16 = v15;
    if ( v15 < 0 )
    {
      v18 = v15 & 0x1F;
      v19 = v10[v13 + 1] & 0x3F;
      if ( v15 <= 0xDFu )
      {
        v17 = &v10[v13 + 2];
        v16 = v19 | (v18 << 6);
      }
      else
      {
        v20 = (v19 << 6) | v10[v13 + 2] & 0x3F;
        if ( v15 < 0xF0u )
        {
          v17 = &v10[v13 + 3];
          v16 = (v18 << 12) | v20;
        }
        else
        {
          v17 = &v10[v13 + 4];
          v16 = ((v15 & 7) << 18) | (v20 << 6) | v10[v13 + 3] & 0x3F;
          if ( v16 == 1114112 )
          {
            v12 += v13;
            goto LABEL_43;
          }
        }
      }
    }
    else
    {
      v17 = &v10[v13 + 1];
    }
    sub_7FF7053F89C0(v29, v16, 65537);
    if ( v31 - v30 != 1 )
    {
      if ( v9 > v25 )
        goto LABEL_62;
      if ( v9 )
      {
        if ( v9 >= v34 )
        {
          if ( v9 != v34 )
            goto LABEL_62;
        }
        else if ( v35[v9] <= -65 )
        {
          goto LABEL_62;
        }
      }
      if ( v25 )
      {
        if ( v25 >= v34 )
        {
          if ( v27 + v25 )
LABEL_62:
            sub_7FF7053FE500(v35, v34, v9, v13 + v12, &off_7FF705404A28);
        }
        else if ( v35[v12 + v13] <= -65 )
        {
          goto LABEL_62;
        }
      }
      v21 = *(v28 + 24);
      if ( v21(v32, &v35[v9], v13 + v12 - v9)
        || (v31 < 0x81uLL ? (v22 = v21(v32, v29 + v30, v31 - v30)) : (v22 = v33(v32, v29[0])), v22) )
      {
        LOBYTE(v3) = 1;
        return v3;
      }
      v23 = 1LL;
      if ( v16 >= 0x80 )
      {
        v23 = 2LL;
        if ( v16 >= 0x800 )
          v23 = 4LL - (v16 < 0x10000);
      }
      v9 = v13 + v12 + v23;
    }
    v24 = 1LL;
    if ( v16 >= 0x80 )
    {
      v24 = 2LL;
      if ( v16 >= 0x800 )
        v24 = 4LL - (v16 < 0x10000);
    }
    v12 += v24 + v13;
    v25 = v12;
LABEL_43:
    v10 = v17;
    v3 -= v17;
    v11 = v3;
  }
  while ( v3 );
LABEL_44:
  if ( v9 > v25 )
  {
    a1 = v35;
    goto LABEL_64;
  }
  v6 = v32;
  v7 = v28;
  if ( !v9 )
  {
    v9 = 0LL;
    a1 = v35;
    v8 = v33;
    LOBYTE(v3) = 1;
    if ( v25 )
      goto LABEL_49;
    goto LABEL_54;
  }
  a1 = v35;
  if ( v9 < v34 )
  {
    v8 = v33;
    LOBYTE(v3) = 1;
    if ( v35[v9] > -65 )
      goto LABEL_48;
LABEL_64:
    sub_7FF7053FE500(a1, v34, v9, v25, &off_7FF705404A40);
  }
  v8 = v33;
  LOBYTE(v3) = 1;
  if ( v9 != v34 )
    goto LABEL_64;
LABEL_48:
  if ( !v25 )
  {
LABEL_54:
    v25 = 0LL;
    goto LABEL_58;
  }
LABEL_49:
  if ( v25 >= v34 )
  {
    if ( v25 != v34 )
      goto LABEL_64;
  }
  else if ( a1[v25] <= -65 )
  {
    goto LABEL_64;
  }
LABEL_58:
  if ( !(*(v7 + 24))(v6, &a1[v9], v25 - v9) )
    LODWORD(v3) = (v8)(v6, 34LL);
  return v3;
}
// 7FF7053FA455: variable 'v3' is possibly undefined
// 7FF705404A28: using guessed type _UNKNOWN *off_7FF705404A28;
// 7FF705404A40: using guessed type _UNKNOWN *off_7FF705404A40;

//----- (00007FF7053FA4C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053FA4C0(unsigned __int16 *a1, unsigned __int64 a2, __int64 *a3)
{
  return sub_7FF7053F9980(a3, a1, a2);
}

//----- (00007FF7053FA4E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053FA4E0(unsigned int *a1, __int64 *a2)
{
  __int64 v3; // rsi
  __int64 v4; // r14
  __int64 (__fastcall *v5)(__int64, __int64); // rbx
  char v6; // cl
  char result; // al
  char v8; // cl
  char v9; // cl
  _DWORD v10[3]; // [rsp+20h] [rbp-10h] BYREF
  unsigned __int8 v11; // [rsp+2Ch] [rbp-4h]
  unsigned __int8 v12; // [rsp+2Dh] [rbp-3h]

  v3 = *a2;
  v4 = a2[1];
  v5 = *(v4 + 32);
  v6 = v5(*a2, 39LL);
  result = 1;
  if ( !v6 )
  {
    sub_7FF7053F89C0(v10, *a1, 257);
    if ( v12 < 0x81uLL )
    {
      v9 = (*(v4 + 24))(v3, v10 + v11, v12 - v11);
      result = 1;
      if ( v9 )
        return result;
    }
    else
    {
      v8 = v5(v3, v10[0]);
      result = 1;
      if ( v8 )
        return result;
    }
    return v5(v3, 39LL);
  }
  return result;
}

//----- (00007FF7053FA580) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053FA580(unsigned int *a1, __int64 *a2)
{
  unsigned int v2; // eax
  unsigned __int64 v3; // r8
  int v5; // [rsp+2Ch] [rbp-4h] BYREF

  v2 = *a1;
  if ( (*(a2 + 19) & 0x18) == 0 )
    return (*(a2[1] + 32))(*a2, v2);
  v5 = 0;
  if ( v2 >= 0x80 )
  {
    if ( v2 >= 0x800 )
    {
      if ( v2 >= 0x10000 )
      {
        LOBYTE(v5) = (v2 >> 18) | 0xF0;
        BYTE1(v5) = (v2 >> 12) & 0x3F | 0x80;
        BYTE2(v5) = (v2 >> 6) & 0x3F | 0x80;
        HIBYTE(v5) = v2 & 0x3F | 0x80;
        v3 = 4LL;
      }
      else
      {
        LOBYTE(v5) = (v2 >> 12) | 0xE0;
        BYTE1(v5) = (v2 >> 6) & 0x3F | 0x80;
        BYTE2(v5) = v2 & 0x3F | 0x80;
        v3 = 3LL;
      }
    }
    else
    {
      LOBYTE(v5) = (v2 >> 6) | 0xC0;
      BYTE1(v5) = v2 & 0x3F | 0x80;
      v3 = 2LL;
    }
  }
  else
  {
    LOBYTE(v5) = v2;
    v3 = 1LL;
  }
  return sub_7FF7053F9980(a2, &v5, v3);
}

//----- (00007FF7053FA660) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FA660(unsigned __int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  int v4; // eax
  __int64 v5; // rax
  unsigned __int64 v6; // rdx
  char v7; // r9
  bool v8; // cc
  __int64 result; // rax
  _BYTE v10[17]; // [rsp+AFh] [rbp+2Fh] BYREF

  v3 = *(a2 + 16);
  v4 = v3;
  if ( (v3 & 0x800000) != 0 )
  {
    if ( (v3 & 0x8000000) != 0 )
    {
      v4 = v3 | 0x1000000;
    }
    else
    {
      v4 = v3 | 0x9000000;
      *(a2 + 20) = 18;
    }
  }
  *(a2 + 16) = v4 | 0x800000;
  v5 = 0LL;
  v6 = a1;
  do
  {
    v6 >>= 4;
    v7 = (a1 & 0xF) + 87;
    if ( (a1 & 0xF) < 0xA )
      v7 = (a1 & 0xF) + 48;
    v10[v5--] = v7;
    v8 = a1 <= 0xF;
    a1 = v6;
  }
  while ( !v8 );
  result = sub_7FF7053F9420(
             a2,
             1,
             "0x000102030405060708091011121314151617181920212223242526272829303132333435363738394041424344454647484950515"
             "25354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library\\cor"
             "e\\src\\fmt\\mod.rs",
             2uLL,
             &v10[v5 + 1],
             -v5);
  *(a2 + 16) = v3;
  return result;
}

//----- (00007FF7053FA720) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FA720(unsigned __int8 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rdx
  __int64 i; // r10
  unsigned __int64 v6; // rax
  __int64 result; // rax

  v4 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8uLL) - a2;
  if ( !v4 )
    goto LABEL_10;
  if ( a3 < v4 )
    v4 = a3;
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
    {
      if ( *(a2 + i) == a1 )
        return 1LL;
    }
    v6 = a3 - 16;
    if ( v4 <= a3 - 16 )
      goto LABEL_11;
  }
  else
  {
LABEL_10:
    v6 = a3 - 16;
    v4 = 0LL;
    do
    {
LABEL_11:
      if ( (~(((0x101010101010101LL * a1) ^ *(a2 + v4) | (0x101010101010100LL - ((0x101010101010101LL * a1) ^ *(a2 + v4)))) & ((0x101010101010101LL * a1) ^ *(a2 + v4 + 8) | (0x101010101010100LL - ((0x101010101010101LL * a1) ^ *(a2 + v4 + 8))))) & 0x8080808080808080uLL) != 0 )
        break;
      v4 += 16LL;
    }
    while ( v4 <= v6 );
  }
  result = 0LL;
  if ( a3 != v4 )
  {
    while ( *(a2 + v4) != a1 )
    {
      if ( a3 == ++v4 )
        return result;
    }
    return 1LL;
  }
  return result;
}

//----- (00007FF7053FA810) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FA810(unsigned __int8 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // r8
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r9
  bool v7; // cf
  unsigned __int64 v8; // rax
  _BYTE *v9; // rsi
  __int64 i; // r11
  bool v11; // zf
  unsigned __int64 v12; // r9
  __int64 result; // rax

  v4 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8uLL) - a2;
  v5 = (a3 - v4) & 0xF;
  v6 = 0LL;
  v7 = a3 < v4;
  if ( a3 <= v4 )
    v4 = a3;
  if ( !v7 )
    v6 = v5;
  v8 = a3 - v6;
  if ( a3 < v6 )
    sub_7FF7053FE4D0(a3 - v6, a3, &off_7FF705404A80);
  v9 = (a3 + a2 - 1);
  for ( i = 0LL; v6 != i; ++i )
  {
    v11 = *v9-- == a1;
    if ( v11 )
      return 1LL;
  }
  do
  {
    v12 = v8;
    if ( v8 <= v4 )
      break;
    v8 -= 16LL;
  }
  while ( (~(((0x101010101010101LL * a1) ^ *(a2 + v12 - 16) | (0x101010101010100LL
                                                             - ((0x101010101010101LL * a1) ^ *(a2 + v12 - 16)))) & ((0x101010101010101LL * a1) ^ *(a2 + v12 - 8) | (0x101010101010100LL - ((0x101010101010101LL * a1) ^ *(a2 + v12 - 8))))) & 0x8080808080808080uLL) == 0 );
  if ( v12 > a3 )
    sub_7FF7053FE4E0(v12, a3, &off_7FF705404A98);
  result = 0LL;
  while ( v12 )
  {
    v11 = *(a2 + v12-- - 1) == a1;
    if ( v11 )
      return 1LL;
  }
  return result;
}
// 7FF705404A80: using guessed type char *off_7FF705404A80;
// 7FF705404A98: using guessed type char *off_7FF705404A98;

//----- (00007FF7053FA930) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FA930(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 result; // rax
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rbx
  int v7; // ebp
  char v8; // r11
  unsigned __int64 v9; // r14
  char v10; // bp
  char v11; // bp
  __int64 v12; // rcx

  result = a1;
  v4 = 0LL;
  if ( a3 >= 0xF )
    v4 = a3 - 15;
  if ( !a3 )
  {
LABEL_50:
    *(result + 8) = a2;
    *(result + 16) = a3;
    v12 = 0LL;
    goto LABEL_55;
  }
  v5 = 0LL;
  while ( 1 )
  {
    v6 = *(a2 + v5);
    if ( (v6 & 0x80u) == 0LL )
    {
      if ( ((((a2 + 7) & 0xF8) - a2 - v5) & 7) != 0 )
      {
        ++v5;
      }
      else
      {
        while ( v5 < v4 && ((*(a2 + v5) | *(a2 + v5 + 8)) & 0x8080808080808080uLL) == 0 )
          v5 += 16LL;
        if ( v5 < a3 )
        {
          while ( *(a2 + v5) >= 0 )
          {
            if ( a3 == ++v5 )
              goto LABEL_50;
          }
        }
      }
      goto LABEL_6;
    }
    v7 = byte_7FF705404ACC[v6];
    v8 = 1;
    if ( v7 != 4 )
    {
      if ( v7 == 3 )
      {
        if ( v5 + 1 >= a3 )
          goto LABEL_51;
        v10 = *(a2 + v5 + 1);
        if ( v6 == 224 )
        {
          if ( (v10 & 0xE0) != 0xA0 )
            goto LABEL_52;
        }
        else if ( v6 == 237 )
        {
          if ( v10 > -97 )
            goto LABEL_52;
        }
        else if ( (v6 + 31) >= 0xCu && (LOBYTE(v6) = v6 & 0xFE, v6 != 0xEE) || v10 >= -64 )
        {
LABEL_52:
          LOBYTE(v6) = 1;
          goto LABEL_54;
        }
        v9 = v5 + 2;
        if ( v5 + 2 >= a3 )
          goto LABEL_51;
        if ( *(a2 + v9) > -65 )
          break;
      }
      else
      {
        if ( v7 != 2 )
          goto LABEL_52;
        v9 = v5 + 1;
        if ( v5 + 1 >= a3 )
        {
LABEL_51:
          v8 = 0;
          goto LABEL_54;
        }
        LOBYTE(v6) = 1;
        if ( *(a2 + v9) > -65 )
          goto LABEL_54;
      }
      goto LABEL_5;
    }
    if ( v5 + 1 >= a3 )
      goto LABEL_51;
    v11 = *(a2 + v5 + 1);
    if ( v6 == 240 )
    {
      if ( (v11 + 112) >= 0x30u )
        goto LABEL_52;
    }
    else if ( v6 == 244 )
    {
      if ( v11 > -113 )
        goto LABEL_52;
    }
    else if ( (v6 + 15) > 2u || v11 >= -64 )
    {
      goto LABEL_52;
    }
    v6 = v5 + 2;
    if ( v5 + 2 >= a3 )
      goto LABEL_51;
    if ( *(a2 + v6) > -65 )
      break;
    v9 = v5 + 3;
    if ( v5 + 3 >= a3 )
      goto LABEL_51;
    if ( *(a2 + v9) >= -64 )
    {
      LOBYTE(v6) = 3;
      goto LABEL_54;
    }
LABEL_5:
    v5 = v9 + 1;
LABEL_6:
    if ( v5 >= a3 )
      goto LABEL_50;
  }
  LOBYTE(v6) = 2;
LABEL_54:
  *(result + 8) = v5;
  *(result + 16) = v8;
  *(result + 17) = v6;
  v12 = 1LL;
LABEL_55:
  *result = v12;
  return result;
}
// 7FF705404ACC: using guessed type unsigned __int8 byte_7FF705404ACC[256];

//----- (00007FF7053FAB30) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053FAB30(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v5; // r8
  int v6; // eax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r10
  __m128i v9; // xmm0
  __int64 v10; // rax
  __m128i v11; // xmm2
  __m128i v12; // xmm3
  __m128i v13; // xmm1
  __m128i v14; // xmm4
  __m128i v15; // xmm5
  __m128i v16; // xmm1
  __m128i v17; // xmm0
  __int64 v18; // rdx
  __m128i si128; // xmm2
  __m128i v20; // xmm3
  __m128i v21; // xmm1
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm1
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r9
  __int64 v27; // rdi
  unsigned __int64 v28; // rdi
  unsigned __int64 v29; // r8
  __m128i v30; // xmm1
  unsigned __int64 v31; // rdi
  int v32; // ebx
  const __m128i *v33; // r10
  __int64 v34; // r11
  __int64 v35; // rcx
  unsigned __int64 v36; // r14
  const __m128i *v37; // rbx
  unsigned __int64 v38; // r14
  const __m128i *v39; // rdi
  __m128i v40; // xmm4
  unsigned __int64 v41; // r12
  __m128i v42; // xmm6
  __m128i v43; // xmm2
  __m128i v44; // xmm5
  __m128i v45; // xmm3
  __m128i v46; // xmm3
  __m128i v47; // xmm4
  __m128i v48; // xmm7
  __m128i v49; // xmm2
  __m128i v50; // xmm5
  __m128i v51; // xmm4
  __m128i v52; // xmm10
  __m128i v53; // xmm7
  __m128i v54; // xmm9
  __m128i v55; // xmm8
  __m128i v56; // xmm8
  __m128i v57; // xmm6
  __m128i v58; // xmm9
  __m128i v59; // xmm7
  __m128i v60; // xmm6
  __m128i v61; // xmm6
  const __m128i *v62; // rcx
  __m128i v63; // xmm2
  __m128i v64; // xmm3
  __m128i v65; // xmm2
  __int64 v66; // r11
  unsigned __int64 v67; // rcx

  v2 = ((a1 + 7) & 0xFFFFFFFFFFFFFFF8uLL) - a1;
  v3 = a2 - v2;
  if ( a2 >= v2 && v3 >= 8 )
  {
    v6 = v3 & 7;
    if ( ((a1 + 7) & 0xFFFFFFFFFFFFFFF8uLL) == a1 )
    {
      v7 = 0LL;
    }
    else
    {
      if ( v2 >= 4 )
      {
        v8 = v2 & 4;
        v17 = 0LL;
        v18 = 0LL;
        si128 = _mm_load_si128(&xmmword_7FF7054041E0);
        v20 = _mm_load_si128(&xmmword_7FF7054041F0);
        v21 = 0LL;
        do
        {
          v22 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(a1 + v18)), si128);
          v17 = _mm_add_epi64(
                  v17,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v22, v22), 212), 212), v20));
          v23 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(a1 + v18 + 2)), si128);
          v21 = _mm_add_epi64(
                  v21,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v23, v23), 212), 212), v20));
          v18 += 4LL;
        }
        while ( v8 != v18 );
        v24 = _mm_add_epi64(v21, v17);
        v7 = _mm_add_epi64(_mm_shuffle_epi32(v24, 238), v24).m128i_u64[0];
        goto LABEL_18;
      }
      v7 = 0LL;
      v8 = 0LL;
      do
      {
        v7 += *(a1 + v8++) >= 0xC0;
LABEL_18:
        ;
      }
      while ( v2 != v8 );
    }
    v25 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( (v3 & 7) != 0 )
    {
      v26 = v3 & 0xFFFFFFFFFFFFFFF8uLL;
      v27 = *(v25 + (v3 & 0xFFFFFFFFFFFFFFF8uLL)) >= 0xC0;
      if ( v6 != 1 )
      {
        v27 += *(v25 + v26 + 1) >= 0xC0;
        if ( v6 != 2 )
        {
          v27 += *(v25 + v26 + 2) >= 0xC0;
          if ( v6 != 3 )
          {
            v27 += *(v25 + v26 + 3) >= 0xC0;
            if ( v6 != 4 )
            {
              v27 += *(v25 + v26 + 4) >= 0xC0;
              if ( v6 != 5 )
              {
                v27 += *(v25 + v26 + 5) >= 0xC0;
                if ( v6 != 6 )
                  v27 += *(v25 + v26 + 6) >= 0xC0;
              }
            }
          }
        }
      }
    }
    else
    {
      v27 = 0LL;
    }
    v28 = v7 + v27;
    v29 = v3 >> 3;
    v30 = _mm_load_si128(&xmmword_7FF705404200);
    while ( 1 )
    {
      result = v28;
      if ( !v29 )
        return result;
      v33 = v25;
      v34 = 192LL;
      if ( v29 < 0xC0 )
        v34 = v29;
      if ( v29 < 4 )
      {
        v31 = 0LL;
      }
      else
      {
        v35 = v34 >> 2;
        v36 = (v35 - 1) & 0x7FFFFFFFFFFFFFFLL;
        if ( v36 >= 3 )
        {
          v38 = v36 + 1;
          v37 = &v33[2 * (v38 & 0xFFFFFFFFFFFFFFFCuLL)];
          v39 = v33 + 4;
          v40 = 0LL;
          v41 = v38 & 0xFFFFFFFFFFFFFFFCuLL;
          v42 = 0LL;
          do
          {
            v43 = _mm_loadu_si128(v39 - 4);
            v44 = _mm_loadu_si128(v39 - 2);
            v45 = _mm_unpacklo_epi64(v43, v44);
            v46 = _mm_add_epi64(
                    _mm_and_si128(
                      _mm_or_si128(_mm_srli_epi64(v45, 6u), _mm_srli_epi64(_mm_xor_si128(v45, -1LL), 7u)),
                      v30),
                    v40);
            v47 = _mm_loadu_si128(v39 - 3);
            v48 = _mm_loadu_si128(v39 - 1);
            v49 = _mm_unpackhi_epi64(v43, v44);
            v50 = _mm_unpacklo_epi64(v47, v48);
            v51 = _mm_unpackhi_epi64(v47, v48);
            v52 = _mm_loadu_si128(v39 + 3);
            v53 = _mm_loadu_si128(v39 + 2);
            v54 = _mm_loadu_si128(v39);
            v55 = _mm_unpacklo_epi64(v54, v53);
            v56 = _mm_add_epi64(
                    _mm_and_si128(
                      _mm_or_si128(_mm_srli_epi64(v55, 6u), _mm_srli_epi64(_mm_xor_si128(v55, -1LL), 7u)),
                      v30),
                    v42);
            v57 = _mm_loadu_si128(v39 + 1);
            v58 = _mm_unpackhi_epi64(v54, v53);
            v59 = _mm_unpacklo_epi64(v57, v52);
            v60 = _mm_unpackhi_epi64(v57, v52);
            v40 = _mm_add_epi64(
                    _mm_and_si128(
                      _mm_or_si128(_mm_srli_epi64(v51, 6u), _mm_srli_epi64(_mm_xor_si128(v51, -1LL), 7u)),
                      v30),
                    _mm_add_epi64(
                      _mm_add_epi64(
                        _mm_and_si128(
                          _mm_or_si128(_mm_srli_epi64(v50, 6u), _mm_srli_epi64(_mm_xor_si128(v50, -1LL), 7u)),
                          v30),
                        _mm_and_si128(
                          _mm_or_si128(_mm_srli_epi64(v49, 6u), _mm_srli_epi64(_mm_xor_si128(v49, -1LL), 7u)),
                          v30)),
                      v46));
            v42 = _mm_add_epi64(
                    _mm_and_si128(
                      _mm_or_si128(_mm_srli_epi64(v60, 6u), _mm_srli_epi64(_mm_xor_si128(v60, -1LL), 7u)),
                      v30),
                    _mm_add_epi64(
                      _mm_add_epi64(
                        _mm_and_si128(
                          _mm_or_si128(_mm_srli_epi64(v59, 6u), _mm_srli_epi64(_mm_xor_si128(v59, -1LL), 7u)),
                          v30),
                        _mm_and_si128(
                          _mm_or_si128(_mm_srli_epi64(v58, 6u), _mm_srli_epi64(_mm_xor_si128(v58, -1LL), 7u)),
                          v30)),
                      v56));
            v39 += 8;
            v41 -= 4LL;
          }
          while ( v41 );
          v61 = _mm_add_epi64(v42, v40);
          v31 = _mm_add_epi64(_mm_shuffle_epi32(v61, 238), v61).m128i_u64[0];
          if ( v38 == (v38 & 0xFFFFFFFFFFFFFFFCuLL) )
            goto LABEL_30;
        }
        else
        {
          v31 = 0LL;
          v37 = v33;
        }
        v62 = (v33 + (32 * v35));
        do
        {
          v63 = _mm_loadu_si128(v37);
          v64 = _mm_loadu_si128(v37 + 1);
          v65 = _mm_add_epi64(
                  _mm_and_si128(
                    _mm_or_si128(_mm_srli_epi64(v63, 6u), _mm_srli_epi64(_mm_xor_si128(v63, -1LL), 7u)),
                    v30),
                  _mm_and_si128(
                    _mm_or_si128(_mm_srli_epi64(v64, 6u), _mm_srli_epi64(_mm_xor_si128(v64, -1LL), 7u)),
                    v30));
          v31 += _mm_add_epi64(_mm_shuffle_epi32(v65, 238), v65).m128i_u64[0];
          v37 += 2;
        }
        while ( v37 != v62 );
      }
LABEL_30:
      v25 = v33 + 8 * v34;
      v29 -= v34;
      v32 = v34 & 3;
      v28 = result + ((0x1000100010001LL * ((v31 & 0xFF00FF00FF00FFLL) + ((v31 >> 8) & 0xFF00FF00FF00FFLL))) >> 48);
      if ( (v34 & 3) != 0 )
      {
        v66 = v34 & 0xFC;
        v67 = ((~v33->m128i_i64[v66] >> 7) | (v33->m128i_i64[v66] >> 6)) & 0x101010101010101LL;
        if ( v32 != 1 )
        {
          v67 += ((~v33->m128i_i64[v66 + 1] >> 7) | (v33->m128i_i64[v66 + 1] >> 6)) & 0x101010101010101LL;
          if ( v32 != 2 )
            v67 += ((~v33[1].m128i_i64[v66] >> 7) | (v33[1].m128i_i64[v66] >> 6)) & 0x101010101010101LL;
        }
        return v28 + ((0x1000100010001LL * ((v67 & 0xFF00FF00FF00FFLL) + ((v67 >> 8) & 0x700FF00FF00FFLL))) >> 48);
      }
    }
  }
  if ( !a2 )
    return 0LL;
  if ( a2 >= 4 )
  {
    v5 = a2 & 0xFFFFFFFFFFFFFFFCuLL;
    v9 = 0LL;
    v10 = 0LL;
    v11 = _mm_load_si128(&xmmword_7FF7054041E0);
    v12 = _mm_load_si128(&xmmword_7FF7054041F0);
    v13 = 0LL;
    do
    {
      v14 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(a1 + v10)), v11);
      v9 = _mm_add_epi64(
             v9,
             _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v14, v14), 212), 212), v12));
      v15 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(a1 + v10 + 2)), v11);
      v13 = _mm_add_epi64(
              v13,
              _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v15, v15), 212), 212), v12));
      v10 += 4LL;
    }
    while ( v5 != v10 );
    v16 = _mm_add_epi64(v13, v9);
    result = _mm_add_epi64(_mm_shuffle_epi32(v16, 238), v16).m128i_u64[0];
    goto LABEL_47;
  }
  result = 0LL;
  v5 = 0LL;
  do
  {
    result += *(a1 + v5++) >= 0xC0;
LABEL_47:
    ;
  }
  while ( a2 != v5 );
  return result;
}
// 7FF7054041E0: using guessed type __int128 xmmword_7FF7054041E0;
// 7FF7054041F0: using guessed type __int128 xmmword_7FF7054041F0;
// 7FF705404200: using guessed type __int128 xmmword_7FF705404200;

//----- (00007FF7053FB220) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FB220(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, unsigned __int64 a5)
{
  __int64 v6; // rbx
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rax
  __int64 v10; // rdx
  size_t v11; // r12
  size_t v12; // r15
  unsigned __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // r10
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // rcx
  __int64 v20; // rcx
  unsigned __int8 v21; // cl
  __int64 v22; // r8
  __int64 v23; // r10
  __int64 v24; // r11
  __int64 v25; // r10
  __int64 v26; // r9
  __int64 v27; // rcx
  unsigned __int8 v28; // cl
  __int64 v29; // r9
  __int64 v30; // r11
  __int64 v31; // r9
  __int64 v32; // r10
  __int64 v33; // r11
  unsigned __int64 v34; // rdx
  __int64 v35; // r15
  unsigned __int64 v36; // rcx
  unsigned __int64 v37; // rax
  unsigned __int8 v38; // al
  __int64 v39; // r10
  __int64 v40; // rax
  __int64 v41; // rbx
  __int64 v42; // r11
  __int64 v43; // r15
  unsigned __int64 v44; // r10
  __int64 v45; // r9
  unsigned __int8 v46; // al
  __int64 v47; // r11
  __int64 v48; // rax
  size_t v49; // rcx
  __int64 v50; // r15
  __int64 v51; // r9
  char *v52; // rdx
  __int64 v53; // r8
  __int64 v54; // r8
  __int64 v55; // rdx
  char *v56; // r9
  __int64 v57; // r10
  __int64 v59; // [rsp+28h] [rbp-8h]

  v6 = a3;
  if ( a5 )
  {
    if ( a5 != 1 )
    {
      v16 = 1LL;
      v9 = 0LL;
      v17 = 1LL;
      v18 = 0LL;
      v8 = 1LL;
      do
      {
        v20 = v18 + v9;
        if ( v18 + v9 >= a5 )
          goto LABEL_89;
        v21 = a4[v20];
        if ( a4[v16] < v21 )
        {
          v19 = v17 + v18 + 1;
          v8 = v19 - v9;
          v18 = 0LL;
        }
        else if ( a4[v16] == v21 )
        {
          v22 = v18 + 1;
          v23 = v22;
          if ( v22 == v8 )
            v23 = 0LL;
          else
            v22 = 0LL;
          v19 = v17 + v22;
          v18 = v23;
        }
        else
        {
          v19 = v17 + 1;
          v8 = 1LL;
          v18 = 0LL;
          v9 = v17;
        }
        v16 = v19 + v18;
        v17 = v19;
      }
      while ( v19 + v18 < a5 );
      v24 = 1LL;
      v11 = 0LL;
      v25 = 1LL;
      v26 = 0LL;
      v10 = 1LL;
      while ( 1 )
      {
        v20 = v26 + v11;
        if ( v26 + v11 >= a5 )
          break;
        v28 = a4[v20];
        if ( a4[v24] > v28 )
        {
          v27 = v25 + v26 + 1;
          v10 = v27 - v11;
          v26 = 0LL;
        }
        else if ( a4[v24] == v28 )
        {
          v29 = v26 + 1;
          v30 = v29;
          if ( v29 == v10 )
            v30 = 0LL;
          else
            v29 = 0LL;
          v27 = v25 + v29;
          v26 = v30;
        }
        else
        {
          v27 = v25 + 1;
          v10 = 1LL;
          v26 = 0LL;
          v11 = v25;
        }
        v24 = v27 + v26;
        v25 = v27;
        if ( v27 + v26 >= a5 )
          goto LABEL_4;
      }
LABEL_89:
      sub_7FF7053FE234(v20, a5, &off_7FF705404C20);
    }
    v8 = 1LL;
    v9 = 0LL;
    v10 = 1LL;
    v11 = 0LL;
LABEL_4:
    if ( v9 <= v11 )
      v8 = v10;
    else
      v11 = v9;
    v12 = a5 - v11;
    if ( a5 < v11 )
      sub_7FF7053FE4E0(v11, a5, &off_7FF705404BF0);
    v13 = v11 + v8;
    if ( __CFADD__(v11, v8) )
      sub_7FF7053FE4F0(v8, v13, &off_7FF705404C08);
    if ( v13 > a5 )
      sub_7FF7053FE4E0(v11 + v8, a5, &off_7FF705404C08);
    if ( !memcmp(a4, &a4[v8], v11) )
    {
      v59 = v6;
      v31 = 1LL;
      v32 = 0LL;
      v33 = 1LL;
      v34 = 0LL;
      do
      {
        if ( v33 + v32 >= a5 )
          break;
        v36 = ~v33 + a5 - v32;
        if ( v36 >= a5 )
LABEL_90:
          sub_7FF7053FE234(v36, a5, &off_7FF705404C38);
        v37 = a5 + ~v32 - v34;
        if ( v37 >= a5 )
LABEL_91:
          sub_7FF7053FE234(v37, a5, &off_7FF705404C50);
        v35 = v33 + 1;
        v38 = a4[v37];
        if ( a4[v36] < v38 )
        {
          v35 = v32 + v33 + 1;
          v31 = v35 - v34;
          v32 = 0LL;
        }
        else if ( a4[v36] == v38 )
        {
          v39 = v32 + 1;
          v40 = v39;
          if ( v39 == v31 )
            v40 = 0LL;
          else
            v39 = 0LL;
          v35 = v33 + v39;
          v32 = v40;
        }
        else
        {
          v31 = 1LL;
          v32 = 0LL;
          v34 = v33;
        }
        v33 = v35;
      }
      while ( v31 != v8 );
      v41 = 1LL;
      v42 = 0LL;
      v43 = 1LL;
      v44 = 0LL;
      while ( v43 + v42 < a5 )
      {
        v36 = ~v43 + a5 - v42;
        if ( v36 >= a5 )
          goto LABEL_90;
        v37 = a5 + ~v42 - v44;
        if ( v37 >= a5 )
          goto LABEL_91;
        v45 = v43 + 1;
        v46 = a4[v37];
        if ( a4[v36] > v46 )
        {
          v45 = v42 + v43 + 1;
          v41 = v45 - v44;
          v42 = 0LL;
        }
        else if ( a4[v36] == v46 )
        {
          v47 = v42 + 1;
          v48 = v47;
          if ( v47 == v41 )
            v48 = 0LL;
          else
            v47 = 0LL;
          v45 = v43 + v47;
          v42 = v48;
        }
        else
        {
          v41 = 1LL;
          v42 = 0LL;
          v44 = v43;
        }
        v43 = v45;
        if ( v41 == v8 )
          break;
      }
      if ( v44 > v34 )
        v34 = v44;
      v49 = a5 - v34;
      if ( v8 )
      {
        v6 = v59;
        v50 = a2;
        if ( v8 >= 4 )
        {
          v14 = 0LL;
          v51 = 0LL;
          do
          {
            v14 |= (1LL << a4[v51]) | (1LL << a4[v51 + 1]) | (1LL << a4[v51 + 2]) | (1LL << a4[v51 + 3]);
            v51 += 4LL;
          }
          while ( (v8 & 0xFFFFFFFFFFFFFFFCuLL) != v51 );
        }
        else
        {
          v14 = 0LL;
          v51 = 0LL;
        }
        if ( (v8 & 3) != 0 )
        {
          v56 = &a4[v51];
          v54 = 0LL;
          v57 = 0LL;
          do
            v14 |= 1LL << v56[v57++];
          while ( (v8 & 3) != v57 );
        }
        else
        {
          v54 = 0LL;
        }
        v55 = a5;
      }
      else
      {
        v54 = 0LL;
        v55 = a5;
        v14 = 0LL;
        v8 = 0LL;
        v6 = v59;
        v50 = a2;
      }
    }
    else
    {
      if ( a5 - 1 >= 3 )
      {
        v14 = 0LL;
        v15 = 0LL;
        do
        {
          v14 |= (1LL << a4[v15]) | (1LL << a4[v15 + 1]) | (1LL << a4[v15 + 2]) | (1LL << a4[v15 + 3]);
          v15 += 4LL;
        }
        while ( (a5 & 0xFFFFFFFFFFFFFFFCuLL) != v15 );
      }
      else
      {
        v14 = 0LL;
        v15 = 0LL;
      }
      if ( (a5 & 3) != 0 )
      {
        v52 = &a4[v15];
        v53 = 0LL;
        do
          v14 |= 1LL << v52[v53++];
        while ( (a5 & 3) != v53 );
      }
      if ( v12 <= v11 )
        v12 = v11;
      v54 = -1LL;
      v55 = -1LL;
      v8 = v12 + 1;
      v49 = v11;
      v50 = a2;
    }
    *(a1 + 72) = v50;
    *(a1 + 80) = v6;
    *(a1 + 88) = a4;
    *(a1 + 96) = a5;
    *a1 = 1LL;
    *(a1 + 8) = v11;
    *(a1 + 16) = v49;
    *(a1 + 24) = v8;
    *(a1 + 32) = v14;
    *(a1 + 40) = 0LL;
    *(a1 + 48) = v6;
    *(a1 + 56) = v54;
    *(a1 + 64) = v55;
  }
  else
  {
    *(a1 + 72) = a2;
    *(a1 + 80) = a3;
    *(a1 + 88) = a4;
    *(a1 + 96) = 0LL;
    *a1 = 0LL;
    *(a1 + 16) = a3;
    *(a1 + 24) = 257;
    *(a1 + 26) = 0;
  }
  return a1;
}
// 7FF705404BF0: using guessed type char *off_7FF705404BF0;
// 7FF705404C08: using guessed type char *off_7FF705404C08;
// 7FF705404C20: using guessed type char *off_7FF705404C20;
// 7FF705404C38: using guessed type char *off_7FF705404C38;
// 7FF705404C50: using guessed type char *off_7FF705404C50;

//----- (00007FF7053FB760) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FB760(
        _BYTE *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5)
{
  __int64 v5; // r10
  __int64 v6; // r11
  __int64 v7; // rsi
  unsigned __int64 *v8; // r9
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // r10
  unsigned __int64 v11; // r11
  unsigned __int64 v12; // r8
  __int64 v13; // r8
  char v14; // r10
  __int64 v15; // rax
  int v16; // eax
  int v17; // r11d
  int v18; // r9d
  unsigned int v19; // ecx
  unsigned __int64 v20; // [rsp+28h] [rbp-58h] BYREF
  _QWORD v21[2]; // [rsp+30h] [rbp-50h] BYREF
  _QWORD v22[2]; // [rsp+40h] [rbp-40h] BYREF
  _QWORD v23[2]; // [rsp+50h] [rbp-30h] BYREF
  unsigned __int64 *v24; // [rsp+60h] [rbp-20h] BYREF
  __int64 (__fastcall *v25)(unsigned __int64 *, __int64); // [rsp+68h] [rbp-18h]
  _QWORD *v26; // [rsp+70h] [rbp-10h]
  void *v27; // [rsp+78h] [rbp-8h]
  _QWORD *v28; // [rsp+80h] [rbp+0h]
  void *v29; // [rsp+88h] [rbp+8h]
  _QWORD *v30; // [rsp+90h] [rbp+10h]
  char (__fastcall *v31)(__int64, __int64 *); // [rsp+98h] [rbp+18h]
  _QWORD *v32; // [rsp+A0h] [rbp+20h]
  char (__fastcall *v33)(__int64, __int64 *); // [rsp+A8h] [rbp+28h]
  char **v34; // [rsp+B0h] [rbp+30h] BYREF
  __int64 v35; // [rsp+B8h] [rbp+38h]
  unsigned __int64 **v36; // [rsp+C0h] [rbp+40h]
  __int64 v37; // [rsp+C8h] [rbp+48h]
  __int64 v38; // [rsp+D0h] [rbp+50h]
  unsigned __int64 v39; // [rsp+E0h] [rbp+60h] BYREF
  unsigned __int64 v40; // [rsp+E8h] [rbp+68h] BYREF
  unsigned int v41; // [rsp+F4h] [rbp+74h] BYREF

  v40 = a3;
  v39 = a4;
  if ( a2 < 0x101 )
  {
    v7 = 1LL;
    v6 = 0LL;
    v5 = a2;
  }
  else
  {
    v5 = 256LL;
    if ( a1[256] <= -65 )
    {
      v5 = 255LL;
      if ( a1[255] <= -65 )
        v5 = (a1[254] >= 0xC0) + 253LL;
    }
    if ( a1[v5] <= -65 )
      sub_7FF7053FE500(a1, a2, 0, v5, a5);
    v6 = 5LL;
    v7 = &unk_7FF705404C68;
  }
  v23[0] = a1;
  v23[1] = v5;
  v22[0] = v7;
  v22[1] = v6;
  if ( a3 > a2 )
  {
LABEL_11:
    v21[0] = a3;
    v24 = v21;
    v25 = sub_7FF7053FC390;
    v26 = v23;
    v27 = sub_7FF7053FC5C0;
    v28 = v22;
    v29 = sub_7FF7053FC5C0;
    v34 = &off_7FF705404D78;
    v35 = 3LL;
    v38 = 0LL;
    v36 = &v24;
    v37 = 3LL;
    sub_7FF7053FE110(&v34, a5);
  }
  if ( a4 > a2 )
  {
    a3 = a4;
    goto LABEL_11;
  }
  if ( a3 > a4 )
  {
    v24 = &v40;
    v25 = sub_7FF7053FC390;
    v26 = &v39;
    v27 = sub_7FF7053FC390;
    v28 = v23;
    v29 = sub_7FF7053FC5C0;
    v30 = v22;
    v31 = sub_7FF7053FC5C0;
    v34 = &off_7FF705404C90;
    v35 = 4LL;
    v38 = 0LL;
    v36 = &v24;
    v37 = 4LL;
    sub_7FF7053FE110(&v34, a5);
  }
  if ( a3 != 0 && a3 < a2 )
  {
    v8 = &v40;
    if ( a1[a3] >= -64 )
      v8 = &v39;
    a4 = *v8;
  }
  v20 = a4;
  v9 = a2;
  if ( a4 < a2 )
  {
    v10 = 0LL;
    if ( a4 >= 3 )
      v10 = a4 - 3;
    v11 = a4 + 1;
    v12 = a4 + 1 - v10;
    if ( a4 + 1 < v10 )
      sub_7FF7053FE4F0(v10, a4 + 1, &off_7FF705404DA8);
    if ( a1[a4] <= -65 )
    {
      if ( a1[v11 - 2] <= -65 )
      {
        if ( a1[v11 - 3] <= -65 )
          v13 = (a1[v11 - 4] >= 0xC0) + v12 - 5;
        else
          v13 = v12 - 3;
      }
      else
      {
        v13 = v12 - 2;
      }
    }
    else
    {
      v13 = a4 - v10;
    }
    v9 = v10 + v13;
  }
  if ( !v9 )
  {
LABEL_32:
    if ( v9 == a2 )
      goto LABEL_33;
    v14 = a1[v9];
    if ( v14 < 0 )
    {
      v16 = v14 & 0x1F;
      v17 = a1[v9 + 1] & 0x3F;
      if ( v14 <= 0xDFu )
      {
        v19 = v17 | (v16 << 6);
      }
      else
      {
        v18 = (v17 << 6) | a1[v9 + 2] & 0x3F;
        if ( v14 < 0xF0u )
        {
          v19 = (v16 << 12) | v18;
        }
        else
        {
          v19 = ((v14 & 7) << 18) | (v18 << 6) | a1[v9 + 3] & 0x3F;
          if ( v19 == 1114112 )
LABEL_33:
            sub_7FF7053FE090(a5);
        }
      }
      v41 = v19;
      v15 = 1LL;
      if ( v19 >= 0x80 )
      {
        v15 = 2LL;
        if ( v19 >= 0x800 )
          v15 = 4LL - (v19 < 0x10000);
      }
    }
    else
    {
      v41 = v14;
      v15 = 1LL;
    }
    v21[0] = v9;
    v21[1] = v9 + v15;
    v24 = &v20;
    v25 = sub_7FF7053FC390;
    v26 = &v41;
    v27 = sub_7FF7053FA4E0;
    v28 = v21;
    v29 = sub_7FF7053F87A0;
    v30 = v23;
    v31 = sub_7FF7053FC5C0;
    v32 = v22;
    v33 = sub_7FF7053FC5C0;
    v34 = &off_7FF705404D10;
    v35 = 5LL;
    v38 = 0LL;
    v36 = &v24;
    v37 = 5LL;
    sub_7FF7053FE110(&v34, a5);
  }
  if ( v9 >= a2 )
  {
    if ( v9 == a2 )
      goto LABEL_32;
  }
  else if ( a1[v9] > -65 )
  {
    goto LABEL_32;
  }
  sub_7FF7053FE500(a1, a2, v9, a2, a5);
}
// 7FF7053FE500: using guessed type void __fastcall __noreturn sub_7FF7053FE500(_DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 7FF705404C90: using guessed type char *off_7FF705404C90;
// 7FF705404D10: using guessed type char *off_7FF705404D10;
// 7FF705404D78: using guessed type char *off_7FF705404D78;
// 7FF705404DA8: using guessed type char *off_7FF705404DA8;

//----- (00007FF7053FBB20) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053FBB20(int a1, _BYTE *a2, __int64 a3, __int64 a4, unsigned __int64 a5, char *a6, __int64 a7)
{
  _BYTE *v7; // rax
  char *v8; // rdi
  _BYTE *v9; // r8
  unsigned __int64 v10; // r11
  _BYTE *v11; // r15
  __int64 v12; // r14
  unsigned __int64 v13; // r10
  __int64 v14; // r11
  __int64 v15; // r15
  char *v17; // rsi
  int v18; // edx
  int v19; // r8d
  char v20; // al

  v7 = a2;
  v8 = a6;
  v9 = &a2[2 * a3];
  v10 = 0LL;
  while ( 1 )
  {
    v11 = v7;
    v12 = v7[1];
    v7 += 2;
    v13 = v10 + v12;
    if ( *v11 == BYTE1(a1) )
      break;
    if ( *v11 > BYTE1(a1) )
      goto LABEL_11;
LABEL_10:
    v10 = v13;
    if ( v7 == v9 )
    {
LABEL_11:
      v17 = &a6[a7];
      a1 = a1;
      v20 = 1;
      while ( 1 )
      {
        v18 = *v8;
        if ( v18 < 0 )
        {
          if ( v8 + 1 == v17 )
            sub_7FF7053FE090(&off_7FF705404DE8);
          v19 = v8[1];
          v8 += 2;
          a1 -= v19 | ((v18 & 0x7F) << 8);
          if ( a1 < 0 )
            return v20 & 1;
        }
        else
        {
          ++v8;
          a1 -= v18;
          if ( a1 < 0 )
            return v20 & 1;
        }
        v20 ^= 1u;
        if ( v8 == v17 )
          return v20 & 1;
      }
    }
  }
  if ( v13 < v10 )
    sub_7FF7053FE4F0(v10, v10 + v12, &off_7FF705404E00);
  if ( v13 > a5 )
    sub_7FF7053FE4E0(v10 + v12, a5, &off_7FF705404E00);
  v14 = a4 + v10;
  v15 = 0LL;
  do
  {
    if ( v12 == v15 )
      goto LABEL_10;
  }
  while ( *(v14 + v15++) != a1 );
  v20 = 0;
  return v20 & 1;
}
// 7FF705404DE8: using guessed type char *off_7FF705404DE8;
// 7FF705404E00: using guessed type char *off_7FF705404E00;

//----- (00007FF7053FBC50) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053FBC50(unsigned int a1)
{
  char result; // al
  __m128i v2; // xmm0
  __m128i v3; // xmm1
  __m128i v4; // xmm2
  __m128i si128; // xmm0

  if ( a1 < 0x20 )
    return 0;
  result = 1;
  if ( a1 >= 0x7F )
  {
    if ( a1 >= 0x10000 )
    {
      if ( a1 >= 0x20000 )
      {
        v2 = _mm_cvtsi32_si128(a1);
        v3 = _mm_add_epi32(_mm_shuffle_epi32(v2, 0), xmmword_7FF705404210);
        v4 = _mm_unpacklo_epi64(
               _mm_add_epi32(_mm_shuffle_epi32(v2, 80), xmmword_7FF705404220),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(a1 - 917760), v2));
        si128 = _mm_load_si128(&xmmword_7FF705404230);
        return _mm_movemask_epi8(
                 _mm_packs_epi32(
                   _mm_cmpgt_epi32(_mm_xor_si128(v3, si128), xmmword_7FF705404240),
                   _mm_cmpgt_epi32(_mm_xor_si128(v4, si128), xmmword_7FF705404250))) == 0
            && (a1 & 0x1FFFE0) != 173792
            && (a1 & 0x1FFFFE) != 178206;
      }
      else
      {
        return sub_7FF7053FBB20(a1, byte_7FF705404E18, 44LL, &unk_7FF705404E70, 0xD0uLL, asc_7FF705404F40, 486LL);
      }
    }
    else
    {
      return sub_7FF7053FBB20(a1, byte_7FF705405126, 40LL, &unk_7FF705405176, 0x122uLL, byte_7FF705405298, 297LL);
    }
  }
  return result;
}
// 7FF705404210: using guessed type __int128 xmmword_7FF705404210;
// 7FF705404220: using guessed type __int128 xmmword_7FF705404220;
// 7FF705404230: using guessed type __int128 xmmword_7FF705404230;
// 7FF705404240: using guessed type __int128 xmmword_7FF705404240;
// 7FF705404250: using guessed type __int128 xmmword_7FF705404250;
// 7FF705404E18: using guessed type _BYTE byte_7FF705404E18[88];
// 7FF705405126: using guessed type _BYTE byte_7FF705405126[80];

//----- (00007FF7053FBD80) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053FBD80(unsigned __int64 a1, unsigned __int64 a2)
{
  return ((a2 - 1) ^ a2) > a2 - 1 && a1 <= 0x8000000000000000uLL - a2;
}

//----- (00007FF7053FBDB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FBDB0(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int8 v2; // cl
  __int64 v3; // rax
  unsigned __int8 v4; // r8
  char v5; // r10
  bool v6; // cc
  char v8; // [rsp+AFh] [rbp+2Fh]
  __int64 savedregs; // [rsp+B0h] [rbp+30h] BYREF

  v2 = *a1;
  v3 = 0LL;
  v4 = v2;
  do
  {
    v4 >>= 4;
    v5 = (v2 & 0xF) + 87;
    if ( (v2 & 0xFu) < 0xA )
      v5 = (v2 & 0xF) + 48;
    *(&v8 + v3--) = v5;
    v6 = v2 <= 0xFu;
    v2 = v4;
  }
  while ( !v6 );
  return sub_7FF7053F9420(
           a2,
           1,
           "0x00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525"
           "354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library\\core\\src\\fmt\\mod.rs",
           2uLL,
           &savedregs + v3,
           -v3);
}

//----- (00007FF7053FBE40) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FBE40(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int8 v2; // cl
  __int64 v3; // rax
  unsigned __int8 v4; // r8
  char v5; // r10
  bool v6; // cc
  char v8; // [rsp+AFh] [rbp+2Fh]
  __int64 savedregs; // [rsp+B0h] [rbp+30h] BYREF

  v2 = *a1;
  v3 = 0LL;
  v4 = v2;
  do
  {
    v4 >>= 4;
    v5 = (v2 & 0xF) + 55;
    if ( (v2 & 0xFu) < 0xA )
      v5 = (v2 & 0xF) + 48;
    *(&v8 + v3--) = v5;
    v6 = v2 <= 0xFu;
    v2 = v4;
  }
  while ( !v6 );
  return sub_7FF7053F9420(
           a2,
           1,
           "0x00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525"
           "354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library\\core\\src\\fmt\\mod.rs",
           2uLL,
           &savedregs + v3,
           -v3);
}

//----- (00007FF7053FBED0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053FBED0(_WORD *a1, __int64 a2)
{
  __int64 v2; // rax
  unsigned __int16 v3; // r8
  char v4; // r10
  char v6; // [rsp+AFh] [rbp+2Fh]
  __int64 savedregs; // [rsp+B0h] [rbp+30h] BYREF

  LOWORD(a1) = *a1;
  v2 = 0LL;
  do
  {
    v3 = a1;
    LODWORD(a1) = a1 >> 4;
    v4 = (v3 & 0xF) + 87;
    if ( (v3 & 0xFu) < 0xA )
      v4 = (v3 & 0xF) + 48;
    *(&v6 + v2--) = v4;
  }
  while ( v3 > 0xFu );
  return sub_7FF7053F9420(
           a2,
           1,
           "0x00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525"
           "354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library\\core\\src\\fmt\\mod.rs",
           2uLL,
           &savedregs + v2,
           -v2);
}

//----- (00007FF7053FBF60) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FBF60(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rcx
  __int64 v3; // rax
  unsigned __int64 v4; // r8
  char v5; // r10
  bool v6; // cc
  char v8; // [rsp+AFh] [rbp+2Fh]
  __int64 savedregs; // [rsp+B0h] [rbp+30h] BYREF

  v2 = *a1;
  v3 = 0LL;
  v4 = v2;
  do
  {
    v4 >>= 4;
    v5 = (v2 & 0xF) + 87;
    if ( (v2 & 0xF) < 0xA )
      v5 = (v2 & 0xF) + 48;
    *(&v8 + v3--) = v5;
    v6 = v2 <= 0xF;
    v2 = v4;
  }
  while ( !v6 );
  return sub_7FF7053F9420(
           a2,
           1,
           "0x00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525"
           "354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library\\core\\src\\fmt\\mod.rs",
           2uLL,
           &savedregs + v3,
           -v3);
}

//----- (00007FF7053FBFF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FBFF0(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rcx
  __int64 v3; // rax
  unsigned __int64 v4; // r8
  char v5; // r10
  bool v6; // cc
  char v8; // [rsp+AFh] [rbp+2Fh]
  __int64 savedregs; // [rsp+B0h] [rbp+30h] BYREF

  v2 = *a1;
  v3 = 0LL;
  v4 = v2;
  do
  {
    v4 >>= 4;
    v5 = (v2 & 0xF) + 55;
    if ( (v2 & 0xF) < 0xA )
      v5 = (v2 & 0xF) + 48;
    *(&v8 + v3--) = v5;
    v6 = v2 <= 0xF;
    v2 = v4;
  }
  while ( !v6 );
  return sub_7FF7053F9420(
           a2,
           1,
           "0x00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525"
           "354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library\\core\\src\\fmt\\mod.rs",
           2uLL,
           &savedregs + v3,
           -v3);
}

//----- (00007FF7053FC080) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FC080(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int8 v2; // cl
  __int64 v3; // rax
  unsigned __int8 v4; // r8
  _BYTE v6[2]; // [rsp+3Ch] [rbp-4h] BYREF
  __int16 v7; // [rsp+3Eh] [rbp-2h]

  v2 = *a1;
  v3 = 3LL;
  v4 = v2;
  if ( v2 >= 0xAu )
  {
    v4 = v2 / 0x64u;
    v7 = *&a00010203040506[2 * (v2 % 0x64u)];
    v3 = 1LL;
  }
  if ( v4 != 0 || v2 == 0 )
    v6[v3--] = a00010203040506[2 * v4 + 1];
  return sub_7FF7053F9420(a2, 1, 1, 0LL, &v6[v3 + 1], 3 - v3);
}

//----- (00007FF7053FC130) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FC130(unsigned int *a1, __int64 a2)
{
  unsigned int v2; // r8d
  __int64 v3; // rax
  unsigned int v4; // r9d
  __int64 v5; // r11
  unsigned int v6; // esi
  bool v7; // cc
  _WORD v9[23]; // [rsp+32h] [rbp-Eh] BYREF

  v2 = *a1;
  v3 = 10LL;
  v4 = *a1;
  if ( *a1 >= 0x3E8 )
  {
    v5 = 5LL;
    v6 = *a1;
    do
    {
      v3 = v5 * 2 - 4;
      v4 = v6 / 0x2710;
      v9[v5] = *&a00010203040506[2 * ((5243 * (v6 % 0x2710)) >> 19)];
      v9[v5 + 1] = *&a00010203040506[2 * (v6 % 0x2710 - 100 * (((5243 * (v6 % 0x2710)) >> 16) >> 3))];
      v5 -= 2LL;
      v7 = v6 <= 0x98967F;
      v6 /= 0x2710u;
    }
    while ( !v7 );
  }
  if ( v4 > 9 )
  {
    *(&v9[1] + v3) = *&a00010203040506[2 * (v4 % 0x64u)];
    v3 -= 2LL;
    v4 = (5243 * (v4 >> 2)) >> 17;
  }
  if ( !v2 || v4 )
    *(&v9[1] + v3-- + 1) = a00010203040506[2 * (v4 & 0xF) + 1];
  return sub_7FF7053F9420(a2, 1, 1, 0LL, &v9[2] + v3, 10 - v3);
}

//----- (00007FF7053FC250) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FC250(int *a1, __int64 a2)
{
  int v2; // eax
  unsigned int v3; // r10d
  __int64 v4; // r8
  __int64 v5; // rsi
  unsigned int v6; // r9d
  bool v7; // cc
  _WORD v9[23]; // [rsp+32h] [rbp-Eh] BYREF

  v2 = *a1;
  v3 = -*a1;
  if ( *a1 > 0 )
    v3 = *a1;
  v4 = 10LL;
  if ( v3 < 0x3E8 )
  {
    v6 = v3;
    if ( v3 <= 9 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v5 = 5LL;
  do
  {
    v4 = v5 * 2 - 4;
    v6 = v3 / 0x2710;
    v9[v5] = *&a00010203040506[2 * ((5243 * (v3 % 0x2710)) >> 19)];
    v9[v5 + 1] = *&a00010203040506[2 * (v3 % 0x2710 - 100 * (((5243 * (v3 % 0x2710)) >> 16) >> 3))];
    v5 -= 2LL;
    v7 = v3 <= 0x98967F;
    v3 /= 0x2710u;
  }
  while ( !v7 );
  if ( v6 > 9 )
  {
LABEL_7:
    *(&v9[1] + v4) = *&a00010203040506[2 * (v6 % 0x64u)];
    v4 -= 2LL;
    v6 = (5243 * (v6 >> 2)) >> 17;
  }
LABEL_8:
  if ( !v2 || v6 )
    *(&v9[1] + v4-- + 1) = a00010203040506[2 * (v6 & 0xF) + 1];
  return sub_7FF7053F9420(a2, v2 >= 0, 1, 0LL, &v9[2] + v4, 10 - v4);
}

//----- (00007FF7053FC390) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FC390(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v3; // r11
  __int64 v4; // r8
  unsigned __int64 v5; // rdx
  __int64 v6; // rdi
  unsigned __int64 v7; // rcx
  int v8; // ebx
  bool v9; // cc
  _WORD v11[28]; // [rsp+38h] [rbp-18h] BYREF

  v3 = *a1;
  v4 = 20LL;
  v5 = *a1;
  if ( *a1 >= 0x3E8 )
  {
    v6 = 10LL;
    v7 = *a1;
    do
    {
      v4 = v6 * 2 - 4;
      v5 = v7 / 0x2710;
      v8 = v7 % 0x2710;
      v11[v6] = *&a00010203040506[2 * ((5243 * v8) >> 19)];
      v11[v6 + 1] = *&a00010203040506[2 * (v8 - 100 * (((5243 * v8) >> 16) >> 3))];
      v6 -= 2LL;
      v9 = v7 <= 0x98967F;
      v7 /= 0x2710uLL;
    }
    while ( !v9 );
  }
  if ( v5 > 9 )
  {
    *(&v11[1] + v4) = *&a00010203040506[2 * (v5 - 100 * (((5243 * (v5 >> 2)) >> 16) >> 1))];
    v4 -= 2LL;
    v5 = (5243 * (v5 >> 2)) >> 17;
  }
  if ( !v3 || v5 )
    *(&v11[1] + v4-- + 1) = a00010203040506[2 * (v5 & 0xF) + 1];
  return sub_7FF7053F9420(a2, 1, 1, 0LL, &v11[2] + v4, 20 - v4);
}

//----- (00007FF7053FC4B0) ----------------------------------------------------
__int64 __fastcall sub_7FF7053FC4B0(unsigned __int64 **a1, __int64 a2)
{
  unsigned __int64 *v2; // rcx
  int v3; // eax
  unsigned __int64 v5; // rcx
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  char v8; // r10
  bool v9; // cc
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r8
  char v12; // r10
  char v13; // [rsp+AFh] [rbp+2Fh]
  __int64 savedregs; // [rsp+B0h] [rbp+30h] BYREF

  v2 = *a1;
  v3 = *(a2 + 16);
  if ( (v3 & 0x2000000) != 0 )
  {
    v5 = *v2;
    v6 = 0LL;
    v7 = v5;
    do
    {
      v7 >>= 4;
      v8 = (v5 & 0xF) + 87;
      if ( (v5 & 0xF) < 0xA )
        v8 = (v5 & 0xF) + 48;
      *(&v13 + v6--) = v8;
      v9 = v5 <= 0xF;
      v5 = v7;
    }
    while ( !v9 );
  }
  else
  {
    if ( (v3 & 0x4000000) == 0 )
      return sub_7FF7053FC390(v2, a2);
    v10 = *v2;
    v6 = 0LL;
    v11 = v10;
    do
    {
      v11 >>= 4;
      v12 = (v10 & 0xF) + 55;
      if ( (v10 & 0xF) < 0xA )
        v12 = (v10 & 0xF) + 48;
      *(&v13 + v6--) = v12;
      v9 = v10 <= 0xF;
      v10 = v11;
    }
    while ( !v9 );
  }
  return sub_7FF7053F9420(
           a2,
           1,
           "0x00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525"
           "354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899library\\core\\src\\fmt\\mod.rs",
           2uLL,
           &savedregs + v6,
           -v6);
}

//----- (00007FF7053FC5A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FC5A0(_QWORD *a1)
{
  return (*(a1[1] + 24LL))(*a1);
}

//----- (00007FF7053FC5C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053FC5C0(__int64 a1, __int64 *a2)
{
  return sub_7FF7053F9980(a2, *a1, *(a1 + 8));
}

//----- (00007FF7053FC5E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool __fastcall sub_7FF7053FC5E0(unsigned int a1)
{
  return a1 < 0x20 || a1 - 127 < 0x21;
}

//----- (00007FF7053FC600) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053FC600(unsigned int a1)
{
  unsigned int v1; // eax
  int v2; // edx
  __int64 v3; // r9
  __int64 v4; // r10
  __int64 v5; // r9
  __int64 v6; // r10
  __int64 v7; // r9
  __int64 v8; // r11
  unsigned __int64 v9; // r10
  __int64 v10; // rax
  __int64 v11; // r9
  unsigned int v12; // ecx
  __int64 v13; // r9
  unsigned int v14; // r8d

  v1 = a1 << 11;
  v2 = 0;
  v3 = 17LL;
  if ( a1 < 0x1182F )
    v3 = 0LL;
  v4 = v3 + 8;
  if ( dword_7FF7054054C0[v3 + 8] << 11 > v1 )
    v4 = v3;
  v5 = v4 + 4;
  if ( dword_7FF7054054C0[v4 + 4] << 11 > v1 )
    v5 = v4;
  v6 = v5 + 2;
  if ( dword_7FF7054054C0[v5 + 2] << 11 > v1 )
    v6 = v5;
  v7 = v6 + 1;
  if ( dword_7FF7054054C0[v6 + 1] << 11 > v1 )
    v7 = v6;
  v8 = v7 + 1;
  if ( dword_7FF7054054C0[v7 + 1] << 11 > v1 )
    v8 = v7;
  v9 = v8 + (dword_7FF7054054C0[v8] << 11 < v1) + (dword_7FF7054054C0[v8] << 11 == v1);
  v10 = dword_7FF7054054C0[v9] >> 21;
  v11 = 751LL;
  if ( v9 > 0x20 || (v11 = dword_7FF7054054C0[v9 + 1] >> 21, v9) )
    v2 = dword_7FF7054054C0[v9 - 1] & 0x1FFFFF;
  if ( v11 + ~v10 )
  {
    v12 = a1 - v2;
    v13 = v11 - 1;
    v14 = 0;
    do
    {
      v14 += byte_7FF705404264[v10];
      if ( v14 > v12 )
        break;
      ++v10;
    }
    while ( v13 != v10 );
  }
  return v10 & 1;
}
// 7FF705404264: using guessed type unsigned __int8 byte_7FF705404264[751];
// 7FF7054054C0: using guessed type _DWORD dword_7FF7054054C0[34];

//----- (00007FF7053FC9E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_7FF7053FC9E0(_QWORD *a1, char a2)
{
  *a1 = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    j_j_free(a1);
  return a1;
}
// 7FF705405638: using guessed type void *type_info::`vftable';

//----- (00007FF7053FCCF8) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall UserMathErrorFunction(struct _exception *a1)
{
  return 0LL;
}

//----- (00007FF7053FCD04) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053FCD04()
{
  return 0LL;
}

//----- (00007FF7053FCD10) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053FCD10()
{
  return 0LL;
}

//----- (00007FF7053FCD14) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053FCD14()
{
  return 0LL;
}

//----- (00007FF7053FCD18) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void sub_7FF7053FCD18()
{
  InitializeSListHead(&stru_7FF70540B2D0);
}
// 7FF70540B2D0: using guessed type union _SLIST_HEADER stru_7FF70540B2D0;

//----- (00007FF7053FCD28) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char sub_7FF7053FCD28()
{
  return 1;
}

//----- (00007FF7053FCD34) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void *sub_7FF7053FCD34()
{
  return &unk_7FF70540B2E0;
}

//----- (00007FF7053FCD3C) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void *sub_7FF7053FCD3C()
{
  return &unk_7FF70540B2E8;
}

//----- (00007FF7053FCD6C) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void *sub_7FF7053FCD6C()
{
  return &unk_7FF70540B308;
}

//----- (00007FF7053FCD74) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void *sub_7FF7053FCD74()
{
  return &unk_7FF70540B300;
}

//----- (00007FF7053FCD7C) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void sub_7FF7053FCD7C()
{
  dword_7FF70540B2F0 = 0;
}
// 7FF70540B2F0: using guessed type int dword_7FF70540B2F0;

//----- (00007FF7053FCED4) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053FCED4()
{
  return 0LL;
}

//----- (00007FF7053FCF3C) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053FCF3C()
{
  return 0LL;
}

//----- (00007FF7053FCF9C) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void sub_7FF7053FCF9C()
{
  void (**i)(void); // rbx

  for ( i = qword_7FF705405C70; i < qword_7FF705405C70; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 7FF705405C70: using guessed type void (*qword_7FF705405C70[2])(void);

//----- (00007FF7053FCFD8) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053FCFD8()
{
  void (**i)(void); // rbx

  for ( i = &qword_7FF705405C80; i < &qword_7FF705405C80; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 7FF705405C80: using guessed type void (*qword_7FF705405C80)(void);

//----- (00007FF7053FD020) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 sub_7FF7053FD020()
{
  int v5; // r10d
  int v6; // r8d
  int v7; // r9d
  int v8; // r14d
  int v14; // edi
  int v15; // eax
  unsigned __int64 v16; // rax
  __int64 v17; // rcx
  int v18; // r8d
  int v19; // r9d
  int v20; // esi
  int v21; // r10d
  unsigned int v22; // r11d
  unsigned __int64 v38; // rax
  int v39; // eax
  unsigned __int64 v40; // rax
  __int64 v41; // rcx
  int v43; // [rsp+30h] [rbp+20h]

  _RAX = 0LL;
  __asm { cpuid }
  v5 = _RDX ^ 0x49656E69;
  v6 = _RCX ^ 0x6C65746E;
  v7 = _RBX;
  v8 = _RAX;
  _RAX = 1LL;
  __asm { cpuid }
  v14 = _RCX;
  if ( !(v7 ^ 0x756E6547 | v6 | v5)
    && ((qword_7FF70540B0A8 = -1LL, v15 = _RAX & 0xFFF3FF0, qword_7FF70540B0A0 = 0x8000LL, v15 == 67264)
     || v15 == 132704
     || v15 == 132720
     || (v16 = (v15 - 198224), v16 <= 0x20) && (v17 = 0x100010001LL, _bittest64(&v17, v16))) )
  {
    v18 = dword_7FF70540B2F8 | 1;
    dword_7FF70540B2F8 |= 1u;
  }
  else
  {
    v18 = dword_7FF70540B2F8;
  }
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  if ( v8 >= 7 )
  {
    _RAX = 7LL;
    __asm { cpuid }
    v20 = _RDX;
    v19 = _RBX;
    if ( (_RBX & 0x200) != 0 )
      dword_7FF70540B2F8 = v18 | 2;
    if ( _RAX >= 1 )
    {
      _RAX = 7LL;
      __asm { cpuid }
      v21 = _RDX;
    }
    _RAX = 36LL;
    if ( v8 >= 36 )
    {
      __asm { cpuid }
      v22 = _RBX;
    }
  }
  v38 = qword_7FF70540B090 & 0xFFFFFFFFFFFFFFFEuLL;
  dword_7FF70540B098 = 1;
  dword_7FF70540B09C = 2;
  qword_7FF70540B090 &= ~1uLL;
  if ( (v14 & 0x100000) != 0 )
  {
    v38 &= ~0x10uLL;
    dword_7FF70540B098 = 2;
    qword_7FF70540B090 = v38;
    dword_7FF70540B09C = 6;
  }
  if ( (v14 & 0x8000000) != 0 )
  {
    __asm { xgetbv }
    v43 = v38;
    if ( (v14 & 0x10000000) == 0 || (v38 & 6) != 6 )
    {
LABEL_32:
      if ( (v21 & 0x200000) != 0 && (*&v43 & 0x80000LL) != 0 )
        qword_7FF70540B090 &= ~0x80uLL;
      return 0LL;
    }
    v39 = dword_7FF70540B09C | 8;
    dword_7FF70540B098 = 3;
    dword_7FF70540B09C |= 8u;
    if ( (v19 & 0x20) != 0 )
    {
      dword_7FF70540B098 = 5;
      dword_7FF70540B09C = v39 | 0x20;
      v40 = qword_7FF70540B090 & 0xFFFFFFFFFFFFFFFDuLL;
      qword_7FF70540B090 &= ~2uLL;
      if ( (v19 & 0xD0030000) != 0xD0030000 )
      {
LABEL_26:
        if ( (v20 & 0x800000) != 0 )
          qword_7FF70540B090 = v40 & 0xFFFFFFFFFEFFFFFFuLL;
        if ( (v21 & 0x80000) != 0 && (v43 & 0xE0) == 0xE0 )
        {
          dword_7FF70540B2F4 = v22 & 0x400FF;
          v41 = qword_7FF70540B090 & ~(HIWORD(v22) & 7 | 0x1000028LL);
          qword_7FF70540B090 = v41;
          if ( (v22 & 0x400FF) > 1 )
            qword_7FF70540B090 = v41 & 0xFFFFFFFFFFFFFFBFuLL;
        }
        goto LABEL_32;
      }
      if ( (v43 & 0xE0) == 0xE0 )
      {
        dword_7FF70540B09C |= 0x40u;
        v40 = qword_7FF70540B090 & 0xFFFFFFFFFFFFFFDBuLL;
        dword_7FF70540B098 = 6;
        qword_7FF70540B090 &= 0xFFFFFFFFFFFFFFDBuLL;
        goto LABEL_26;
      }
    }
    v40 = qword_7FF70540B090;
    goto LABEL_26;
  }
  return 0LL;
}
// 7FF70540B090: using guessed type __int64 qword_7FF70540B090;
// 7FF70540B098: using guessed type int dword_7FF70540B098;
// 7FF70540B09C: using guessed type int dword_7FF70540B09C;
// 7FF70540B0A0: using guessed type __int64 qword_7FF70540B0A0;
// 7FF70540B0A8: using guessed type __int64 qword_7FF70540B0A8;
// 7FF70540B2F4: using guessed type int dword_7FF70540B2F4;
// 7FF70540B2F8: using guessed type int dword_7FF70540B2F8;

//----- (00007FF7053FD3CC) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char sub_7FF7053FD3CC()
{
  return 1;
}

//----- (00007FF7053FD3D0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char sub_7FF7053FD3D0()
{
  return 1;
}

//----- (00007FF7053FD420) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_7FF7053FD420(_QWORD *_RCX, __int64 a2, int _R8D, char a4)
{
  char result; // al
  _BYTE *v5; // r9
  __int64 v6; // rdx
  unsigned __int64 v7; // r10
  _DWORD *v8; // r11
  _DWORD *v9; // rax
  _DWORD *v10; // rsi

  if ( a4 )
    return 0;
  v5 = _RCX[2];
  v6 = *_RCX + a2 + 1;
  v7 = _RCX[3];
  if ( v7 >= 4 )
  {
    while ( 1 )
    {
      __asm { tzcnt   ecx, r8d }
      v8 = (_RCX + v6);
      v9 = (_RCX + v6 + v7 - 4);
      if ( (_RCX + v6) >= v9 )
      {
LABEL_5:
        if ( *v9 == *&v5[v7 - 4] )
          return 1;
      }
      else
      {
        v10 = v5;
        while ( *v8 == *v10 )
        {
          ++v8;
          ++v10;
          if ( v8 >= v9 )
            goto LABEL_5;
        }
      }
      LOWORD(_R8D) = __ROL2__(-2, _RCX) & _R8D;
      if ( !_R8D )
        return 0;
    }
  }
  while ( 1 )
  {
    result = 1;
    if ( !v7 )
      break;
    __asm { tzcnt   ecx, r8d }
    if ( *(_RCX + v6) == *v5
      && (v7 == 1 || *(_RCX + v6 + 1) == v5[1] && (v7 == 2 || v7 == 3 && *(_RCX + v6 + 2) == v5[2])) )
    {
      break;
    }
    LOWORD(_R8D) = __ROL2__(-2, _RCX) & _R8D;
    if ( !_R8D )
      return 0;
  }
  return result;
}

//----- (00007FF7053FD530) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FD530(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rbx
  __int64 result; // rax
  __int64 v8; // rcx

  v5 = a2;
  if ( *(a4 + 8) && *(a4 + 16) )
  {
    result = sub_7FF7053E5E50(*a4);
  }
  else if ( a3 )
  {
    nullsub_1();
    result = sub_7FF7053E5E30(a3, v5);
  }
  else
  {
    result = a2;
  }
  v8 = 0LL;
  if ( result )
    v5 = result;
  LOBYTE(v8) = result == 0;
  a1[1] = v5;
  a1[2] = a3;
  *a1 = v8;
  return result;
}
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 nullsub_1(void);

//----- (00007FF7053FD5A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FD5A0(unsigned __int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  bool v5; // cf
  unsigned __int128 v6; // rax
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // rdi
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 result; // rax
  _QWORD v13[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v14; // [rsp+38h] [rbp-18h] BYREF
  __int64 v15; // [rsp+40h] [rbp-10h]
  __int64 v16; // [rsp+48h] [rbp-8h]

  v5 = __CFADD__(a3, a2);
  *(&v6 + 1) = a3 + a2;
  if ( v5 )
    goto LABEL_13;
  v8 = *a1;
  v9 = 2 * *a1;
  if ( *(&v6 + 1) > v9 )
    v9 = *(&v6 + 1);
  if ( v9 <= 4 * (a5 == 1) + 4 )
    v9 = 4LL * (a5 == 1) + 4;
  v10 = 0LL;
  v6 = v9 * ((a4 + a5 - 1) & -a4);
  if ( !is_mul_ok(v9, (a4 + a5 - 1) & -a4) )
LABEL_13:
    sub_7FF7053FDFF0(0LL, *(&v6 + 1), &off_7FF705400DE0);
  if ( v6 > 0x8000000000000000uLL - a4 )
LABEL_15:
    sub_7FF7053FDFF0(v10, *(&v6 + 1), &off_7FF705400DE0);
  if ( v8 )
  {
    v13[0] = a1[1];
    v13[2] = a5 * v8;
    v11 = a4;
  }
  else
  {
    v11 = 0LL;
  }
  v13[1] = v11;
  sub_7FF7053FD530(&v14, a4, v6, v13);
  if ( v14 == 1 )
  {
    v10 = v15;
    *(&v6 + 1) = v16;
    goto LABEL_15;
  }
  result = v15;
  a1[1] = v15;
  *a1 = v9;
  return result;
}
// 7FF705400DE0: using guessed type char *off_7FF705400DE0;

//----- (00007FF7053FD680) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __noreturn sub_7FF7053FD680()
{
  _QWORD v0[3]; // [rsp+20h] [rbp-30h] BYREF
  __int128 v1; // [rsp+38h] [rbp-18h]

  v0[0] = &off_7FF705401128;
  v0[1] = 1LL;
  v0[2] = 8LL;
  v1 = 0LL;
  sub_7FF7053FE110(v0, &off_7FF705401138);
}
// 7FF705401128: using guessed type char *off_7FF705401128;
// 7FF705401138: using guessed type char *off_7FF705401138;

//----- (00007FF7053FD6C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 __fastcall sub_7FF7053FD6C0(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v5; // rax
  char *v6; // rbx
  unsigned __int64 result; // rax
  __int64 v8; // rbx
  unsigned __int64 v9; // rcx

  v5 = *a1;
  if ( a3 > *a1 - *(a1 + 16) )
  {
    v6 = a2;
    result = sub_7FF7053E9430(a1);
    if ( result )
      return result;
    v5 = *a1;
    a2 = v6;
  }
  if ( a3 >= v5 )
  {
    *(a1 + 24) = 1;
    v9 = sub_7FF7053EAD30((a1 + 25), a2, a3);
    result = 0LL;
    if ( (v9 & 0xFFFFFFFF00000003uLL) != 0x600000002LL )
      result = v9;
    *(a1 + 24) = 0;
  }
  else
  {
    v8 = *(a1 + 16);
    memcpy((v8 + *(a1 + 8)), a2, a3);
    *(a1 + 16) = a3 + v8;
    return 0LL;
  }
  return result;
}

//----- (00007FF7053FD75B) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053FD75B(__int64 a1)
{
  _QWORD v1[3]; // [rsp+28h] [rbp-28h] BYREF
  _QWORD *v2; // [rsp+40h] [rbp-10h] BYREF
  char v3; // [rsp+4Fh] [rbp-1h] BYREF

  if ( dword_7FF70540B188 != 3 )
  {
    v1[0] = a1;
    v1[1] = &qword_7FF70540B150;
    v1[2] = &v3;
    v2 = v1;
    sub_7FF7053FD950(&dword_7FF70540B188, 1, &v2, &unk_7FF705401A88, &off_7FF705401A70);
  }
}
// 7FF705401A70: using guessed type char *off_7FF705401A70;
// 7FF70540B150: using guessed type __int64 qword_7FF70540B150;
// 7FF70540B188: using guessed type int dword_7FF70540B188;

//----- (00007FF7053FD7BA) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void sub_7FF7053FD7BA()
{
  _QWORD v0[2]; // [rsp+30h] [rbp-20h] BYREF
  _QWORD *v1; // [rsp+40h] [rbp-10h] BYREF
  char v2; // [rsp+4Fh] [rbp-1h] BYREF

  if ( dword_7FF70540B188 != 3 )
  {
    v0[0] = &qword_7FF70540B150;
    v0[1] = &v2;
    v1 = v0;
    sub_7FF7053FD950(&dword_7FF70540B188, 1, &v1, &unk_7FF705401A48, &off_7FF705401A70);
  }
}
// 7FF705401A70: using guessed type char *off_7FF705401A70;
// 7FF70540B150: using guessed type __int64 qword_7FF70540B150;
// 7FF70540B188: using guessed type int dword_7FF70540B188;

//----- (00007FF7053FD820) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
bool sub_7FF7053FD820()
{
  return *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 48LL) == 0LL;
}
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053FD83F) ----------------------------------------------------
__int64 __fastcall sub_7FF7053FD83F(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rcx
  _QWORD v3[3]; // [rsp+28h] [rbp-8h] BYREF

  sub_7FF7053F26F0(v3, a1);
  result = v3[0];
  _InterlockedDecrement64(&qword_7FF70540B1E0);
  v2 = *(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  --*(v2 + 48);
  *(v2 + 56) = 0;
  return result;
}
// 7FF70540B1E0: using guessed type __int64 qword_7FF70540B1E0;
// 7FF70540B280: using guessed type int TlsIndex;

//----- (00007FF7053FD890) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
signed __int8 __fastcall sub_7FF7053FD890(signed __int8 *Address)
{
  signed __int8 result; // al
  int v3; // ecx
  bool v4; // zf
  int v5; // ecx
  char CompareAddress[33]; // [rsp+2Fh] [rbp-1h] BYREF

  result = *Address;
  if ( *Address == 1 )
  {
    v3 = -99;
    do
    {
      _mm_pause();
      result = *Address;
      if ( *Address != 1 )
        break;
      v4 = v3++ == 0;
    }
    while ( !v4 );
  }
  if ( result || (result = _InterlockedCompareExchange8(Address, 1, 0)) != 0 )
  {
    while ( 1 )
    {
      if ( result != 2 )
      {
        result = *Address;
        *Address = 2;
        if ( !result )
          break;
      }
      CompareAddress[0] = 2;
      if ( !WaitOnAddress(Address, CompareAddress, 1uLL, 0xFFFFFFFF) )
        GetLastError();
      result = *Address;
      if ( *Address == 1 )
      {
        v5 = -99;
        do
        {
          _mm_pause();
          result = *Address;
          if ( *Address != 1 )
            break;
          v4 = v5++ == 0;
        }
        while ( !v4 );
      }
    }
  }
  return result;
}

//----- (00007FF7053FD950) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053FD950(volatile signed __int32 *a1, char a2, __int64 a3, __int64 a4, __int64 a5)
{
  signed __int32 v7; // eax
  signed __int32 v8; // ett
  unsigned int v9; // r8d
  int v10; // edx
  signed __int32 *v11; // r12
  bool v12; // r8
  PVOID v13; // rcx
  int v14; // edx
  signed __int32 v15; // r9d
  signed __int32 *v16; // rbx
  _QWORD CompareAddress[3]; // [rsp+28h] [rbp-38h] BYREF
  __int128 v18; // [rsp+40h] [rbp-20h]
  PVOID Address; // [rsp+58h] [rbp-8h]
  __int64 v20; // [rsp+60h] [rbp+0h]

  v20 = -2LL;
  v7 = *a1;
  if ( !a2 )
  {
LABEL_18:
    while ( 2 )
    {
      v14 = v7 & 4;
      v15 = v7;
      switch ( v7 & 3 )
      {
        case 0:
LABEL_17:
          v12 = 0;
          v7 = _InterlockedCompareExchange(a1, v14 | 2, v15);
          if ( v15 != v7 )
            continue;
          goto LABEL_14;
        case 1:
LABEL_24:
          CompareAddress[0] = &off_7FF705402BA8;
          CompareAddress[1] = 1LL;
          CompareAddress[2] = 8LL;
          v18 = 0LL;
          sub_7FF7053FE110(CompareAddress, a5);
        case 2:
          while ( 2 )
          {
            if ( v14 || (v15 |= 4u, v7 = _InterlockedCompareExchange(a1, v15, 2), v7 == 2) )
            {
              LODWORD(CompareAddress[0]) = v15;
              v16 = a1;
              if ( !WaitOnAddress(a1, CompareAddress, 4uLL, 0xFFFFFFFF) )
                GetLastError();
              a1 = v16;
              v15 = *v16;
              v14 = *v16 & 4;
              switch ( *v16 & 3 )
              {
                case 0:
                  goto LABEL_17;
                case 1:
                  goto LABEL_24;
                case 2:
                  continue;
                case 3:
                  return;
              }
            }
            goto LABEL_18;
          }
        case 3:
          return;
      }
    }
  }
  do
  {
    while ( 1 )
    {
      v9 = v7 & 3;
      if ( v9 < 2 )
        break;
      if ( v9 != 2 )
        return;
      if ( (v7 & 4) != 0 )
      {
        v10 = v7;
        goto LABEL_10;
      }
      v10 = v7 | 4;
      v7 = _InterlockedCompareExchange(a1, v7 | 4, 2);
      if ( v7 == 2 )
      {
LABEL_10:
        LODWORD(CompareAddress[0]) = v10;
        v11 = a1;
        if ( !WaitOnAddress(a1, CompareAddress, 4uLL, 0xFFFFFFFF) )
          GetLastError();
        a1 = v11;
        v7 = *v11;
      }
    }
    v8 = v7;
    v7 = _InterlockedCompareExchange(a1, v7 & 4 | 2, v7);
  }
  while ( v8 != v7 );
  v12 = v9 == 1;
LABEL_14:
  Address = a1;
  LODWORD(CompareAddress[0]) = 3;
  BYTE4(CompareAddress[0]) = v12;
  (*(a4 + 32))(a3, CompareAddress);
  v13 = Address;
  if ( (_InterlockedExchange(Address, CompareAddress[0]) & 4) != 0 )
    WakeByAddressAll(v13);
}
// 7FF705402BA8: using guessed type char *off_7FF705402BA8;

//----- (00007FF7053FDB60) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FDB60(volatile signed __int32 *Address)
{
  unsigned __int32 v2; // ecx
  int v3; // eax
  bool v4; // zf
  char v5; // al
  __int64 result; // rax
  unsigned int v7; // eax
  int v8; // edx
  _QWORD CompareAddress[3]; // [rsp+20h] [rbp-30h] BYREF
  __int128 v10; // [rsp+38h] [rbp-18h]

  v2 = *Address;
  if ( v2 == 0x3FFFFFFF )
  {
    v3 = -99;
    do
    {
      _mm_pause();
      v2 = *Address;
      if ( *Address != 0x3FFFFFFF )
        break;
      v4 = v3++ == 0;
    }
    while ( !v4 );
  }
  v5 = 0;
LABEL_6:
  if ( (v5 & 1) != 0 )
  {
    while ( 1 )
    {
      v7 = v2 & 0x3FFFFFFF;
      if ( (v2 & 0x3FFFFFFF) - 1073741822 >= 0xC0000003 && (v2 & 0x40000000) == 0 || v2 < 0x40000000 && v7 < 0x3FFFFFFE )
      {
        result = _InterlockedCompareExchange(Address, v2 + 1, v2);
        if ( v2 == result )
          return result;
      }
      else
      {
        if ( v7 == 1073741822 )
          goto LABEL_29;
        if ( (v2 & 0x40000000) != 0 )
          goto LABEL_22;
        LODWORD(result) = _InterlockedCompareExchange(Address, v2 | 0x40000000, v2);
        if ( v2 == result )
          goto LABEL_22;
      }
      v2 = result;
    }
  }
  while ( (v2 & 0x3FFFFFFF) >= 0x3FFFFFFE || v2 >= 0x40000000 )
  {
    if ( (v2 & 0x3FFFFFFF) == 0x3FFFFFFE )
    {
LABEL_29:
      CompareAddress[0] = &off_7FF705402BE0;
      CompareAddress[1] = 1LL;
      CompareAddress[2] = 8LL;
      v10 = 0LL;
      sub_7FF7053FE110(CompareAddress, &off_7FF705402C20);
    }
    if ( (v2 & 0x40000000) != 0
      || (LODWORD(result) = _InterlockedCompareExchange(Address, v2 | 0x40000000, v2), v2 == result) )
    {
LABEL_22:
      LODWORD(CompareAddress[0]) = v2 | 0x40000000;
      if ( !WaitOnAddress(Address, CompareAddress, 4uLL, 0xFFFFFFFF) )
        GetLastError();
      v2 = *Address;
      v5 = 1;
      if ( *Address == 0x3FFFFFFF )
      {
        v8 = -99;
        do
        {
          _mm_pause();
          v2 = *Address;
          if ( *Address != 0x3FFFFFFF )
            break;
          v4 = v8++ == 0;
        }
        while ( !v4 );
      }
      goto LABEL_6;
    }
LABEL_17:
    v2 = result;
  }
  result = _InterlockedCompareExchange(Address, v2 + 1, v2);
  if ( v2 != result )
    goto LABEL_17;
  return result;
}
// 7FF705402BE0: using guessed type char *off_7FF705402BE0;
// 7FF705402C20: using guessed type char *off_7FF705402C20;

//----- (00007FF7053FDD40) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_7FF7053FDD40(volatile signed __int32 *a1, signed __int32 a2)
{
  signed __int32 v2; // eax
  volatile signed __int32 *v3; // rsi

  if ( (a2 & 0x3FFFFFFF) != 0 )
    sub_7FF7053FE1B0(aAssertionFaile_1, 36LL, &off_7FF705402C60);
  if ( __OFSUB__(-a2, 1) )
  {
    v2 = _InterlockedCompareExchange(a1, 0, 0x80000000);
    if ( v2 == 0x80000000 )
    {
      _InterlockedIncrement(a1 + 1);
      WakeByAddressSingle((a1 + 1));
      return;
    }
    a2 = v2;
  }
  if ( a2 != -1073741824 )
  {
    if ( a2 != 0x40000000 || _InterlockedCompareExchange(a1, 0, 0x40000000) != 0x40000000 )
      return;
LABEL_12:
    WakeByAddressAll(a1);
    return;
  }
  if ( _InterlockedCompareExchange(a1, 0x40000000, -1073741824) == -1073741824 )
  {
    _InterlockedIncrement(a1 + 1);
    v3 = a1;
    WakeByAddressSingle((a1 + 1));
    a1 = v3;
    if ( _InterlockedCompareExchange(v3, 0, 0x40000000) == 0x40000000 )
      goto LABEL_12;
  }
}
// 7FF705402C60: using guessed type char *off_7FF705402C60;

//----- (00007FF7053FDE10) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __noreturn sub_7FF7053FDE10()
{
  _QWORD v0[3]; // [rsp+20h] [rbp-30h] BYREF
  __int128 v1; // [rsp+38h] [rbp-18h]

  v0[0] = &off_7FF705403338;
  v0[1] = 1LL;
  v0[2] = 8LL;
  v1 = 0LL;
  sub_7FF7053FE110(v0, &off_7FF705403348);
}
// 7FF705403338: using guessed type char *off_7FF705403338;
// 7FF705403348: using guessed type char *off_7FF705403348;

//----- (00007FF7053FDE4D) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FDE4D(unsigned __int8 a1, __int64 a2, __int64 a3, __int128 *a4, __int64 a5)
{
  __int64 v5; // [rsp+40h] [rbp-10h] BYREF
  __int64 v6; // [rsp+48h] [rbp-8h] BYREF

  v6 = a2;
  v5 = a3;
  sub_7FF7053FE2F4(a1, &v6, &unk_7FF705404028, &v5, &unk_7FF705404028, a4, a5);
}

//----- (00007FF7053FDE90) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FDE90(__int64 a1)
{
  _QWORD v1[3]; // [rsp+20h] [rbp-30h] BYREF
  __int128 v2; // [rsp+38h] [rbp-18h]

  v1[0] = &off_7FF7054040C8;
  v1[1] = 1LL;
  v1[2] = 8LL;
  v2 = 0LL;
  sub_7FF7053FE110(v1, a1);
}
// 7FF7054040C8: using guessed type char *off_7FF7054040C8;

//----- (00007FF7053FDED0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FDED0(__int64 *a1, __int64 a2, __int64 a3)
{
  bool v3; // cf
  unsigned __int64 v4; // rdx
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  __int64 v8; // rdi
  __int64 v9; // rax
  __int64 result; // rax
  _QWORD v11[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v12; // [rsp+38h] [rbp-18h] BYREF
  __int64 v13; // [rsp+40h] [rbp-10h]
  __int64 v14; // [rsp+48h] [rbp-8h]

  v3 = __CFADD__(a3, a2);
  v4 = a3 + a2;
  if ( v3 )
    goto LABEL_12;
  v6 = *a1;
  v7 = 2 * *a1;
  if ( v4 > v7 )
    v7 = v4;
  v8 = 8LL;
  if ( v7 >= 9 )
    v8 = v7;
  if ( v8 < 0 )
LABEL_12:
    sub_7FF7053FDFF0(0LL, v4, &off_7FF705404100);
  if ( v6 )
  {
    v11[0] = a1[1];
    v11[2] = v6;
    v9 = 1LL;
  }
  else
  {
    v9 = 0LL;
  }
  v11[1] = v9;
  sub_7FF7053FDF80(&v12, 1LL, v8, v11);
  if ( v12 == 1 )
    sub_7FF7053FDFF0(v13, v14, &off_7FF705404100);
  result = v13;
  a1[1] = v13;
  *a1 = v8;
  return result;
}
// 7FF705404100: using guessed type char *off_7FF705404100;

//----- (00007FF7053FDF80) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_7FF7053FDF80(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rbx
  __int64 result; // rax
  __int64 v8; // rcx

  v5 = a2;
  if ( *(a4 + 8) && *(a4 + 16) )
  {
    result = sub_7FF7053E5E50(*a4);
  }
  else if ( a3 )
  {
    nullsub_1();
    result = sub_7FF7053E5E30(a3, v5);
  }
  else
  {
    result = a2;
  }
  v8 = 0LL;
  if ( result )
    v5 = result;
  LOBYTE(v8) = result == 0;
  a1[1] = v5;
  a1[2] = a3;
  *a1 = v8;
  return result;
}
// 7FF7053E5E30: using guessed type __int64 __fastcall sub_7FF7053E5E30(_QWORD, _QWORD);
// 7FF7053E5E80: using guessed type __int64 nullsub_1(void);

//----- (00007FF7053FDFF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FDFF0(__int64 a1, __int64 a2, __int64 a3)
{
  if ( !a1 )
    sub_7FF7053FDE90(a3);
  sub_7FF7053FE00D(a1, a2);
}

//----- (00007FF7053FE00D) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE00D(__int64 a1, __int64 a2)
{
  sub_7FF7053E5E70(a2, a1);
}
// 7FF7053E5E70: using guessed type void __fastcall __noreturn sub_7FF7053E5E70(_QWORD, _QWORD);

//----- (00007FF7053FE030) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE030(__int64 a1)
{
  _QWORD v1[6]; // [rsp+28h] [rbp-48h] BYREF
  _QWORD v2[2]; // [rsp+58h] [rbp-18h] BYREF
  char v3; // [rsp+6Fh] [rbp-1h] BYREF

  v2[0] = &v3;
  v2[1] = sub_7FF7053F89A0;
  v1[0] = &unk_7FF7054046D0;
  v1[1] = 1LL;
  v1[4] = 0LL;
  v1[2] = v2;
  v1[3] = 1LL;
  sub_7FF7053FE110(v1, a1);
}

//----- (00007FF7053FE090) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE090(__int64 a1)
{
  sub_7FF7053FE1B0("called `Option::unwrap()` on a `None` valuelibrary\\core\\src\\panicking.rs", 43LL, a1);
}

//----- (00007FF7053FE0B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE0B0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[6]; // [rsp+20h] [rbp-50h] BYREF
  _QWORD v4[2]; // [rsp+50h] [rbp-20h] BYREF
  _QWORD v5[2]; // [rsp+60h] [rbp-10h] BYREF

  v5[0] = a1;
  v5[1] = a2;
  v4[0] = v5;
  v4[1] = sub_7FF7053FC5C0;
  v3[0] = &unk_7FF7054046D0;
  v3[1] = 1LL;
  v3[4] = 0LL;
  v3[2] = v4;
  v3[3] = 1LL;
  sub_7FF7053FE110(v3, a3);
}

//----- (00007FF7053FE110) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE110(__int64 a1, __int64 a2)
{
  _QWORD v2[2]; // [rsp+28h] [rbp-18h] BYREF
  __int16 v3; // [rsp+38h] [rbp-8h]

  v2[0] = a1;
  v2[1] = a2;
  v3 = 1;
  sub_7FF7053EF030(v2);
}
// 7FF7053EF030: using guessed type void __fastcall __noreturn sub_7FF7053EF030(_QWORD);

//----- (00007FF7053FE140) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE140(__int128 *a1, char a2, __int64 a3)
{
  __int128 v3; // xmm0
  __int128 v4; // xmm1
  _OWORD v5[3]; // [rsp+20h] [rbp-50h] BYREF
  __int128 v6; // [rsp+50h] [rbp-20h] BYREF
  char v7; // [rsp+60h] [rbp-10h]
  char v8; // [rsp+61h] [rbp-Fh]
  __int64 v9; // [rsp+68h] [rbp-8h]

  v9 = -2LL;
  v3 = *a1;
  v4 = a1[1];
  v5[2] = a1[2];
  v5[1] = v4;
  v5[0] = v3;
  *&v6 = v5;
  *(&v6 + 1) = a3;
  v7 = 0;
  v8 = a2;
  try
  {
    sub_7FF7053EF030(&v6);
  }
  catch ( ... )
  {
    sub_7FF7053FE29A();
  }
}
// 7FF7053FE29A: using guessed type void __noreturn sub_7FF7053FE29A(void);

//----- (00007FF7053FE1B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE1B0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[3]; // [rsp+20h] [rbp-40h] BYREF
  __int128 v4; // [rsp+38h] [rbp-28h]
  _QWORD v5[2]; // [rsp+50h] [rbp-10h] BYREF

  v5[0] = a1;
  v5[1] = a2;
  v3[0] = v5;
  v3[1] = 1LL;
  v3[2] = 8LL;
  v4 = 0LL;
  sub_7FF7053FE110(v3, a3);
}

//----- (00007FF7053FE1F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE1F0(__int64 a1, __int64 a2)
{
  __int128 v2; // [rsp+20h] [rbp-40h] BYREF
  __int64 v3; // [rsp+30h] [rbp-30h]
  __int128 v4; // [rsp+38h] [rbp-28h]
  _QWORD v5[2]; // [rsp+50h] [rbp-10h] BYREF

  v5[0] = a1;
  v5[1] = a2;
  *&v2 = v5;
  *(&v2 + 1) = 1LL;
  v3 = 8LL;
  v4 = 0LL;
  sub_7FF7053FE140(&v2, 0, &off_7FF705404748);
}
// 7FF705404748: using guessed type char *off_7FF705404748;

//----- (00007FF7053FE234) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE234(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[6]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v4[4]; // [rsp+50h] [rbp-30h] BYREF
  __int64 v5; // [rsp+70h] [rbp-10h] BYREF
  __int64 v6; // [rsp+78h] [rbp-8h] BYREF

  v6 = a1;
  v5 = a2;
  v4[0] = &v5;
  v4[1] = sub_7FF7053FC390;
  v3[0] = &off_7FF705404798;
  v3[1] = 2LL;
  v3[4] = 0LL;
  v4[2] = &v6;
  v4[3] = sub_7FF7053FC390;
  v3[2] = v4;
  v3[3] = 2LL;
  sub_7FF7053FE110(v3, a3);
}
// 7FF705404798: using guessed type char *off_7FF705404798;

//----- (00007FF7053FE29A) ----------------------------------------------------
void __noreturn sub_7FF7053FE29A()
{
  sub_7FF7053FE1F0(aPanicInAFuncti, 38LL);
}

//----- (00007FF7053FE2B6) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE2B6(unsigned __int8 a1, __int64 a2, __int64 a3, __int128 *a4, __int64 a5)
{
  __int64 v5; // [rsp+40h] [rbp-10h] BYREF
  __int64 v6; // [rsp+48h] [rbp-8h] BYREF

  v6 = a2;
  v5 = a3;
  sub_7FF7053FE2F4(a1, &v6, &unk_7FF7054047E0, &v5, &unk_7FF7054047E0, a4, a5);
}

//----- (00007FF7053FE2F4) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE2F4(
        unsigned __int8 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int128 *a6,
        __int64 a7)
{
  __int64 v7; // rax
  __int64 v8; // r10
  __int128 v9; // xmm0
  __int128 v10; // xmm1
  _OWORD v11[3]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD *v12; // [rsp+50h] [rbp-30h] BYREF
  char (__fastcall *v13)(__int64, __int64 *); // [rsp+58h] [rbp-28h]
  _QWORD *v14; // [rsp+60h] [rbp-20h]
  void *v15; // [rsp+68h] [rbp-18h]
  _QWORD *v16; // [rsp+70h] [rbp-10h]
  __int64 (__fastcall *v17)(_QWORD *); // [rsp+78h] [rbp-8h]
  _QWORD *v18; // [rsp+80h] [rbp+0h]
  __int64 (__fastcall *v19)(_QWORD *); // [rsp+88h] [rbp+8h]
  char **v20; // [rsp+90h] [rbp+10h] BYREF
  __int64 v21; // [rsp+98h] [rbp+18h]
  _QWORD *v22; // [rsp+A0h] [rbp+20h]
  __int64 v23; // [rsp+A8h] [rbp+28h]
  __int64 v24; // [rsp+B0h] [rbp+30h]
  _QWORD v25[2]; // [rsp+C0h] [rbp+40h] BYREF
  _QWORD v26[2]; // [rsp+D0h] [rbp+50h] BYREF
  _QWORD v27[2]; // [rsp+E0h] [rbp+60h] BYREF

  v27[0] = a2;
  v27[1] = a3;
  v26[0] = a4;
  v26[1] = a5;
  v7 = qword_7FF705405558[a1];
  v25[0] = dword_7FF705405548 + dword_7FF705405548[a1];
  v25[1] = v7;
  if ( *a6 )
  {
    v9 = *a6;
    v10 = a6[1];
    v11[2] = a6[2];
    v11[1] = v10;
    v11[0] = v9;
    v12 = v25;
    v13 = sub_7FF7053FC5C0;
    v14 = v11;
    v15 = sub_7FF7053F9210;
    v16 = v27;
    v17 = sub_7FF7053FC5A0;
    v20 = &off_7FF705404890;
    v8 = 4LL;
    v21 = 4LL;
    v24 = 0LL;
    v18 = v26;
    v19 = sub_7FF7053FC5A0;
  }
  else
  {
    v12 = v25;
    v13 = sub_7FF7053FC5C0;
    v14 = v27;
    v15 = sub_7FF7053FC5A0;
    v20 = &off_7FF705404840;
    v8 = 3LL;
    v21 = 3LL;
    v24 = 0LL;
    v16 = v26;
    v17 = sub_7FF7053FC5A0;
  }
  v22 = &v12;
  v23 = v8;
  sub_7FF7053FE110(&v20, a7);
}
// 7FF705404840: using guessed type char *off_7FF705404840;
// 7FF705404890: using guessed type char *off_7FF705404890;
// 7FF705405548: using guessed type int dword_7FF705405548[4];
// 7FF705405558: using guessed type _QWORD qword_7FF705405558[3];

//----- (00007FF7053FE440) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE440(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  _QWORD v5[6]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v6[4]; // [rsp+50h] [rbp-30h] BYREF
  _QWORD v7[2]; // [rsp+70h] [rbp-10h] BYREF
  _QWORD v8[2]; // [rsp+80h] [rbp+0h] BYREF

  v8[0] = a1;
  v8[1] = a2;
  v7[0] = a3;
  v7[1] = a4;
  v6[0] = v8;
  v6[1] = sub_7FF7053FC5C0;
  v6[2] = v7;
  v6[3] = sub_7FF7053FC5A0;
  v5[0] = &unk_7FF7054048D8;
  v5[1] = 2LL;
  v5[4] = 0LL;
  v5[2] = v6;
  v5[3] = 2LL;
  sub_7FF7053FE110(v5, a5);
}

//----- (00007FF7053FE4D0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE4D0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_7FF7053FE5E0(a1, a2, a3);
}

//----- (00007FF7053FE4E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE4E0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_7FF7053FE650(a1, a2, a3);
}

//----- (00007FF7053FE4F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE4F0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_7FF7053FE6C0(a1, a2, a3);
}

//----- (00007FF7053FE500) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE500(
        _BYTE *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5)
{
  sub_7FF7053FB760(a1, a2, a3, a4, a5);
}

//----- (00007FF7053FE520) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE520(__int64 a1)
{
  _QWORD v1[3]; // [rsp+20h] [rbp-30h] BYREF
  __int128 v2; // [rsp+38h] [rbp-18h]

  v1[0] = &off_7FF705404670;
  v1[1] = 1LL;
  v1[2] = 8LL;
  v2 = 0LL;
  sub_7FF7053FE110(v1, a1);
}
// 7FF705404670: using guessed type char *off_7FF705404670;

//----- (00007FF7053FE560) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE560(__int64 a1)
{
  _QWORD v1[3]; // [rsp+20h] [rbp-30h] BYREF
  __int128 v2; // [rsp+38h] [rbp-18h]

  v1[0] = &off_7FF7054046A8;
  v1[1] = 1LL;
  v1[2] = 8LL;
  v2 = 0LL;
  sub_7FF7053FE110(v1, a1);
}
// 7FF7054046A8: using guessed type char *off_7FF7054046A8;

//----- (00007FF7053FE5A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE5A0(__int64 a1)
{
  _QWORD v1[3]; // [rsp+20h] [rbp-30h] BYREF
  __int128 v2; // [rsp+38h] [rbp-18h]

  v1[0] = &off_7FF7054053E0;
  v1[1] = 1LL;
  v1[2] = 8LL;
  v2 = 0LL;
  sub_7FF7053FE110(v1, a1);
}
// 7FF7054053E0: using guessed type char *off_7FF7054053E0;

//----- (00007FF7053FE5E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE5E0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[6]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v4[4]; // [rsp+50h] [rbp-30h] BYREF
  __int64 v5; // [rsp+70h] [rbp-10h] BYREF
  __int64 v6; // [rsp+78h] [rbp-8h] BYREF

  v6 = a1;
  v5 = a2;
  v4[0] = &v6;
  v4[1] = sub_7FF7053FC390;
  v4[2] = &v5;
  v4[3] = sub_7FF7053FC390;
  v3[0] = &off_7FF705405428;
  v3[1] = 2LL;
  v3[4] = 0LL;
  v3[2] = v4;
  v3[3] = 2LL;
  sub_7FF7053FE110(v3, a3);
}
// 7FF705405428: using guessed type char *off_7FF705405428;

//----- (00007FF7053FE650) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE650(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[6]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v4[4]; // [rsp+50h] [rbp-30h] BYREF
  __int64 v5; // [rsp+70h] [rbp-10h] BYREF
  __int64 v6; // [rsp+78h] [rbp-8h] BYREF

  v6 = a1;
  v5 = a2;
  v4[0] = &v6;
  v4[1] = sub_7FF7053FC390;
  v4[2] = &v5;
  v4[3] = sub_7FF7053FC390;
  v3[0] = &off_7FF705405458;
  v3[1] = 2LL;
  v3[4] = 0LL;
  v3[2] = v4;
  v3[3] = 2LL;
  sub_7FF7053FE110(v3, a3);
}
// 7FF705405458: using guessed type char *off_7FF705405458;

//----- (00007FF7053FE6C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall __noreturn sub_7FF7053FE6C0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[6]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v4[4]; // [rsp+50h] [rbp-30h] BYREF
  __int64 v5; // [rsp+70h] [rbp-10h] BYREF
  __int64 v6; // [rsp+78h] [rbp-8h] BYREF

  v6 = a1;
  v5 = a2;
  v4[0] = &v6;
  v4[1] = sub_7FF7053FC390;
  v4[2] = &v5;
  v4[3] = sub_7FF7053FC390;
  v3[0] = &off_7FF7054054A0;
  v3[1] = 2LL;
  v3[4] = 0LL;
  v3[2] = v4;
  v3[3] = 2LL;
  sub_7FF7053FE110(v3, a3);
}
// 7FF7054054A0: using guessed type char *off_7FF7054054A0;

// #eh34_calls=0 #try=10 #catch=12 #wind=0 #gotos=647
// nfuncs=649 queued=449 decompiled=449 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 449 function(s)"
